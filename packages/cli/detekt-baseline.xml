<?xml version='1.0' encoding='UTF-8'?>
<SmellBaseline>
  <ManuallySuppressedIssues/>
  <CurrentIssues>
    <ID>ComplexCondition:RuntimeWorkdirManager.kt$RuntimeWorkdirManager$(base != null &amp;&amp; (base.parentFile == null || base.absolutePath == "/")) || files.isEmpty()</ID>
    <ID>CyclomaticComplexMethod:ToolShellCommand.kt$ToolShellCommand$override fun PolyglotEngineConfiguration.configureEngine(langs: Set&lt;GuestLanguage>)</ID>
    <ID>CyclomaticComplexMethod:ToolShellCommand.kt$ToolShellCommand$override suspend fun CommandContext.invoke(state: ToolContext&lt;ToolState>): CommandResult</ID>
    <ID>CyclomaticComplexMethod:ToolShellCommand.kt$ToolShellCommand$private fun displayFormattedError( exc: Throwable, message: String, advice: String? = null, internal: Boolean = false, stacktrace: Boolean = internal, withCause: Boolean = true, )</ID>
    <ID>EmptyFunctionBlock:BuildOutput.kt$BaseOutput${ }</ID>
    <ID>EmptyFunctionBlock:BuildOutput.kt$BaseOutput.&lt;no name provided>${ }</ID>
    <ID>ForbiddenComment:DelegatedToolCommand.kt$DelegatedToolCommand$// @TODO: delegated error handling</ID>
    <ID>ForbiddenComment:ToolProjectCommand.kt$ToolProjectCommand$// @TODO: rename this to classes so that sources can be embedded clearly in jars</ID>
    <ID>ForbiddenComment:ToolShellCommand.kt$ToolShellCommand$// @TODO: use manifest to resolve versions</ID>
    <ID>LongMethod:InitCommand.kt$InitCommand$@Suppress("ReturnCount", "CyclomaticComplexMethod") override suspend fun CommandContext.invoke(state: ToolContext&lt;ToolState>): CommandResult</ID>
    <ID>LongMethod:ToolShellCommand.kt$ToolShellCommand$override fun PolyglotEngineConfiguration.configureEngine(langs: Set&lt;GuestLanguage>)</ID>
    <ID>LongMethod:ToolShellCommand.kt$ToolShellCommand$override suspend fun CommandContext.invoke(state: ToolContext&lt;ToolState>): CommandResult</ID>
    <ID>LongMethod:ToolShellCommand.kt$ToolShellCommand$private fun CommandContext.readRunTests( label: String, language: GuestLanguage, ctxAccessor: ContextAccessor, source: List&lt;Source>, execProvider: GuestExecutorProvider, )</ID>
    <ID>LongMethod:ToolShellCommand.kt$ToolShellCommand$private fun displayFormattedError( exc: Throwable, message: String, advice: String? = null, internal: Boolean = false, stacktrace: Boolean = internal, withCause: Boolean = true, )</ID>
    <ID>LoopWithTooManyJumpStatements:ToolShellCommand.kt$ToolShellCommand$while</ID>
    <ID>MagicNumber:RuntimeWorkdirManager.kt$RuntimeWorkdirManager$15</ID>
    <ID>MagicNumber:SubprocessRunner.kt$100</ID>
    <ID>MagicNumber:ToolShellCommand.kt$ToolShellCommand$1000L</ID>
    <ID>MagicNumber:ToolShellCommand.kt$ToolShellCommand$120</ID>
    <ID>MagicNumber:ToolShellCommand.kt$ToolShellCommand$40</ID>
    <ID>MagicNumber:ToolShellCommand.kt$ToolShellCommand$80</ID>
    <ID>MatchingDeclarationName:SanityTests.kt$SanitySelfTest : SelfTest</ID>
    <ID>ReturnCount:ExecutionController.kt$ExecutionController$private fun toHost(polyglotException: PolyglotException): Throwable</ID>
    <ID>ReturnCount:RuntimeWorkdirManager.kt$RuntimeWorkdirManager$private fun nearestDirectoryWithAnyOfTheseFiles( files: Array&lt;String>, base: File? = null, depth: Int? = null, ): File?</ID>
    <ID>ReturnCount:ToolShellCommand.kt$ToolShellCommand$override suspend fun CommandContext.invoke(state: ToolContext&lt;ToolState>): CommandResult</ID>
    <ID>ReturnCount:ToolShellCommand.kt$ToolShellCommand$private fun highlightLineMaybe(line: String, langId: String?): Pair&lt;String, Int></ID>
    <ID>SpreadOperator:ToolInvokeCommand.kt$ToolInvokeCommand$(*selectedTools.map { it to buildArgs(action, it) }.toTypedArray())</ID>
    <ID>SwallowedException:PersistedError.kt$PersistedError.RuntimeInfo$err: Throwable</ID>
    <ID>TooGenericExceptionCaught:AbstractToolCommand.kt$AbstractToolCommand$err: Throwable</ID>
    <ID>TooGenericExceptionCaught:CommandTestRunner.kt$CommandTestRunner$thr: Throwable</ID>
    <ID>TooGenericExceptionCaught:PersistedError.kt$PersistedError.RuntimeInfo$err: Throwable</ID>
    <ID>TooGenericExceptionCaught:TestContext.kt$TestContext.Companion$err: Throwable</ID>
    <ID>TooGenericExceptionCaught:ToolInvokeCommand.kt$ToolInvokeCommand$err: Throwable</ID>
    <ID>TopLevelPropertyNaming:ToolInvokeCommand.kt$private const val jsHint = "package.json"</ID>
    <ID>TopLevelPropertyNaming:ToolInvokeCommand.kt$private const val pyHint = "requirements.txt"</ID>
    <ID>UnusedPrivateMember:BuildOutput.kt$Animated$private fun transferLayout()</ID>
    <ID>UnusedPrivateProperty:AbstractToolCommand.kt$AbstractToolCommand$// Initialization state. private val initialized: AtomicBoolean = AtomicBoolean(false)</ID>
    <ID>UnusedPrivateProperty:AddCommand.kt$AddCommand$@Inject private lateinit var projectManagerProvider: Provider&lt;ProjectManager></ID>
    <ID>UnusedPrivateProperty:BuildOutput.kt$Animated$// Main progress renderer. private val progress = layout.animateInCoroutine( terminal = terminal, )</ID>
    <ID>UnusedPrivateProperty:BuildOutput.kt$Animated$// Top-level build task. private val topTask = taskLayout()</ID>
    <ID>UnusedPrivateProperty:BuildOutput.kt$Animated$private val activeContext = atomic(ProgressContext())</ID>
    <ID>UnusedPrivateProperty:ExecutionController.kt$ExecutionController$private val tRunException: Lazy&lt;Value> = Lazy.of { loadClass("jdk.jshell.spi.ExecutionControl\$RunException") }</ID>
    <ID>UnusedPrivateProperty:NativeImageAdapter.kt$NativeImageAdapter$val totalMs = compileEnd - compileStart</ID>
    <ID>UnusedPrivateProperty:ToolInvokeCommand.kt$// Sub-commands for Orogene. private val orogeneActions = sortedSetOf( "add", "apply", "login", "logout", "ping", "reapply", "remove", "view", "help", )</ID>
    <ID>UnusedPrivateProperty:ToolInvokeCommand.kt$// Sub-commands for Uv. private val uvActions = sortedSetOf( "pip", "tool", "toolchain", "venv", "cache", "self", "version", "help", )</ID>
    <ID>UnusedPrivateProperty:ToolTestCommand.kt$ToolTestCommand$@Inject private lateinit var projectManager: Provider&lt;ProjectManager></ID>
    <ID>VariableNaming:InspectorConfig.kt$InspectorConfig$/** Specifies whether the inspector should suspend for internal (facade) sources. */ @Option( names = ["--inspect:internal"], description = ["Specifies whether the inspector should suspend for internal (facade) sources"], defaultValue = "false", hidden = false, ) internal var `internal`: Boolean = false</ID>
  </CurrentIssues>
</SmellBaseline>
