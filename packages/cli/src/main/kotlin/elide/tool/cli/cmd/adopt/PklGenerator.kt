/*
 * Copyright (c) 2024-2025 Elide Technologies, Inc.
 *
 * Licensed under the MIT license (the "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   https://opensource.org/license/mit/
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under the License.
 */

package elide.tool.cli.cmd.adopt

/**
 * Generates elide.pkl content from various build system descriptors.
 *
 * This generator creates well-formatted, documented PKL configuration files
 * with helpful comments and organized sections.
 */
object PklGenerator {
  /**
   * Generate a header comment block explaining the conversion.
   */
  private fun generatedHeader(buildSystem: String, sourceFile: String? = null): String = buildString {
    appendLine("// ═══════════════════════════════════════════════════════════════════════════════")
    appendLine("//")
    appendLine("//  Elide Project Configuration")
    appendLine("//  Generated from $buildSystem")
    if (sourceFile != null) {
      appendLine("//  Source: $sourceFile")
    }
    appendLine("//")
    appendLine("//  This file was automatically generated by `elide adopt`.")
    appendLine("//  You may customize it to fit your project's needs.")
    appendLine("//")
    appendLine("// ═══════════════════════════════════════════════════════════════════════════════")
    appendLine()
  }

  /**
   * Generate a section comment to organize the PKL file.
   */
  private fun sectionComment(title: String): String = buildString {
    appendLine()
    appendLine("// ─── $title ─────────────────────────────────────────────────────────")
    appendLine()
  }

  /**
   * Generate elide.pkl content for a multi-module project.
   *
   * @param parentPom The parent/aggregator POM
   * @param modulePoms List of child module POMs
   */
  fun generateMultiModule(parentPom: PomDescriptor, modulePoms: List<PomDescriptor>): String = buildString {
    // Header
    appendLine("amends \"elide:project.pkl\"")
    appendLine()

    // Project metadata from parent
    appendLine("name = \"${parentPom.artifactId}\"")
    if (parentPom.description != null) {
      appendLine("description = \"${parentPom.description.escapeQuotes()}\"")
    }
    if (parentPom.version.isNotBlank()) {
      appendLine("version = \"${parentPom.version}\"")
    }
    appendLine()

    // Workspaces block
    if (parentPom.modules.isNotEmpty()) {
      appendLine("workspaces {")
      parentPom.modules.forEach { module ->
        appendLine("  \"$module\"")
      }
      appendLine("}")
      appendLine()
    }

    // Aggregate all dependencies from all modules
    val allCompileDeps = mutableSetOf<Dependency>()
    val allTestDeps = mutableSetOf<Dependency>()
    val allRepositories = mutableSetOf<Repository>()

    // Include parent dependencies and repositories
    allCompileDeps.addAll(parentPom.dependencies.filter { it.scope == "compile" || it.scope == "runtime" })
    allTestDeps.addAll(parentPom.dependencies.filter { it.scope == "test" })
    allRepositories.addAll(parentPom.repositories)

    // Include module dependencies and repositories
    modulePoms.forEach { modulePom ->
      allCompileDeps.addAll(modulePom.dependencies.filter { it.scope == "compile" || it.scope == "runtime" })
      allTestDeps.addAll(modulePom.dependencies.filter { it.scope == "test" })
      allRepositories.addAll(modulePom.repositories)
    }

    // Filter out inter-module dependencies
    val moduleCoordinates = modulePoms.map { "${it.groupId}:${it.artifactId}" }.toSet()
    val compileDeps = allCompileDeps.filterNot { dep ->
      "${dep.groupId}:${dep.artifactId}" in moduleCoordinates
    }
    val testDeps = allTestDeps.filterNot { dep ->
      "${dep.groupId}:${dep.artifactId}" in moduleCoordinates
    }
    val repositories = allRepositories.toList()

    // Dependencies section
    if (compileDeps.isNotEmpty() || testDeps.isNotEmpty() || repositories.isNotEmpty()) {
      appendLine("dependencies {")
      appendLine("  maven {")

      // Repositories - always include Maven Central (Super POM default)
      val hasMavenCentral = repositories.any {
        it.url.contains("repo.maven.apache.org") || it.url.contains("repo1.maven.org")
      }

      appendLine("    repositories {")

      // Add Maven Central if not already present (Super POM implicit default)
      if (!hasMavenCentral) {
        appendLine("      [\"central\"] = \"https://repo.maven.apache.org/maven2\"  // Maven Central (Super POM default)")
      }

      // Add custom repositories
      repositories.forEach { repo ->
        if (repo.name != null) {
          appendLine("      [\"${repo.id}\"] = \"${repo.url}\"  // ${repo.name}")
        } else {
          appendLine("      [\"${repo.id}\"] = \"${repo.url}\"")
        }
      }
      appendLine("    }")

      // Compile dependencies
      if (compileDeps.isNotEmpty()) {
        appendLine("    packages {")
        compileDeps.sortedBy { it.coordinate() }.forEach { dep ->
          appendLine("      \"${dep.coordinate()}\"")
        }
        appendLine("    }")
      }

      // Test dependencies
      if (testDeps.isNotEmpty()) {
        appendLine("    testPackages {")
        testDeps.sortedBy { it.coordinate() }.forEach { dep ->
          appendLine("      \"${dep.coordinate()}\"")
        }
        appendLine("    }")
      }

      appendLine("  }")
      appendLine("}")
      appendLine()
    }

    // Note about multi-module structure
    appendLine("// Note: This is a multi-module Maven project with ${modulePoms.size} module(s).")
    appendLine("// Dependencies are aggregated from all modules. Inter-module dependencies are excluded.")
  }

  /**
   * Generate elide.pkl content from a POM descriptor.
   */
  fun generate(pom: PomDescriptor): String = buildString {
    // Generated header
    append(generatedHeader("Maven", "pom.xml"))

    // Header
    appendLine("amends \"elide:project.pkl\"")
    appendLine()

    // Project metadata
    append(sectionComment("Project Metadata"))
    appendLine("name = \"${pom.artifactId}\"")
    if (pom.description != null) {
      appendLine("description = \"${pom.description.escapeQuotes()}\"")
    }
    appendLine()

    // Dependencies section
    append(sectionComment("Dependencies"))
    val compileDeps = pom.dependencies.filter { it.scope == "compile" || it.scope == "runtime" }.sortedBy { it.coordinate() }
    val testDeps = pom.dependencies.filter { it.scope == "test" }.sortedBy { it.coordinate() }

    if (compileDeps.isNotEmpty() || testDeps.isNotEmpty() || pom.repositories.isNotEmpty()) {
      appendLine("dependencies {")
      appendLine("  maven {")

      // Repositories - always include Maven Central (Super POM default)
      val hasMavenCentral = pom.repositories.any {
        it.url.contains("repo.maven.apache.org") || it.url.contains("repo1.maven.org")
      }

      appendLine("    repositories {")

      // Add Maven Central if not already present (Super POM implicit default)
      if (!hasMavenCentral) {
        appendLine("      [\"central\"] = \"https://repo.maven.apache.org/maven2\"  // Maven Central (Super POM default)")
      }

      // Add custom repositories
      pom.repositories.forEach { repo ->
        if (repo.name != null) {
          appendLine("      [\"${repo.id}\"] = \"${repo.url}\"  // ${repo.name}")
        } else {
          appendLine("      [\"${repo.id}\"] = \"${repo.url}\"")
        }
      }
      appendLine("    }")

      // Compile dependencies
      if (compileDeps.isNotEmpty()) {
        appendLine("    packages {")
        compileDeps.forEach { dep ->
          appendLine("      \"${dep.coordinate()}\"")
        }
        appendLine("    }")
      }

      // Test dependencies
      if (testDeps.isNotEmpty()) {
        appendLine("    testPackages {")
        testDeps.forEach { dep ->
          appendLine("      \"${dep.coordinate()}\"")
        }
        appendLine("    }")
      }

      appendLine("  }")
      appendLine("}")
      appendLine()
    }

    // Source mappings
    appendLine("sources {")
    appendLine("  [\"main\"] = \"src/main/java/**/*.java\"")
    appendLine("  [\"test\"] = \"src/test/java/**/*.java\"")
    appendLine("}")
  }

  /**
   * Generate elide.pkl content from a Gradle project descriptor.
   *
   * @param gradle The Gradle project descriptor
   */
  internal fun generate(gradle: GradleDescriptor): String = buildString {
    // Generated header
    append(generatedHeader("Gradle", "build.gradle / build.gradle.kts"))

    // Header
    appendLine("amends \"elide:project.pkl\"")
    appendLine()

    // Project metadata
    append(sectionComment("Project Metadata"))
    appendLine("name = \"${gradle.name}\"")
    if (gradle.description != null) {
      appendLine("description = \"${gradle.description.escapeQuotes()}\"")
    }
    if (gradle.version != "unspecified" && gradle.version.isNotBlank()) {
      appendLine("version = \"${gradle.version}\"")
    }
    appendLine()

    // Dependencies section
    append(sectionComment("Dependencies"))
    val allDeps = gradle.dependencies
    val compileOnlyDeps = allDeps.filter { it.isCompileOnly() && !it.isTestScope() }.sortedBy { it.coordinate() }
    val compileDeps = allDeps.filterNot { it.isTestScope() || it.isCompileOnly() }.sortedBy { it.coordinate() }
    val testDeps = allDeps.filter { it.isTestScope() && !it.isCompileOnly() }.sortedBy { it.coordinate() }
    val testCompileOnlyDeps = allDeps.filter { it.isTestScope() && it.isCompileOnly() }.sortedBy { it.coordinate() }

    if (compileDeps.isNotEmpty() || testDeps.isNotEmpty() || gradle.repositories.isNotEmpty()) {
      appendLine("dependencies {")
      appendLine("  maven {")

      // Repositories
      if (gradle.repositories.isNotEmpty()) {
        appendLine("    repositories {")
        gradle.repositories.forEach { repo ->
          appendLine("      [\"${repo.name}\"] = \"${repo.url}\"")
        }
        appendLine("    }")
        appendLine()
      }

      // Compile dependencies
      if (compileDeps.isNotEmpty()) {
        appendLine("    packages {")
        compileDeps.forEach { dep ->
          appendLine("      \"${dep.coordinate()}\"")
        }
        appendLine("    }")
      }

      // Test dependencies
      if (testDeps.isNotEmpty()) {
        if (compileDeps.isNotEmpty()) appendLine()
        appendLine("    testPackages {")
        testDeps.forEach { dep ->
          appendLine("      \"${dep.coordinate()}\"")
        }
        appendLine("    }")
      }

      appendLine("  }")
      appendLine("}")
      appendLine()
    }

    // CompileOnly dependencies (listed as comments)
    if (compileOnlyDeps.isNotEmpty()) {
      appendLine("// Compile-only dependencies (not included at runtime):")
      appendLine("// These are typically annotation processors, Lombok, or provided libraries")
      compileOnlyDeps.forEach { dep ->
        appendLine("//   - ${dep.coordinate()}")
      }
      appendLine()
    }

    // Test compileOnly dependencies (listed as comments)
    if (testCompileOnlyDeps.isNotEmpty()) {
      appendLine("// Test compile-only dependencies (not included in test runtime):")
      testCompileOnlyDeps.forEach { dep ->
        appendLine("//   - ${dep.coordinate()}")
      }
      appendLine()
    }

    // Composite builds (included builds)
    if (gradle.includedBuilds.isNotEmpty()) {
      appendLine("// Composite builds detected (included builds):")
      appendLine("// These are separate Gradle builds included in this project.")
      appendLine("// Manual conversion may be needed for each included build.")
      gradle.includedBuilds.forEach { includedBuild ->
        appendLine("//   - $includedBuild")
      }
      appendLine()
    }

    // Build warnings
    if (gradle.plugins.isNotEmpty()) {
      appendLine("// Build plugins detected (manual conversion may be needed):")
      gradle.plugins.forEach { plugin ->
        val pluginStr = if (plugin.version != null) {
          "//   - ${plugin.id}:${plugin.version}"
        } else {
          "//   - ${plugin.id}"
        }
        appendLine(pluginStr)
      }
      appendLine()
    }

    // Source mappings (Gradle defaults)
    appendLine("sources {")
    appendLine("  [\"main\"] = \"src/main/java/**/*.java\"")
    appendLine("  [\"test\"] = \"src/test/java/**/*.java\"")
    appendLine("}")
  }

  /**
   * Generate elide.pkl content for a multi-module Gradle project.
   *
   * @param rootProject The root Gradle project
   * @param subprojects List of subproject descriptors
   */
  internal fun generateMultiModule(rootProject: GradleDescriptor, subprojects: List<GradleDescriptor>): String = buildString {
    // Header
    appendLine("amends \"elide:project.pkl\"")
    appendLine()

    // Project metadata from root
    appendLine("name = \"${rootProject.name}\"")
    if (rootProject.description != null) {
      appendLine("description = \"${rootProject.description.escapeQuotes()}\"")
    }
    if (rootProject.version != "unspecified" && rootProject.version.isNotBlank()) {
      appendLine("version = \"${rootProject.version}\"")
    }
    appendLine()

    // Workspaces block
    if (rootProject.modules.isNotEmpty()) {
      appendLine("workspaces {")
      rootProject.modules.forEach { module ->
        appendLine("  \"$module\"")
      }
      appendLine("}")
      appendLine()
    }

    // Aggregate all dependencies from all subprojects
    val allCompileDeps = mutableSetOf<GradleDescriptor.Dependency>()
    val allTestDeps = mutableSetOf<GradleDescriptor.Dependency>()
    val allCompileOnlyDeps = mutableSetOf<GradleDescriptor.Dependency>()
    val allTestCompileOnlyDeps = mutableSetOf<GradleDescriptor.Dependency>()
    val allRepositories = mutableSetOf<GradleDescriptor.Repository>()

    // Include root dependencies and repositories
    allCompileDeps.addAll(rootProject.dependencies.filterNot { it.isTestScope() || it.isCompileOnly() })
    allTestDeps.addAll(rootProject.dependencies.filter { it.isTestScope() && !it.isCompileOnly() })
    allCompileOnlyDeps.addAll(rootProject.dependencies.filter { it.isCompileOnly() && !it.isTestScope() })
    allTestCompileOnlyDeps.addAll(rootProject.dependencies.filter { it.isTestScope() && it.isCompileOnly() })
    allRepositories.addAll(rootProject.repositories)

    // Include subproject dependencies and repositories
    subprojects.forEach { subproject ->
      allCompileDeps.addAll(subproject.dependencies.filterNot { it.isTestScope() || it.isCompileOnly() })
      allTestDeps.addAll(subproject.dependencies.filter { it.isTestScope() && !it.isCompileOnly() })
      allCompileOnlyDeps.addAll(subproject.dependencies.filter { it.isCompileOnly() && !it.isTestScope() })
      allTestCompileOnlyDeps.addAll(subproject.dependencies.filter { it.isTestScope() && it.isCompileOnly() })
      allRepositories.addAll(subproject.repositories)
    }

    // Dependencies section
    if (allCompileDeps.isNotEmpty() || allTestDeps.isNotEmpty() || allRepositories.isNotEmpty()) {
      appendLine("dependencies {")
      appendLine("  maven {")

      // Repositories
      if (allRepositories.isNotEmpty()) {
        appendLine("    repositories {")
        allRepositories.forEach { repo ->
          appendLine("      [\"${repo.name}\"] = \"${repo.url}\"")
        }
        appendLine("    }")
        appendLine()
      }

      // Compile dependencies
      if (allCompileDeps.isNotEmpty()) {
        appendLine("    packages {")
        allCompileDeps.forEach { dep ->
          appendLine("      \"${dep.coordinate()}\"")
        }
        appendLine("    }")
      }

      // Test dependencies
      if (allTestDeps.isNotEmpty()) {
        if (allCompileDeps.isNotEmpty()) appendLine()
        appendLine("    testPackages {")
        allTestDeps.forEach { dep ->
          appendLine("      \"${dep.coordinate()}\"")
        }
        appendLine("    }")
      }

      appendLine("  }")
      appendLine("}")
      appendLine()
    }

    // CompileOnly dependencies (listed as comments)
    if (allCompileOnlyDeps.isNotEmpty()) {
      appendLine("// Compile-only dependencies (not included at runtime):")
      appendLine("// These are typically annotation processors, Lombok, or provided libraries")
      allCompileOnlyDeps.forEach { dep ->
        appendLine("//   - ${dep.coordinate()}")
      }
      appendLine()
    }

    // Test compileOnly dependencies (listed as comments)
    if (allTestCompileOnlyDeps.isNotEmpty()) {
      appendLine("// Test compile-only dependencies (not included in test runtime):")
      allTestCompileOnlyDeps.forEach { dep ->
        appendLine("//   - ${dep.coordinate()}")
      }
      appendLine()
    }

    // Composite builds (aggregate all included builds)
    val allIncludedBuilds = (rootProject.includedBuilds + subprojects.flatMap { it.includedBuilds }).distinct()
    if (allIncludedBuilds.isNotEmpty()) {
      appendLine("// Composite builds detected (included builds):")
      appendLine("// These are separate Gradle builds included in this project.")
      appendLine("// Manual conversion may be needed for each included build.")
      allIncludedBuilds.forEach { includedBuild ->
        appendLine("//   - $includedBuild")
      }
      appendLine()
    }

    // Build warnings (aggregate all plugins)
    val allPlugins = (rootProject.plugins + subprojects.flatMap { it.plugins }).distinctBy { it.id }
    if (allPlugins.isNotEmpty()) {
      appendLine("// Build plugins detected (manual conversion may be needed):")
      allPlugins.forEach { plugin ->
        val pluginStr = if (plugin.version != null) {
          "//   - ${plugin.id}:${plugin.version}"
        } else {
          "//   - ${plugin.id}"
        }
        appendLine(pluginStr)
      }
      appendLine()
    }

    // Source mappings (Gradle defaults)
    appendLine("sources {")
    appendLine("  [\"main\"] = \"src/main/java/**/*.java\"")
    appendLine("  [\"test\"] = \"src/test/java/**/*.java\"")
    appendLine("}")
  }

  /**
   * Generate elide.pkl content from a package.json descriptor.
   *
   * @param pkg The package.json descriptor
   */
  internal fun generate(pkg: PackageJsonDescriptor): String = buildString {
    // Generated header
    append(generatedHeader("Node.js", "package.json"))

    // Header
    appendLine("amends \"elide:project.pkl\"")
    appendLine()

    // Project metadata
    append(sectionComment("Project Metadata"))
    appendLine("name = \"${pkg.name}\"")
    if (pkg.description != null) {
      appendLine("description = \"${pkg.description.escapeQuotes()}\"")
    }
    if (pkg.version != null) {
      appendLine("version = \"${pkg.version}\"")
    }
    appendLine()

    // Dependencies section
    append(sectionComment("Dependencies"))
    val prodDeps = pkg.dependencies.toSortedMap()
    val devDeps = pkg.devDependencies.toSortedMap()
    val peerDeps = pkg.peerDependencies.toSortedMap()
    val optionalDeps = pkg.optionalDependencies.toSortedMap()

    if (prodDeps.isNotEmpty() || devDeps.isNotEmpty()) {
      appendLine("dependencies {")
      appendLine("  npm {")

      // Production dependencies
      if (prodDeps.isNotEmpty()) {
        appendLine("    packages {")
        prodDeps.forEach { (name, version) ->
          val versionSpec = if (version.startsWith("^") || version.startsWith("~") || version.startsWith(">=")) {
            version
          } else {
            "^$version"
          }
          appendLine("      \"$name@$versionSpec\"")
        }
        appendLine("    }")
      }

      // Development dependencies
      if (devDeps.isNotEmpty()) {
        if (prodDeps.isNotEmpty()) appendLine()
        appendLine("    testPackages {")
        devDeps.forEach { (name, version) ->
          val versionSpec = if (version.startsWith("^") || version.startsWith("~") || version.startsWith(">=")) {
            version
          } else {
            "^$version"
          }
          appendLine("      \"$name@$versionSpec\"")
        }
        appendLine("    }")
      }

      appendLine("  }")
      appendLine("}")
      appendLine()
    }

    // Peer dependencies (listed as comments)
    if (peerDeps.isNotEmpty()) {
      appendLine("// Peer dependencies (should be provided by the consuming application):")
      peerDeps.forEach { (name, version) ->
        appendLine("//   - $name@$version")
      }
      appendLine()
    }

    // Optional dependencies (listed as comments)
    if (optionalDeps.isNotEmpty()) {
      appendLine("// Optional dependencies:")
      optionalDeps.forEach { (name, version) ->
        appendLine("//   - $name@$version")
      }
      appendLine()
    }

    // NPM scripts (listed as comments)
    if (pkg.scripts.isNotEmpty()) {
      appendLine("// NPM scripts (may need manual conversion):")
      pkg.scripts.forEach { (name, script) ->
        appendLine("//   $name: $script")
      }
      appendLine()
    }

    // Source mappings (Node.js defaults)
    appendLine("sources {")
    appendLine("  [\"main\"] = \"src/**/*.{js,ts,jsx,tsx}\"")
    appendLine("  [\"test\"] = \"test/**/*.{js,ts,jsx,tsx}\"")
    appendLine("}")
  }

  /**
   * Generate elide.pkl content for a Node.js workspace/monorepo project.
   *
   * @param rootPkg The root package.json descriptor
   * @param workspacePackages List of workspace package descriptors
   */
  internal fun generateWorkspace(
    rootPkg: PackageJsonDescriptor,
    workspacePackages: List<PackageJsonDescriptor>
  ): String = buildString {
    // Header
    appendLine("amends \"elide:project.pkl\"")
    appendLine()

    // Project metadata from root
    appendLine("name = \"${rootPkg.name}\"")
    if (rootPkg.description != null) {
      appendLine("description = \"${rootPkg.description.escapeQuotes()}\"")
    }
    if (rootPkg.version != null) {
      appendLine("version = \"${rootPkg.version}\"")
    }
    appendLine()

    // Workspaces block
    if (rootPkg.workspaces.isNotEmpty()) {
      appendLine("workspaces {")
      rootPkg.workspaces.forEach { workspace ->
        appendLine("  \"$workspace\"")
      }
      appendLine("}")
      appendLine()
    }

    // Aggregate all dependencies from all workspace packages
    val allProdDeps = mutableMapOf<String, String>()
    val allDevDeps = mutableMapOf<String, String>()
    val allPeerDeps = mutableMapOf<String, String>()

    // Include root dependencies
    allProdDeps.putAll(rootPkg.dependencies)
    allDevDeps.putAll(rootPkg.devDependencies)
    allPeerDeps.putAll(rootPkg.peerDependencies)

    // Include workspace package dependencies
    workspacePackages.forEach { pkg ->
      allProdDeps.putAll(pkg.dependencies)
      allDevDeps.putAll(pkg.devDependencies)
      allPeerDeps.putAll(pkg.peerDependencies)
    }

    // Filter out workspace internal dependencies
    val workspacePackageNames = workspacePackages.map { it.name }.toSet()
    val prodDeps = allProdDeps.filterKeys { it !in workspacePackageNames }
    val devDeps = allDevDeps.filterKeys { it !in workspacePackageNames }
    val peerDeps = allPeerDeps.filterKeys { it !in workspacePackageNames }

    // Dependencies section
    if (prodDeps.isNotEmpty() || devDeps.isNotEmpty()) {
      appendLine("dependencies {")
      appendLine("  npm {")

      // Production dependencies
      if (prodDeps.isNotEmpty()) {
        appendLine("    packages {")
        prodDeps.toSortedMap().forEach { (name, version) ->
          val versionSpec = if (version.startsWith("^") || version.startsWith("~") || version.startsWith(">=")) {
            version
          } else {
            "^$version"
          }
          appendLine("      \"$name@$versionSpec\"")
        }
        appendLine("    }")
      }

      // Development dependencies
      if (devDeps.isNotEmpty()) {
        if (prodDeps.isNotEmpty()) appendLine()
        appendLine("    testPackages {")
        devDeps.toSortedMap().forEach { (name, version) ->
          val versionSpec = if (version.startsWith("^") || version.startsWith("~") || version.startsWith(">=")) {
            version
          } else {
            "^$version"
          }
          appendLine("      \"$name@$versionSpec\"")
        }
        appendLine("    }")
      }

      appendLine("  }")
      appendLine("}")
      appendLine()
    }

    // Peer dependencies (listed as comments)
    if (peerDeps.isNotEmpty()) {
      appendLine("// Peer dependencies (should be provided by the consuming application):")
      peerDeps.toSortedMap().forEach { (name, version) ->
        appendLine("//   - $name@$version")
      }
      appendLine()
    }

    // Note about workspace structure
    appendLine("// Note: This is a Node.js workspace/monorepo project with ${workspacePackages.size} workspace(s).")
    appendLine("// Dependencies are aggregated from all workspaces. Workspace-internal dependencies are excluded.")
  }

  /**
   * Generate elide.pkl from a Bazel project descriptor.
   *
   * @param bazel Bazel project descriptor
   * @return Generated elide.pkl content
   */
  internal fun generate(bazel: BazelDescriptor): String = buildString {
    // Generated header
    append(generatedHeader("Bazel", "WORKSPACE / MODULE.bazel / BUILD"))

    // Header
    appendLine("amends \"elide:project.pkl\"")
    appendLine()

    // Project metadata
    append(sectionComment("Project Metadata"))
    appendLine("name = \"${bazel.name}\"")
    appendLine()

    // Dependencies section (Maven dependencies from WORKSPACE/MODULE.bazel)
    append(sectionComment("Dependencies"))
    if (bazel.dependencies.isNotEmpty()) {
      appendLine("dependencies {")
      appendLine("  maven {")
      appendLine("    packages {")

      bazel.dependencies.sortedBy { it.coordinate }.forEach { dep ->
        val groupId = dep.groupId()
        val artifactId = dep.artifactId()
        val version = dep.version()

        if (version != null) {
          appendLine("      \"$groupId:$artifactId:$version\"")
        } else {
          appendLine("      \"${dep.coordinate}\" // No version specified")
        }
      }

      appendLine("    }")
      appendLine("  }")
      appendLine("}")
      appendLine()
    }

    // Source mappings based on Bazel targets
    appendLine("sources {")

    // Infer source mappings from targets
    val mainSrcs = mutableSetOf<String>()
    val testSrcs = mutableSetOf<String>()

    bazel.targets.forEach { target ->
      if (target.isTestTarget()) {
        testSrcs.addAll(target.srcs)
      } else {
        mainSrcs.addAll(target.srcs)
      }
    }

    // Generate source mappings
    if (mainSrcs.isNotEmpty()) {
      // Try to infer pattern from sources
      val mainPattern = inferSourcePattern(mainSrcs) ?: "src/main/**/*.{java,kt}"
      appendLine("  [\"main\"] = \"$mainPattern\"")
    } else {
      // Default Bazel Java/Kotlin patterns
      appendLine("  [\"main\"] = \"src/main/**/*.{java,kt}\"")
    }

    if (testSrcs.isNotEmpty()) {
      val testPattern = inferSourcePattern(testSrcs) ?: "src/test/**/*.{java,kt}"
      appendLine("  [\"test\"] = \"$testPattern\"")
    } else {
      appendLine("  [\"test\"] = \"src/test/**/*.{java,kt}\"")
    }

    appendLine("}")
    appendLine()

    // Bazel-specific notes
    if (bazel.targets.isNotEmpty()) {
      appendLine("// Bazel targets found in BUILD file:")
      bazel.targets.forEach { target ->
        appendLine("//   - ${target.name} (${target.rule})")
      }
      appendLine()
    }

    // Note about Bazel BUILD files
    appendLine("// Note: This project uses Bazel for builds. The generated configuration")
    appendLine("// is based on the WORKSPACE/MODULE.bazel and BUILD files.")
    if (bazel.workspaceFile != null) {
      appendLine("// Workspace file: ${bazel.workspaceFile.fileName}")
    }
    if (bazel.buildFile != null) {
      appendLine("// Build file: ${bazel.buildFile.fileName}")
    }
  }

  /**
   * Infer a source pattern from a list of source files.
   *
   * This attempts to find a common pattern among the source files.
   * For example, if all sources are in "src/main/java", it returns a glob pattern for java/kt files.
   */
  private fun inferSourcePattern(srcs: Set<String>): String? {
    if (srcs.isEmpty()) return null

    // Look for common prefixes
    val firstSrc = srcs.first()
    val parts = firstSrc.split("/")

    // Try to find common directory prefix
    var commonPrefix = ""
    for (i in parts.indices) {
      val prefix = parts.take(i + 1).joinToString("/")
      if (srcs.all { it.startsWith(prefix) }) {
        commonPrefix = prefix
      } else {
        break
      }
    }

    // If we found a common prefix, use it
    return if (commonPrefix.isNotEmpty()) {
      "$commonPrefix/**/*.{java,kt}"
    } else {
      // Look for common patterns like "java/" or "kotlin/"
      when {
        srcs.any { it.contains("/java/") } -> "**/*.java"
        srcs.any { it.contains("/kotlin/") } -> "**/*.kt"
        else -> "**/*.{java,kt}"
      }
    }
  }

  /**
   * Generate elide.pkl content from a Python project descriptor.
   *
   * @param python PythonDescriptor parsed from pyproject.toml, requirements.txt, etc.
   */
  fun generateFromPython(python: PythonDescriptor): String = buildString {
    // Determine source file name
    val sourceFile = when (python.sourceType) {
      PythonDescriptor.SourceType.PYPROJECT_TOML -> "pyproject.toml"
      PythonDescriptor.SourceType.REQUIREMENTS_TXT -> "requirements.txt"
      PythonDescriptor.SourceType.PIPFILE -> "Pipfile"
      PythonDescriptor.SourceType.SETUP_PY -> "setup.py"
    }

    // Generated header
    append(generatedHeader("Python", sourceFile))

    // Header
    appendLine("amends \"elide:project.pkl\"")
    appendLine()

    // Project metadata
    append(sectionComment("Project Metadata"))
    appendLine("name = \"${python.name}\"")
    if (python.description != null) {
      appendLine("description = \"${python.description.escapeQuotes()}\"")
    }
    if (python.version != null) {
      appendLine("version = \"${python.version}\"")
    }
    appendLine()

    // Python version requirement
    if (python.pythonVersion != null) {
      appendLine("python {")
      appendLine("  version = \"${python.pythonVersion}\"")
      appendLine("}")
      appendLine()
    }

    // Dependencies section
    append(sectionComment("Dependencies"))
    val prodDeps = python.dependencies.sorted()
    val devDeps = python.devDependencies.sorted()
    val optionalDeps = python.optionalDependencies

    if (prodDeps.isNotEmpty() || devDeps.isNotEmpty()) {
      appendLine("dependencies {")
      appendLine("  pypi {")

      // Production dependencies
      if (prodDeps.isNotEmpty()) {
        appendLine("    packages {")
        prodDeps.sorted().forEach { dep ->
          appendLine("      \"$dep\"")
        }
        appendLine("    }")
      }

      // Development dependencies
      if (devDeps.isNotEmpty()) {
        if (prodDeps.isNotEmpty()) appendLine()
        appendLine("    testPackages {")
        devDeps.sorted().forEach { dep ->
          appendLine("      \"$dep\"")
        }
        appendLine("    }")
      }

      appendLine("  }")
      appendLine("}")
      appendLine()
    }

    // Optional dependencies (listed as comments, grouped by extra name)
    if (optionalDeps.isNotEmpty()) {
      appendLine("// Optional dependencies (install with pip install <package>[extra]):")
      optionalDeps.forEach { (extraName, deps) ->
        appendLine("//   [$extraName]")
        deps.forEach { dep ->
          appendLine("//     - $dep")
        }
      }
      appendLine()
    }

    // Python scripts (entry points)
    if (python.scripts.isNotEmpty()) {
      appendLine("// Python scripts/entry points:")
      python.scripts.forEach { (name, entryPoint) ->
        appendLine("//   $name -> $entryPoint")
      }
      appendLine()
    }

    // Build system information
    if (python.buildSystem != null) {
      appendLine("// Build system: ${python.buildSystem}")
    }

    // Source type note
    appendLine("// Converted from: ${python.sourceDisplayName()}")
  }

  private fun String.escapeQuotes(): String = replace("\"", "\\\"")
}
