/*
 * Copyright (c) 2023 Elide Ventures, LLC.
 *
 * Licensed under the MIT license (the "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   https://opensource.org/license/mit/
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under the License.
 */

package elide.runtime.core

import org.graalvm.polyglot.Source

/**
 * Represents a language supported by a [PolyglotContext], providing a key for identification of guest bindings and
 * other contextual elements.
 */
@DelicateElideApi public interface GuestLanguage {
  /** A unique string representing this language. */
  public val languageId: String
}

/**
 * A [GuestLanguage] feature for evaluating [Source] code in a given [PolyglotContext].
 *
 * Install an implementation of this interface using a [PolyglotContextElement] with a key obtained from
 * [GuestLanguageEvaluator.contextElementFor], with the target language as identifier, to intercept calls to
 * [PolyglotContext.evaluate].
 *
 * [PolyglotContext] implementations will always prefer delegating execution to a [GuestLanguageEvaluator] for the
 * relevant source if one is registered, falling back to their defaults if none is found.
 *
 * @see GuestLanguageEvaluator.contextElementFor
 * @see GuestLanguageParser
 */
@DelicateElideApi public interface GuestLanguageEvaluator {
  /** Analyzes the given [source] and returns whether it can be used with this evaluator. */
  public fun accepts(source: Source): Boolean = true

  /** Evaluate a [source] in the given [context], returning the result. */
  public fun evaluate(source: Source, context: PolyglotContext): PolyglotValue

  public companion object {
    private const val ELEMENT_PREFIX = "elide.lang"
    private const val ELEMENT_SUFFIX = "evaluator"

    /**
     * Obtain an evaluator key for a target [language]. [PolyglotContext] implementations will search for a key
     * generated by this function during [PolyglotContext.evaluate] in order to load custom evaluators.
     *
     * @see GuestLanguageEvaluator
     */
    public fun contextElementFor(language: GuestLanguage): PolyglotContextElement<GuestLanguageEvaluator> {
      return contextElementFor(language.languageId)
    }

    /**
     * Obtain an evaluator key for a target [languageId]. [PolyglotContext] implementations will search for a key
     * generated by this function during [PolyglotContext.evaluate] in order to load custom evaluators.
     *
     * @see GuestLanguageEvaluator
     */
    public fun contextElementFor(languageId: String): PolyglotContextElement<GuestLanguageEvaluator> {
      return PolyglotContextElement("$ELEMENT_PREFIX.${languageId}.$ELEMENT_SUFFIX")
    }
  }
}

/**
 * A [GuestLanguage] feature for parsing [Source] code in a given [PolyglotContext], returning an executable
 * [PolyglotValue].
 *
 * Install an implementation of this interface using a [PolyglotContextElement] with a key obtained from
 * [GuestLanguageParser.contextElementFor], with the target language as identifier, to intercept calls to
 * [PolyglotContext.parse].
 *
 * [PolyglotContext] implementations will always prefer delegating parsing logic to a [GuestLanguageParser] for the
 * relevant source if one is registered, falling back to their defaults if none is found.
 *
 * @see GuestLanguageParser.contextElementFor
 * @see GuestLanguageEvaluator
 */
@DelicateElideApi public interface GuestLanguageParser {
  /** Analyzes the given [source] and returns whether it can be used with this parser. */
  public fun accepts(source: Source): Boolean = true

  /** Parse a [source] in the given [context] without evaluating it, returning an executable [PolyglotValue]. */
  public fun parse(source: Source, context: PolyglotContext): PolyglotValue

  public companion object {
    private const val ELEMENT_PREFIX = "elide.lang"
    private const val ELEMENT_SUFFIX = "parser"

    /**
     * Obtain a parser key for a target [language]. [PolyglotContext] implementations will search for a key generated
     * by this function during [PolyglotContext.parse] in order to load custom parsers.
     *
     * @see GuestLanguageParser
     */
    public fun contextElementFor(language: GuestLanguage): PolyglotContextElement<GuestLanguageParser> {
      return contextElementFor(language.languageId)
    }

    /**
     * Obtain a parser key for a target [languageId]. [PolyglotContext] implementations will search for a key generated
     * by this function during [PolyglotContext.parse] in order to load custom parsers.
     *
     * @see GuestLanguageParser
     */
    public fun contextElementFor(languageId: String): PolyglotContextElement<GuestLanguageParser> {
      return PolyglotContextElement("$ELEMENT_PREFIX.${languageId}.$ELEMENT_SUFFIX")
    }
  }
}

