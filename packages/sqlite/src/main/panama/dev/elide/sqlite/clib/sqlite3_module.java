// Generated by jextract

package dev.elide.sqlite.clib;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct sqlite3_module {
 *     int iVersion;
 *     int (*xCreate)(sqlite3 *, void *, int, const char *const *, sqlite3_vtab **, char **);
 *     int (*xConnect)(sqlite3 *, void *, int, const char *const *, sqlite3_vtab **, char **);
 *     int (*xBestIndex)(sqlite3_vtab *, sqlite3_index_info *);
 *     int (*xDisconnect)(sqlite3_vtab *);
 *     int (*xDestroy)(sqlite3_vtab *);
 *     int (*xOpen)(sqlite3_vtab *, sqlite3_vtab_cursor **);
 *     int (*xClose)(sqlite3_vtab_cursor *);
 *     int (*xFilter)(sqlite3_vtab_cursor *, int, const char *, int, sqlite3_value **);
 *     int (*xNext)(sqlite3_vtab_cursor *);
 *     int (*xEof)(sqlite3_vtab_cursor *);
 *     int (*xColumn)(sqlite3_vtab_cursor *, sqlite3_context *, int);
 *     int (*xRowid)(sqlite3_vtab_cursor *, sqlite3_int64 *);
 *     int (*xUpdate)(sqlite3_vtab *, int, sqlite3_value **, sqlite3_int64 *);
 *     int (*xBegin)(sqlite3_vtab *);
 *     int (*xSync)(sqlite3_vtab *);
 *     int (*xCommit)(sqlite3_vtab *);
 *     int (*xRollback)(sqlite3_vtab *);
 *     int (*xFindFunction)(sqlite3_vtab *, int, const char *, void (**)(sqlite3_context *, int, sqlite3_value **), void **);
 *     int (*xRename)(sqlite3_vtab *, const char *);
 *     int (*xSavepoint)(sqlite3_vtab *, int);
 *     int (*xRelease)(sqlite3_vtab *, int);
 *     int (*xRollbackTo)(sqlite3_vtab *, int);
 *     int (*xShadowName)(const char *);
 *     int (*xIntegrity)(sqlite3_vtab *, const char *, const char *, int, char **);
 * }
 * }
 */
public class sqlite3_module {

    sqlite3_module() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        sqlite3_h.C_INT.withName("iVersion"),
        MemoryLayout.paddingLayout(4),
        sqlite3_h.C_POINTER.withName("xCreate"),
        sqlite3_h.C_POINTER.withName("xConnect"),
        sqlite3_h.C_POINTER.withName("xBestIndex"),
        sqlite3_h.C_POINTER.withName("xDisconnect"),
        sqlite3_h.C_POINTER.withName("xDestroy"),
        sqlite3_h.C_POINTER.withName("xOpen"),
        sqlite3_h.C_POINTER.withName("xClose"),
        sqlite3_h.C_POINTER.withName("xFilter"),
        sqlite3_h.C_POINTER.withName("xNext"),
        sqlite3_h.C_POINTER.withName("xEof"),
        sqlite3_h.C_POINTER.withName("xColumn"),
        sqlite3_h.C_POINTER.withName("xRowid"),
        sqlite3_h.C_POINTER.withName("xUpdate"),
        sqlite3_h.C_POINTER.withName("xBegin"),
        sqlite3_h.C_POINTER.withName("xSync"),
        sqlite3_h.C_POINTER.withName("xCommit"),
        sqlite3_h.C_POINTER.withName("xRollback"),
        sqlite3_h.C_POINTER.withName("xFindFunction"),
        sqlite3_h.C_POINTER.withName("xRename"),
        sqlite3_h.C_POINTER.withName("xSavepoint"),
        sqlite3_h.C_POINTER.withName("xRelease"),
        sqlite3_h.C_POINTER.withName("xRollbackTo"),
        sqlite3_h.C_POINTER.withName("xShadowName"),
        sqlite3_h.C_POINTER.withName("xIntegrity")
    ).withName("sqlite3_module");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt iVersion$LAYOUT = (OfInt)$LAYOUT.select(groupElement("iVersion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int iVersion
     * }
     */
    public static final OfInt iVersion$layout() {
        return iVersion$LAYOUT;
    }

    private static final long iVersion$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int iVersion
     * }
     */
    public static final long iVersion$offset() {
        return iVersion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int iVersion
     * }
     */
    public static int iVersion(MemorySegment struct) {
        return struct.get(iVersion$LAYOUT, iVersion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int iVersion
     * }
     */
    public static void iVersion(MemorySegment struct, int fieldValue) {
        struct.set(iVersion$LAYOUT, iVersion$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*xCreate)(sqlite3 *, void *, int, const char *const *, sqlite3_vtab **, char **)
     * }
     */
    public static class xCreate {

        xCreate() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xCreate.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xCreate.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xCreate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xCreate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*xCreate)(sqlite3 *, void *, int, const char *const *, sqlite3_vtab **, char **)
     * }
     */
    public static final AddressLayout xCreate$layout() {
        return xCreate$LAYOUT;
    }

    private static final long xCreate$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*xCreate)(sqlite3 *, void *, int, const char *const *, sqlite3_vtab **, char **)
     * }
     */
    public static final long xCreate$offset() {
        return xCreate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*xCreate)(sqlite3 *, void *, int, const char *const *, sqlite3_vtab **, char **)
     * }
     */
    public static MemorySegment xCreate(MemorySegment struct) {
        return struct.get(xCreate$LAYOUT, xCreate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*xCreate)(sqlite3 *, void *, int, const char *const *, sqlite3_vtab **, char **)
     * }
     */
    public static void xCreate(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xCreate$LAYOUT, xCreate$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*xConnect)(sqlite3 *, void *, int, const char *const *, sqlite3_vtab **, char **)
     * }
     */
    public static class xConnect {

        xConnect() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xConnect.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xConnect.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xConnect$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xConnect"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*xConnect)(sqlite3 *, void *, int, const char *const *, sqlite3_vtab **, char **)
     * }
     */
    public static final AddressLayout xConnect$layout() {
        return xConnect$LAYOUT;
    }

    private static final long xConnect$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*xConnect)(sqlite3 *, void *, int, const char *const *, sqlite3_vtab **, char **)
     * }
     */
    public static final long xConnect$offset() {
        return xConnect$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*xConnect)(sqlite3 *, void *, int, const char *const *, sqlite3_vtab **, char **)
     * }
     */
    public static MemorySegment xConnect(MemorySegment struct) {
        return struct.get(xConnect$LAYOUT, xConnect$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*xConnect)(sqlite3 *, void *, int, const char *const *, sqlite3_vtab **, char **)
     * }
     */
    public static void xConnect(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xConnect$LAYOUT, xConnect$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*xBestIndex)(sqlite3_vtab *, sqlite3_index_info *)
     * }
     */
    public static class xBestIndex {

        xBestIndex() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xBestIndex.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xBestIndex.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xBestIndex$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xBestIndex"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*xBestIndex)(sqlite3_vtab *, sqlite3_index_info *)
     * }
     */
    public static final AddressLayout xBestIndex$layout() {
        return xBestIndex$LAYOUT;
    }

    private static final long xBestIndex$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*xBestIndex)(sqlite3_vtab *, sqlite3_index_info *)
     * }
     */
    public static final long xBestIndex$offset() {
        return xBestIndex$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*xBestIndex)(sqlite3_vtab *, sqlite3_index_info *)
     * }
     */
    public static MemorySegment xBestIndex(MemorySegment struct) {
        return struct.get(xBestIndex$LAYOUT, xBestIndex$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*xBestIndex)(sqlite3_vtab *, sqlite3_index_info *)
     * }
     */
    public static void xBestIndex(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xBestIndex$LAYOUT, xBestIndex$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*xDisconnect)(sqlite3_vtab *)
     * }
     */
    public static class xDisconnect {

        xDisconnect() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xDisconnect.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xDisconnect.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xDisconnect$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xDisconnect"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*xDisconnect)(sqlite3_vtab *)
     * }
     */
    public static final AddressLayout xDisconnect$layout() {
        return xDisconnect$LAYOUT;
    }

    private static final long xDisconnect$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*xDisconnect)(sqlite3_vtab *)
     * }
     */
    public static final long xDisconnect$offset() {
        return xDisconnect$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*xDisconnect)(sqlite3_vtab *)
     * }
     */
    public static MemorySegment xDisconnect(MemorySegment struct) {
        return struct.get(xDisconnect$LAYOUT, xDisconnect$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*xDisconnect)(sqlite3_vtab *)
     * }
     */
    public static void xDisconnect(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xDisconnect$LAYOUT, xDisconnect$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*xDestroy)(sqlite3_vtab *)
     * }
     */
    public static class xDestroy {

        xDestroy() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xDestroy.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xDestroy.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xDestroy$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xDestroy"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*xDestroy)(sqlite3_vtab *)
     * }
     */
    public static final AddressLayout xDestroy$layout() {
        return xDestroy$LAYOUT;
    }

    private static final long xDestroy$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*xDestroy)(sqlite3_vtab *)
     * }
     */
    public static final long xDestroy$offset() {
        return xDestroy$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*xDestroy)(sqlite3_vtab *)
     * }
     */
    public static MemorySegment xDestroy(MemorySegment struct) {
        return struct.get(xDestroy$LAYOUT, xDestroy$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*xDestroy)(sqlite3_vtab *)
     * }
     */
    public static void xDestroy(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xDestroy$LAYOUT, xDestroy$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*xOpen)(sqlite3_vtab *, sqlite3_vtab_cursor **)
     * }
     */
    public static class xOpen {

        xOpen() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xOpen.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xOpen.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xOpen$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xOpen"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*xOpen)(sqlite3_vtab *, sqlite3_vtab_cursor **)
     * }
     */
    public static final AddressLayout xOpen$layout() {
        return xOpen$LAYOUT;
    }

    private static final long xOpen$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*xOpen)(sqlite3_vtab *, sqlite3_vtab_cursor **)
     * }
     */
    public static final long xOpen$offset() {
        return xOpen$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*xOpen)(sqlite3_vtab *, sqlite3_vtab_cursor **)
     * }
     */
    public static MemorySegment xOpen(MemorySegment struct) {
        return struct.get(xOpen$LAYOUT, xOpen$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*xOpen)(sqlite3_vtab *, sqlite3_vtab_cursor **)
     * }
     */
    public static void xOpen(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xOpen$LAYOUT, xOpen$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*xClose)(sqlite3_vtab_cursor *)
     * }
     */
    public static class xClose {

        xClose() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xClose.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xClose.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xClose$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xClose"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*xClose)(sqlite3_vtab_cursor *)
     * }
     */
    public static final AddressLayout xClose$layout() {
        return xClose$LAYOUT;
    }

    private static final long xClose$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*xClose)(sqlite3_vtab_cursor *)
     * }
     */
    public static final long xClose$offset() {
        return xClose$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*xClose)(sqlite3_vtab_cursor *)
     * }
     */
    public static MemorySegment xClose(MemorySegment struct) {
        return struct.get(xClose$LAYOUT, xClose$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*xClose)(sqlite3_vtab_cursor *)
     * }
     */
    public static void xClose(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xClose$LAYOUT, xClose$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*xFilter)(sqlite3_vtab_cursor *, int, const char *, int, sqlite3_value **)
     * }
     */
    public static class xFilter {

        xFilter() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xFilter.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xFilter.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, int _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xFilter$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xFilter"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*xFilter)(sqlite3_vtab_cursor *, int, const char *, int, sqlite3_value **)
     * }
     */
    public static final AddressLayout xFilter$layout() {
        return xFilter$LAYOUT;
    }

    private static final long xFilter$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*xFilter)(sqlite3_vtab_cursor *, int, const char *, int, sqlite3_value **)
     * }
     */
    public static final long xFilter$offset() {
        return xFilter$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*xFilter)(sqlite3_vtab_cursor *, int, const char *, int, sqlite3_value **)
     * }
     */
    public static MemorySegment xFilter(MemorySegment struct) {
        return struct.get(xFilter$LAYOUT, xFilter$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*xFilter)(sqlite3_vtab_cursor *, int, const char *, int, sqlite3_value **)
     * }
     */
    public static void xFilter(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xFilter$LAYOUT, xFilter$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*xNext)(sqlite3_vtab_cursor *)
     * }
     */
    public static class xNext {

        xNext() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xNext.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xNext.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xNext$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xNext"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*xNext)(sqlite3_vtab_cursor *)
     * }
     */
    public static final AddressLayout xNext$layout() {
        return xNext$LAYOUT;
    }

    private static final long xNext$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*xNext)(sqlite3_vtab_cursor *)
     * }
     */
    public static final long xNext$offset() {
        return xNext$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*xNext)(sqlite3_vtab_cursor *)
     * }
     */
    public static MemorySegment xNext(MemorySegment struct) {
        return struct.get(xNext$LAYOUT, xNext$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*xNext)(sqlite3_vtab_cursor *)
     * }
     */
    public static void xNext(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xNext$LAYOUT, xNext$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*xEof)(sqlite3_vtab_cursor *)
     * }
     */
    public static class xEof {

        xEof() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xEof.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xEof.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xEof$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xEof"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*xEof)(sqlite3_vtab_cursor *)
     * }
     */
    public static final AddressLayout xEof$layout() {
        return xEof$LAYOUT;
    }

    private static final long xEof$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*xEof)(sqlite3_vtab_cursor *)
     * }
     */
    public static final long xEof$offset() {
        return xEof$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*xEof)(sqlite3_vtab_cursor *)
     * }
     */
    public static MemorySegment xEof(MemorySegment struct) {
        return struct.get(xEof$LAYOUT, xEof$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*xEof)(sqlite3_vtab_cursor *)
     * }
     */
    public static void xEof(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xEof$LAYOUT, xEof$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*xColumn)(sqlite3_vtab_cursor *, sqlite3_context *, int)
     * }
     */
    public static class xColumn {

        xColumn() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xColumn.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xColumn.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xColumn$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xColumn"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*xColumn)(sqlite3_vtab_cursor *, sqlite3_context *, int)
     * }
     */
    public static final AddressLayout xColumn$layout() {
        return xColumn$LAYOUT;
    }

    private static final long xColumn$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*xColumn)(sqlite3_vtab_cursor *, sqlite3_context *, int)
     * }
     */
    public static final long xColumn$offset() {
        return xColumn$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*xColumn)(sqlite3_vtab_cursor *, sqlite3_context *, int)
     * }
     */
    public static MemorySegment xColumn(MemorySegment struct) {
        return struct.get(xColumn$LAYOUT, xColumn$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*xColumn)(sqlite3_vtab_cursor *, sqlite3_context *, int)
     * }
     */
    public static void xColumn(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xColumn$LAYOUT, xColumn$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*xRowid)(sqlite3_vtab_cursor *, sqlite3_int64 *)
     * }
     */
    public static class xRowid {

        xRowid() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xRowid.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xRowid.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xRowid$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xRowid"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*xRowid)(sqlite3_vtab_cursor *, sqlite3_int64 *)
     * }
     */
    public static final AddressLayout xRowid$layout() {
        return xRowid$LAYOUT;
    }

    private static final long xRowid$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*xRowid)(sqlite3_vtab_cursor *, sqlite3_int64 *)
     * }
     */
    public static final long xRowid$offset() {
        return xRowid$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*xRowid)(sqlite3_vtab_cursor *, sqlite3_int64 *)
     * }
     */
    public static MemorySegment xRowid(MemorySegment struct) {
        return struct.get(xRowid$LAYOUT, xRowid$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*xRowid)(sqlite3_vtab_cursor *, sqlite3_int64 *)
     * }
     */
    public static void xRowid(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xRowid$LAYOUT, xRowid$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*xUpdate)(sqlite3_vtab *, int, sqlite3_value **, sqlite3_int64 *)
     * }
     */
    public static class xUpdate {

        xUpdate() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xUpdate.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xUpdate.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xUpdate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xUpdate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*xUpdate)(sqlite3_vtab *, int, sqlite3_value **, sqlite3_int64 *)
     * }
     */
    public static final AddressLayout xUpdate$layout() {
        return xUpdate$LAYOUT;
    }

    private static final long xUpdate$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*xUpdate)(sqlite3_vtab *, int, sqlite3_value **, sqlite3_int64 *)
     * }
     */
    public static final long xUpdate$offset() {
        return xUpdate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*xUpdate)(sqlite3_vtab *, int, sqlite3_value **, sqlite3_int64 *)
     * }
     */
    public static MemorySegment xUpdate(MemorySegment struct) {
        return struct.get(xUpdate$LAYOUT, xUpdate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*xUpdate)(sqlite3_vtab *, int, sqlite3_value **, sqlite3_int64 *)
     * }
     */
    public static void xUpdate(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xUpdate$LAYOUT, xUpdate$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*xBegin)(sqlite3_vtab *)
     * }
     */
    public static class xBegin {

        xBegin() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xBegin.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xBegin.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xBegin$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xBegin"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*xBegin)(sqlite3_vtab *)
     * }
     */
    public static final AddressLayout xBegin$layout() {
        return xBegin$LAYOUT;
    }

    private static final long xBegin$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*xBegin)(sqlite3_vtab *)
     * }
     */
    public static final long xBegin$offset() {
        return xBegin$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*xBegin)(sqlite3_vtab *)
     * }
     */
    public static MemorySegment xBegin(MemorySegment struct) {
        return struct.get(xBegin$LAYOUT, xBegin$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*xBegin)(sqlite3_vtab *)
     * }
     */
    public static void xBegin(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xBegin$LAYOUT, xBegin$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*xSync)(sqlite3_vtab *)
     * }
     */
    public static class xSync {

        xSync() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xSync.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xSync.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xSync$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xSync"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*xSync)(sqlite3_vtab *)
     * }
     */
    public static final AddressLayout xSync$layout() {
        return xSync$LAYOUT;
    }

    private static final long xSync$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*xSync)(sqlite3_vtab *)
     * }
     */
    public static final long xSync$offset() {
        return xSync$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*xSync)(sqlite3_vtab *)
     * }
     */
    public static MemorySegment xSync(MemorySegment struct) {
        return struct.get(xSync$LAYOUT, xSync$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*xSync)(sqlite3_vtab *)
     * }
     */
    public static void xSync(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xSync$LAYOUT, xSync$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*xCommit)(sqlite3_vtab *)
     * }
     */
    public static class xCommit {

        xCommit() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xCommit.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xCommit.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xCommit$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xCommit"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*xCommit)(sqlite3_vtab *)
     * }
     */
    public static final AddressLayout xCommit$layout() {
        return xCommit$LAYOUT;
    }

    private static final long xCommit$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*xCommit)(sqlite3_vtab *)
     * }
     */
    public static final long xCommit$offset() {
        return xCommit$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*xCommit)(sqlite3_vtab *)
     * }
     */
    public static MemorySegment xCommit(MemorySegment struct) {
        return struct.get(xCommit$LAYOUT, xCommit$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*xCommit)(sqlite3_vtab *)
     * }
     */
    public static void xCommit(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xCommit$LAYOUT, xCommit$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*xRollback)(sqlite3_vtab *)
     * }
     */
    public static class xRollback {

        xRollback() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xRollback.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xRollback.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xRollback$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xRollback"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*xRollback)(sqlite3_vtab *)
     * }
     */
    public static final AddressLayout xRollback$layout() {
        return xRollback$LAYOUT;
    }

    private static final long xRollback$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*xRollback)(sqlite3_vtab *)
     * }
     */
    public static final long xRollback$offset() {
        return xRollback$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*xRollback)(sqlite3_vtab *)
     * }
     */
    public static MemorySegment xRollback(MemorySegment struct) {
        return struct.get(xRollback$LAYOUT, xRollback$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*xRollback)(sqlite3_vtab *)
     * }
     */
    public static void xRollback(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xRollback$LAYOUT, xRollback$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*xFindFunction)(sqlite3_vtab *, int, const char *, void (**)(sqlite3_context *, int, sqlite3_value **), void **)
     * }
     */
    public static class xFindFunction {

        xFindFunction() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xFindFunction.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xFindFunction.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xFindFunction$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xFindFunction"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*xFindFunction)(sqlite3_vtab *, int, const char *, void (**)(sqlite3_context *, int, sqlite3_value **), void **)
     * }
     */
    public static final AddressLayout xFindFunction$layout() {
        return xFindFunction$LAYOUT;
    }

    private static final long xFindFunction$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*xFindFunction)(sqlite3_vtab *, int, const char *, void (**)(sqlite3_context *, int, sqlite3_value **), void **)
     * }
     */
    public static final long xFindFunction$offset() {
        return xFindFunction$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*xFindFunction)(sqlite3_vtab *, int, const char *, void (**)(sqlite3_context *, int, sqlite3_value **), void **)
     * }
     */
    public static MemorySegment xFindFunction(MemorySegment struct) {
        return struct.get(xFindFunction$LAYOUT, xFindFunction$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*xFindFunction)(sqlite3_vtab *, int, const char *, void (**)(sqlite3_context *, int, sqlite3_value **), void **)
     * }
     */
    public static void xFindFunction(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xFindFunction$LAYOUT, xFindFunction$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*xRename)(sqlite3_vtab *, const char *)
     * }
     */
    public static class xRename {

        xRename() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xRename.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xRename.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xRename$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xRename"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*xRename)(sqlite3_vtab *, const char *)
     * }
     */
    public static final AddressLayout xRename$layout() {
        return xRename$LAYOUT;
    }

    private static final long xRename$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*xRename)(sqlite3_vtab *, const char *)
     * }
     */
    public static final long xRename$offset() {
        return xRename$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*xRename)(sqlite3_vtab *, const char *)
     * }
     */
    public static MemorySegment xRename(MemorySegment struct) {
        return struct.get(xRename$LAYOUT, xRename$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*xRename)(sqlite3_vtab *, const char *)
     * }
     */
    public static void xRename(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xRename$LAYOUT, xRename$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*xSavepoint)(sqlite3_vtab *, int)
     * }
     */
    public static class xSavepoint {

        xSavepoint() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xSavepoint.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xSavepoint.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xSavepoint$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xSavepoint"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*xSavepoint)(sqlite3_vtab *, int)
     * }
     */
    public static final AddressLayout xSavepoint$layout() {
        return xSavepoint$LAYOUT;
    }

    private static final long xSavepoint$OFFSET = 160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*xSavepoint)(sqlite3_vtab *, int)
     * }
     */
    public static final long xSavepoint$offset() {
        return xSavepoint$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*xSavepoint)(sqlite3_vtab *, int)
     * }
     */
    public static MemorySegment xSavepoint(MemorySegment struct) {
        return struct.get(xSavepoint$LAYOUT, xSavepoint$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*xSavepoint)(sqlite3_vtab *, int)
     * }
     */
    public static void xSavepoint(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xSavepoint$LAYOUT, xSavepoint$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*xRelease)(sqlite3_vtab *, int)
     * }
     */
    public static class xRelease {

        xRelease() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xRelease.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xRelease.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xRelease$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xRelease"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*xRelease)(sqlite3_vtab *, int)
     * }
     */
    public static final AddressLayout xRelease$layout() {
        return xRelease$LAYOUT;
    }

    private static final long xRelease$OFFSET = 168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*xRelease)(sqlite3_vtab *, int)
     * }
     */
    public static final long xRelease$offset() {
        return xRelease$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*xRelease)(sqlite3_vtab *, int)
     * }
     */
    public static MemorySegment xRelease(MemorySegment struct) {
        return struct.get(xRelease$LAYOUT, xRelease$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*xRelease)(sqlite3_vtab *, int)
     * }
     */
    public static void xRelease(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xRelease$LAYOUT, xRelease$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*xRollbackTo)(sqlite3_vtab *, int)
     * }
     */
    public static class xRollbackTo {

        xRollbackTo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xRollbackTo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xRollbackTo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xRollbackTo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xRollbackTo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*xRollbackTo)(sqlite3_vtab *, int)
     * }
     */
    public static final AddressLayout xRollbackTo$layout() {
        return xRollbackTo$LAYOUT;
    }

    private static final long xRollbackTo$OFFSET = 176;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*xRollbackTo)(sqlite3_vtab *, int)
     * }
     */
    public static final long xRollbackTo$offset() {
        return xRollbackTo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*xRollbackTo)(sqlite3_vtab *, int)
     * }
     */
    public static MemorySegment xRollbackTo(MemorySegment struct) {
        return struct.get(xRollbackTo$LAYOUT, xRollbackTo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*xRollbackTo)(sqlite3_vtab *, int)
     * }
     */
    public static void xRollbackTo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xRollbackTo$LAYOUT, xRollbackTo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*xShadowName)(const char *)
     * }
     */
    public static class xShadowName {

        xShadowName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xShadowName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xShadowName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xShadowName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xShadowName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*xShadowName)(const char *)
     * }
     */
    public static final AddressLayout xShadowName$layout() {
        return xShadowName$LAYOUT;
    }

    private static final long xShadowName$OFFSET = 184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*xShadowName)(const char *)
     * }
     */
    public static final long xShadowName$offset() {
        return xShadowName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*xShadowName)(const char *)
     * }
     */
    public static MemorySegment xShadowName(MemorySegment struct) {
        return struct.get(xShadowName$LAYOUT, xShadowName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*xShadowName)(const char *)
     * }
     */
    public static void xShadowName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xShadowName$LAYOUT, xShadowName$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*xIntegrity)(sqlite3_vtab *, const char *, const char *, int, char **)
     * }
     */
    public static class xIntegrity {

        xIntegrity() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xIntegrity.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xIntegrity.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xIntegrity$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xIntegrity"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*xIntegrity)(sqlite3_vtab *, const char *, const char *, int, char **)
     * }
     */
    public static final AddressLayout xIntegrity$layout() {
        return xIntegrity$LAYOUT;
    }

    private static final long xIntegrity$OFFSET = 192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*xIntegrity)(sqlite3_vtab *, const char *, const char *, int, char **)
     * }
     */
    public static final long xIntegrity$offset() {
        return xIntegrity$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*xIntegrity)(sqlite3_vtab *, const char *, const char *, int, char **)
     * }
     */
    public static MemorySegment xIntegrity(MemorySegment struct) {
        return struct.get(xIntegrity$LAYOUT, xIntegrity$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*xIntegrity)(sqlite3_vtab *, const char *, const char *, int, char **)
     * }
     */
    public static void xIntegrity(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xIntegrity$LAYOUT, xIntegrity$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

