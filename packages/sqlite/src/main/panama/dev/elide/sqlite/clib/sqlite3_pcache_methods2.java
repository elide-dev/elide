// Generated by jextract

package dev.elide.sqlite.clib;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct sqlite3_pcache_methods2 {
 *     int iVersion;
 *     void *pArg;
 *     int (*xInit)(void *);
 *     void (*xShutdown)(void *);
 *     sqlite3_pcache *(*xCreate)(int, int, int);
 *     void (*xCachesize)(sqlite3_pcache *, int);
 *     int (*xPagecount)(sqlite3_pcache *);
 *     sqlite3_pcache_page *(*xFetch)(sqlite3_pcache *, unsigned int, int);
 *     void (*xUnpin)(sqlite3_pcache *, sqlite3_pcache_page *, int);
 *     void (*xRekey)(sqlite3_pcache *, sqlite3_pcache_page *, unsigned int, unsigned int);
 *     void (*xTruncate)(sqlite3_pcache *, unsigned int);
 *     void (*xDestroy)(sqlite3_pcache *);
 *     void (*xShrink)(sqlite3_pcache *);
 * }
 * }
 */
public class sqlite3_pcache_methods2 {

    sqlite3_pcache_methods2() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        sqlite3_h.C_INT.withName("iVersion"),
        MemoryLayout.paddingLayout(4),
        sqlite3_h.C_POINTER.withName("pArg"),
        sqlite3_h.C_POINTER.withName("xInit"),
        sqlite3_h.C_POINTER.withName("xShutdown"),
        sqlite3_h.C_POINTER.withName("xCreate"),
        sqlite3_h.C_POINTER.withName("xCachesize"),
        sqlite3_h.C_POINTER.withName("xPagecount"),
        sqlite3_h.C_POINTER.withName("xFetch"),
        sqlite3_h.C_POINTER.withName("xUnpin"),
        sqlite3_h.C_POINTER.withName("xRekey"),
        sqlite3_h.C_POINTER.withName("xTruncate"),
        sqlite3_h.C_POINTER.withName("xDestroy"),
        sqlite3_h.C_POINTER.withName("xShrink")
    ).withName("sqlite3_pcache_methods2");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt iVersion$LAYOUT = (OfInt)$LAYOUT.select(groupElement("iVersion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int iVersion
     * }
     */
    public static final OfInt iVersion$layout() {
        return iVersion$LAYOUT;
    }

    private static final long iVersion$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int iVersion
     * }
     */
    public static final long iVersion$offset() {
        return iVersion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int iVersion
     * }
     */
    public static int iVersion(MemorySegment struct) {
        return struct.get(iVersion$LAYOUT, iVersion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int iVersion
     * }
     */
    public static void iVersion(MemorySegment struct, int fieldValue) {
        struct.set(iVersion$LAYOUT, iVersion$OFFSET, fieldValue);
    }

    private static final AddressLayout pArg$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("pArg"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *pArg
     * }
     */
    public static final AddressLayout pArg$layout() {
        return pArg$LAYOUT;
    }

    private static final long pArg$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *pArg
     * }
     */
    public static final long pArg$offset() {
        return pArg$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *pArg
     * }
     */
    public static MemorySegment pArg(MemorySegment struct) {
        return struct.get(pArg$LAYOUT, pArg$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *pArg
     * }
     */
    public static void pArg(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(pArg$LAYOUT, pArg$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*xInit)(void *)
     * }
     */
    public static class xInit {

        xInit() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xInit.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xInit.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xInit$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xInit"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*xInit)(void *)
     * }
     */
    public static final AddressLayout xInit$layout() {
        return xInit$LAYOUT;
    }

    private static final long xInit$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*xInit)(void *)
     * }
     */
    public static final long xInit$offset() {
        return xInit$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*xInit)(void *)
     * }
     */
    public static MemorySegment xInit(MemorySegment struct) {
        return struct.get(xInit$LAYOUT, xInit$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*xInit)(void *)
     * }
     */
    public static void xInit(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xInit$LAYOUT, xInit$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*xShutdown)(void *)
     * }
     */
    public static class xShutdown {

        xShutdown() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            sqlite3_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xShutdown.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xShutdown.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xShutdown$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xShutdown"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*xShutdown)(void *)
     * }
     */
    public static final AddressLayout xShutdown$layout() {
        return xShutdown$LAYOUT;
    }

    private static final long xShutdown$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*xShutdown)(void *)
     * }
     */
    public static final long xShutdown$offset() {
        return xShutdown$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*xShutdown)(void *)
     * }
     */
    public static MemorySegment xShutdown(MemorySegment struct) {
        return struct.get(xShutdown$LAYOUT, xShutdown$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*xShutdown)(void *)
     * }
     */
    public static void xShutdown(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xShutdown$LAYOUT, xShutdown$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * sqlite3_pcache *(*xCreate)(int, int, int)
     * }
     */
    public static class xCreate {

        xCreate() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(int _x0, int _x1, int _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_POINTER,
            sqlite3_h.C_INT,
            sqlite3_h.C_INT,
            sqlite3_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xCreate.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xCreate.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,int _x0, int _x1, int _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xCreate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xCreate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * sqlite3_pcache *(*xCreate)(int, int, int)
     * }
     */
    public static final AddressLayout xCreate$layout() {
        return xCreate$LAYOUT;
    }

    private static final long xCreate$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * sqlite3_pcache *(*xCreate)(int, int, int)
     * }
     */
    public static final long xCreate$offset() {
        return xCreate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * sqlite3_pcache *(*xCreate)(int, int, int)
     * }
     */
    public static MemorySegment xCreate(MemorySegment struct) {
        return struct.get(xCreate$LAYOUT, xCreate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * sqlite3_pcache *(*xCreate)(int, int, int)
     * }
     */
    public static void xCreate(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xCreate$LAYOUT, xCreate$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*xCachesize)(sqlite3_pcache *, int)
     * }
     */
    public static class xCachesize {

        xCachesize() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            sqlite3_h.C_POINTER,
            sqlite3_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xCachesize.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xCachesize.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xCachesize$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xCachesize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*xCachesize)(sqlite3_pcache *, int)
     * }
     */
    public static final AddressLayout xCachesize$layout() {
        return xCachesize$LAYOUT;
    }

    private static final long xCachesize$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*xCachesize)(sqlite3_pcache *, int)
     * }
     */
    public static final long xCachesize$offset() {
        return xCachesize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*xCachesize)(sqlite3_pcache *, int)
     * }
     */
    public static MemorySegment xCachesize(MemorySegment struct) {
        return struct.get(xCachesize$LAYOUT, xCachesize$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*xCachesize)(sqlite3_pcache *, int)
     * }
     */
    public static void xCachesize(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xCachesize$LAYOUT, xCachesize$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*xPagecount)(sqlite3_pcache *)
     * }
     */
    public static class xPagecount {

        xPagecount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_INT,
            sqlite3_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xPagecount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xPagecount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xPagecount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xPagecount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*xPagecount)(sqlite3_pcache *)
     * }
     */
    public static final AddressLayout xPagecount$layout() {
        return xPagecount$LAYOUT;
    }

    private static final long xPagecount$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*xPagecount)(sqlite3_pcache *)
     * }
     */
    public static final long xPagecount$offset() {
        return xPagecount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*xPagecount)(sqlite3_pcache *)
     * }
     */
    public static MemorySegment xPagecount(MemorySegment struct) {
        return struct.get(xPagecount$LAYOUT, xPagecount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*xPagecount)(sqlite3_pcache *)
     * }
     */
    public static void xPagecount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xPagecount$LAYOUT, xPagecount$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * sqlite3_pcache_page *(*xFetch)(sqlite3_pcache *, unsigned int, int)
     * }
     */
    public static class xFetch {

        xFetch() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, int _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            sqlite3_h.C_POINTER,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_INT,
            sqlite3_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xFetch.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xFetch.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xFetch$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xFetch"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * sqlite3_pcache_page *(*xFetch)(sqlite3_pcache *, unsigned int, int)
     * }
     */
    public static final AddressLayout xFetch$layout() {
        return xFetch$LAYOUT;
    }

    private static final long xFetch$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * sqlite3_pcache_page *(*xFetch)(sqlite3_pcache *, unsigned int, int)
     * }
     */
    public static final long xFetch$offset() {
        return xFetch$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * sqlite3_pcache_page *(*xFetch)(sqlite3_pcache *, unsigned int, int)
     * }
     */
    public static MemorySegment xFetch(MemorySegment struct) {
        return struct.get(xFetch$LAYOUT, xFetch$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * sqlite3_pcache_page *(*xFetch)(sqlite3_pcache *, unsigned int, int)
     * }
     */
    public static void xFetch(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xFetch$LAYOUT, xFetch$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*xUnpin)(sqlite3_pcache *, sqlite3_pcache_page *, int)
     * }
     */
    public static class xUnpin {

        xUnpin() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            sqlite3_h.C_POINTER,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xUnpin.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xUnpin.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xUnpin$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xUnpin"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*xUnpin)(sqlite3_pcache *, sqlite3_pcache_page *, int)
     * }
     */
    public static final AddressLayout xUnpin$layout() {
        return xUnpin$LAYOUT;
    }

    private static final long xUnpin$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*xUnpin)(sqlite3_pcache *, sqlite3_pcache_page *, int)
     * }
     */
    public static final long xUnpin$offset() {
        return xUnpin$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*xUnpin)(sqlite3_pcache *, sqlite3_pcache_page *, int)
     * }
     */
    public static MemorySegment xUnpin(MemorySegment struct) {
        return struct.get(xUnpin$LAYOUT, xUnpin$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*xUnpin)(sqlite3_pcache *, sqlite3_pcache_page *, int)
     * }
     */
    public static void xUnpin(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xUnpin$LAYOUT, xUnpin$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*xRekey)(sqlite3_pcache *, sqlite3_pcache_page *, unsigned int, unsigned int)
     * }
     */
    public static class xRekey {

        xRekey() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            sqlite3_h.C_POINTER,
            sqlite3_h.C_POINTER,
            sqlite3_h.C_INT,
            sqlite3_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xRekey.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xRekey.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xRekey$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xRekey"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*xRekey)(sqlite3_pcache *, sqlite3_pcache_page *, unsigned int, unsigned int)
     * }
     */
    public static final AddressLayout xRekey$layout() {
        return xRekey$LAYOUT;
    }

    private static final long xRekey$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*xRekey)(sqlite3_pcache *, sqlite3_pcache_page *, unsigned int, unsigned int)
     * }
     */
    public static final long xRekey$offset() {
        return xRekey$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*xRekey)(sqlite3_pcache *, sqlite3_pcache_page *, unsigned int, unsigned int)
     * }
     */
    public static MemorySegment xRekey(MemorySegment struct) {
        return struct.get(xRekey$LAYOUT, xRekey$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*xRekey)(sqlite3_pcache *, sqlite3_pcache_page *, unsigned int, unsigned int)
     * }
     */
    public static void xRekey(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xRekey$LAYOUT, xRekey$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*xTruncate)(sqlite3_pcache *, unsigned int)
     * }
     */
    public static class xTruncate {

        xTruncate() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            sqlite3_h.C_POINTER,
            sqlite3_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xTruncate.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xTruncate.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xTruncate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xTruncate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*xTruncate)(sqlite3_pcache *, unsigned int)
     * }
     */
    public static final AddressLayout xTruncate$layout() {
        return xTruncate$LAYOUT;
    }

    private static final long xTruncate$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*xTruncate)(sqlite3_pcache *, unsigned int)
     * }
     */
    public static final long xTruncate$offset() {
        return xTruncate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*xTruncate)(sqlite3_pcache *, unsigned int)
     * }
     */
    public static MemorySegment xTruncate(MemorySegment struct) {
        return struct.get(xTruncate$LAYOUT, xTruncate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*xTruncate)(sqlite3_pcache *, unsigned int)
     * }
     */
    public static void xTruncate(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xTruncate$LAYOUT, xTruncate$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*xDestroy)(sqlite3_pcache *)
     * }
     */
    public static class xDestroy {

        xDestroy() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            sqlite3_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xDestroy.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xDestroy.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xDestroy$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xDestroy"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*xDestroy)(sqlite3_pcache *)
     * }
     */
    public static final AddressLayout xDestroy$layout() {
        return xDestroy$LAYOUT;
    }

    private static final long xDestroy$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*xDestroy)(sqlite3_pcache *)
     * }
     */
    public static final long xDestroy$offset() {
        return xDestroy$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*xDestroy)(sqlite3_pcache *)
     * }
     */
    public static MemorySegment xDestroy(MemorySegment struct) {
        return struct.get(xDestroy$LAYOUT, xDestroy$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*xDestroy)(sqlite3_pcache *)
     * }
     */
    public static void xDestroy(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xDestroy$LAYOUT, xDestroy$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*xShrink)(sqlite3_pcache *)
     * }
     */
    public static class xShrink {

        xShrink() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            sqlite3_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = sqlite3_h.upcallHandle(xShrink.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(xShrink.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout xShrink$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("xShrink"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*xShrink)(sqlite3_pcache *)
     * }
     */
    public static final AddressLayout xShrink$layout() {
        return xShrink$LAYOUT;
    }

    private static final long xShrink$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*xShrink)(sqlite3_pcache *)
     * }
     */
    public static final long xShrink$offset() {
        return xShrink$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*xShrink)(sqlite3_pcache *)
     * }
     */
    public static MemorySegment xShrink(MemorySegment struct) {
        return struct.get(xShrink$LAYOUT, xShrink$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*xShrink)(sqlite3_pcache *)
     * }
     */
    public static void xShrink(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(xShrink$LAYOUT, xShrink$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

