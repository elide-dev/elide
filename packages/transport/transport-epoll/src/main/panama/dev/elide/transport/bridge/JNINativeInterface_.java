// Generated by jextract

package dev.elide.transport.bridge;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct JNINativeInterface_ {
 *     void *reserved0;
 *     void *reserved1;
 *     void *reserved2;
 *     void *reserved3;
 *     jint (*GetVersion)(JNIEnv *);
 *     jclass (*DefineClass)(JNIEnv *, const char *, jobject, const jbyte *, jsize);
 *     jclass (*FindClass)(JNIEnv *, const char *);
 *     jmethodID (*FromReflectedMethod)(JNIEnv *, jobject);
 *     jfieldID (*FromReflectedField)(JNIEnv *, jobject);
 *     jobject (*ToReflectedMethod)(JNIEnv *, jclass, jmethodID, jboolean);
 *     jclass (*GetSuperclass)(JNIEnv *, jclass);
 *     jboolean (*IsAssignableFrom)(JNIEnv *, jclass, jclass);
 *     jobject (*ToReflectedField)(JNIEnv *, jclass, jfieldID, jboolean);
 *     jint (*Throw)(JNIEnv *, jthrowable);
 *     jint (*ThrowNew)(JNIEnv *, jclass, const char *);
 *     jthrowable (*ExceptionOccurred)(JNIEnv *);
 *     void (*ExceptionDescribe)(JNIEnv *);
 *     void (*ExceptionClear)(JNIEnv *);
 *     void (*FatalError)(JNIEnv *, const char *);
 *     jint (*PushLocalFrame)(JNIEnv *, jint);
 *     jobject (*PopLocalFrame)(JNIEnv *, jobject);
 *     jobject (*NewGlobalRef)(JNIEnv *, jobject);
 *     void (*DeleteGlobalRef)(JNIEnv *, jobject);
 *     void (*DeleteLocalRef)(JNIEnv *, jobject);
 *     jboolean (*IsSameObject)(JNIEnv *, jobject, jobject);
 *     jobject (*NewLocalRef)(JNIEnv *, jobject);
 *     jint (*EnsureLocalCapacity)(JNIEnv *, jint);
 *     jobject (*AllocObject)(JNIEnv *, jclass);
 *     jobject (*NewObject)(JNIEnv *, jclass, jmethodID, ...);
 *     jobject (*NewObjectV)(JNIEnv *, jclass, jmethodID, va_list);
 *     jobject (*NewObjectA)(JNIEnv *, jclass, jmethodID, const jvalue *);
 *     jclass (*GetObjectClass)(JNIEnv *, jobject);
 *     jboolean (*IsInstanceOf)(JNIEnv *, jobject, jclass);
 *     jmethodID (*GetMethodID)(JNIEnv *, jclass, const char *, const char *);
 *     jobject (*CallObjectMethod)(JNIEnv *, jobject, jmethodID, ...);
 *     jobject (*CallObjectMethodV)(JNIEnv *, jobject, jmethodID, va_list);
 *     jobject (*CallObjectMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *);
 *     jboolean (*CallBooleanMethod)(JNIEnv *, jobject, jmethodID, ...);
 *     jboolean (*CallBooleanMethodV)(JNIEnv *, jobject, jmethodID, va_list);
 *     jboolean (*CallBooleanMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *);
 *     jbyte (*CallByteMethod)(JNIEnv *, jobject, jmethodID, ...);
 *     jbyte (*CallByteMethodV)(JNIEnv *, jobject, jmethodID, va_list);
 *     jbyte (*CallByteMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *);
 *     jchar (*CallCharMethod)(JNIEnv *, jobject, jmethodID, ...);
 *     jchar (*CallCharMethodV)(JNIEnv *, jobject, jmethodID, va_list);
 *     jchar (*CallCharMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *);
 *     jshort (*CallShortMethod)(JNIEnv *, jobject, jmethodID, ...);
 *     jshort (*CallShortMethodV)(JNIEnv *, jobject, jmethodID, va_list);
 *     jshort (*CallShortMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *);
 *     jint (*CallIntMethod)(JNIEnv *, jobject, jmethodID, ...);
 *     jint (*CallIntMethodV)(JNIEnv *, jobject, jmethodID, va_list);
 *     jint (*CallIntMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *);
 *     jlong (*CallLongMethod)(JNIEnv *, jobject, jmethodID, ...);
 *     jlong (*CallLongMethodV)(JNIEnv *, jobject, jmethodID, va_list);
 *     jlong (*CallLongMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *);
 *     jfloat (*CallFloatMethod)(JNIEnv *, jobject, jmethodID, ...);
 *     jfloat (*CallFloatMethodV)(JNIEnv *, jobject, jmethodID, va_list);
 *     jfloat (*CallFloatMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *);
 *     jdouble (*CallDoubleMethod)(JNIEnv *, jobject, jmethodID, ...);
 *     jdouble (*CallDoubleMethodV)(JNIEnv *, jobject, jmethodID, va_list);
 *     jdouble (*CallDoubleMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *);
 *     void (*CallVoidMethod)(JNIEnv *, jobject, jmethodID, ...);
 *     void (*CallVoidMethodV)(JNIEnv *, jobject, jmethodID, va_list);
 *     void (*CallVoidMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *);
 *     jobject (*CallNonvirtualObjectMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);
 *     jobject (*CallNonvirtualObjectMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);
 *     jobject (*CallNonvirtualObjectMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *);
 *     jboolean (*CallNonvirtualBooleanMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);
 *     jboolean (*CallNonvirtualBooleanMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);
 *     jboolean (*CallNonvirtualBooleanMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *);
 *     jbyte (*CallNonvirtualByteMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);
 *     jbyte (*CallNonvirtualByteMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);
 *     jbyte (*CallNonvirtualByteMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *);
 *     jchar (*CallNonvirtualCharMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);
 *     jchar (*CallNonvirtualCharMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);
 *     jchar (*CallNonvirtualCharMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *);
 *     jshort (*CallNonvirtualShortMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);
 *     jshort (*CallNonvirtualShortMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);
 *     jshort (*CallNonvirtualShortMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *);
 *     jint (*CallNonvirtualIntMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);
 *     jint (*CallNonvirtualIntMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);
 *     jint (*CallNonvirtualIntMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *);
 *     jlong (*CallNonvirtualLongMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);
 *     jlong (*CallNonvirtualLongMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);
 *     jlong (*CallNonvirtualLongMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *);
 *     jfloat (*CallNonvirtualFloatMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);
 *     jfloat (*CallNonvirtualFloatMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);
 *     jfloat (*CallNonvirtualFloatMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *);
 *     jdouble (*CallNonvirtualDoubleMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);
 *     jdouble (*CallNonvirtualDoubleMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);
 *     jdouble (*CallNonvirtualDoubleMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *);
 *     void (*CallNonvirtualVoidMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);
 *     void (*CallNonvirtualVoidMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);
 *     void (*CallNonvirtualVoidMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *);
 *     jfieldID (*GetFieldID)(JNIEnv *, jclass, const char *, const char *);
 *     jobject (*GetObjectField)(JNIEnv *, jobject, jfieldID);
 *     jboolean (*GetBooleanField)(JNIEnv *, jobject, jfieldID);
 *     jbyte (*GetByteField)(JNIEnv *, jobject, jfieldID);
 *     jchar (*GetCharField)(JNIEnv *, jobject, jfieldID);
 *     jshort (*GetShortField)(JNIEnv *, jobject, jfieldID);
 *     jint (*GetIntField)(JNIEnv *, jobject, jfieldID);
 *     jlong (*GetLongField)(JNIEnv *, jobject, jfieldID);
 *     jfloat (*GetFloatField)(JNIEnv *, jobject, jfieldID);
 *     jdouble (*GetDoubleField)(JNIEnv *, jobject, jfieldID);
 *     void (*SetObjectField)(JNIEnv *, jobject, jfieldID, jobject);
 *     void (*SetBooleanField)(JNIEnv *, jobject, jfieldID, jboolean);
 *     void (*SetByteField)(JNIEnv *, jobject, jfieldID, jbyte);
 *     void (*SetCharField)(JNIEnv *, jobject, jfieldID, jchar);
 *     void (*SetShortField)(JNIEnv *, jobject, jfieldID, jshort);
 *     void (*SetIntField)(JNIEnv *, jobject, jfieldID, jint);
 *     void (*SetLongField)(JNIEnv *, jobject, jfieldID, jlong);
 *     void (*SetFloatField)(JNIEnv *, jobject, jfieldID, jfloat);
 *     void (*SetDoubleField)(JNIEnv *, jobject, jfieldID, jdouble);
 *     jmethodID (*GetStaticMethodID)(JNIEnv *, jclass, const char *, const char *);
 *     jobject (*CallStaticObjectMethod)(JNIEnv *, jclass, jmethodID, ...);
 *     jobject (*CallStaticObjectMethodV)(JNIEnv *, jclass, jmethodID, va_list);
 *     jobject (*CallStaticObjectMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *);
 *     jboolean (*CallStaticBooleanMethod)(JNIEnv *, jclass, jmethodID, ...);
 *     jboolean (*CallStaticBooleanMethodV)(JNIEnv *, jclass, jmethodID, va_list);
 *     jboolean (*CallStaticBooleanMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *);
 *     jbyte (*CallStaticByteMethod)(JNIEnv *, jclass, jmethodID, ...);
 *     jbyte (*CallStaticByteMethodV)(JNIEnv *, jclass, jmethodID, va_list);
 *     jbyte (*CallStaticByteMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *);
 *     jchar (*CallStaticCharMethod)(JNIEnv *, jclass, jmethodID, ...);
 *     jchar (*CallStaticCharMethodV)(JNIEnv *, jclass, jmethodID, va_list);
 *     jchar (*CallStaticCharMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *);
 *     jshort (*CallStaticShortMethod)(JNIEnv *, jclass, jmethodID, ...);
 *     jshort (*CallStaticShortMethodV)(JNIEnv *, jclass, jmethodID, va_list);
 *     jshort (*CallStaticShortMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *);
 *     jint (*CallStaticIntMethod)(JNIEnv *, jclass, jmethodID, ...);
 *     jint (*CallStaticIntMethodV)(JNIEnv *, jclass, jmethodID, va_list);
 *     jint (*CallStaticIntMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *);
 *     jlong (*CallStaticLongMethod)(JNIEnv *, jclass, jmethodID, ...);
 *     jlong (*CallStaticLongMethodV)(JNIEnv *, jclass, jmethodID, va_list);
 *     jlong (*CallStaticLongMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *);
 *     jfloat (*CallStaticFloatMethod)(JNIEnv *, jclass, jmethodID, ...);
 *     jfloat (*CallStaticFloatMethodV)(JNIEnv *, jclass, jmethodID, va_list);
 *     jfloat (*CallStaticFloatMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *);
 *     jdouble (*CallStaticDoubleMethod)(JNIEnv *, jclass, jmethodID, ...);
 *     jdouble (*CallStaticDoubleMethodV)(JNIEnv *, jclass, jmethodID, va_list);
 *     jdouble (*CallStaticDoubleMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *);
 *     void (*CallStaticVoidMethod)(JNIEnv *, jclass, jmethodID, ...);
 *     void (*CallStaticVoidMethodV)(JNIEnv *, jclass, jmethodID, va_list);
 *     void (*CallStaticVoidMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *);
 *     jfieldID (*GetStaticFieldID)(JNIEnv *, jclass, const char *, const char *);
 *     jobject (*GetStaticObjectField)(JNIEnv *, jclass, jfieldID);
 *     jboolean (*GetStaticBooleanField)(JNIEnv *, jclass, jfieldID);
 *     jbyte (*GetStaticByteField)(JNIEnv *, jclass, jfieldID);
 *     jchar (*GetStaticCharField)(JNIEnv *, jclass, jfieldID);
 *     jshort (*GetStaticShortField)(JNIEnv *, jclass, jfieldID);
 *     jint (*GetStaticIntField)(JNIEnv *, jclass, jfieldID);
 *     jlong (*GetStaticLongField)(JNIEnv *, jclass, jfieldID);
 *     jfloat (*GetStaticFloatField)(JNIEnv *, jclass, jfieldID);
 *     jdouble (*GetStaticDoubleField)(JNIEnv *, jclass, jfieldID);
 *     void (*SetStaticObjectField)(JNIEnv *, jclass, jfieldID, jobject);
 *     void (*SetStaticBooleanField)(JNIEnv *, jclass, jfieldID, jboolean);
 *     void (*SetStaticByteField)(JNIEnv *, jclass, jfieldID, jbyte);
 *     void (*SetStaticCharField)(JNIEnv *, jclass, jfieldID, jchar);
 *     void (*SetStaticShortField)(JNIEnv *, jclass, jfieldID, jshort);
 *     void (*SetStaticIntField)(JNIEnv *, jclass, jfieldID, jint);
 *     void (*SetStaticLongField)(JNIEnv *, jclass, jfieldID, jlong);
 *     void (*SetStaticFloatField)(JNIEnv *, jclass, jfieldID, jfloat);
 *     void (*SetStaticDoubleField)(JNIEnv *, jclass, jfieldID, jdouble);
 *     jstring (*NewString)(JNIEnv *, const jchar *, jsize);
 *     jsize (*GetStringLength)(JNIEnv *, jstring);
 *     const jchar *(*GetStringChars)(JNIEnv *, jstring, jboolean *);
 *     void (*ReleaseStringChars)(JNIEnv *, jstring, const jchar *);
 *     jstring (*NewStringUTF)(JNIEnv *, const char *);
 *     jsize (*GetStringUTFLength)(JNIEnv *, jstring);
 *     const char *(*GetStringUTFChars)(JNIEnv *, jstring, jboolean *);
 *     void (*ReleaseStringUTFChars)(JNIEnv *, jstring, const char *);
 *     jsize (*GetArrayLength)(JNIEnv *, jarray);
 *     jobjectArray (*NewObjectArray)(JNIEnv *, jsize, jclass, jobject);
 *     jobject (*GetObjectArrayElement)(JNIEnv *, jobjectArray, jsize);
 *     void (*SetObjectArrayElement)(JNIEnv *, jobjectArray, jsize, jobject);
 *     jbooleanArray (*NewBooleanArray)(JNIEnv *, jsize);
 *     jbyteArray (*NewByteArray)(JNIEnv *, jsize);
 *     jcharArray (*NewCharArray)(JNIEnv *, jsize);
 *     jshortArray (*NewShortArray)(JNIEnv *, jsize);
 *     jintArray (*NewIntArray)(JNIEnv *, jsize);
 *     jlongArray (*NewLongArray)(JNIEnv *, jsize);
 *     jfloatArray (*NewFloatArray)(JNIEnv *, jsize);
 *     jdoubleArray (*NewDoubleArray)(JNIEnv *, jsize);
 *     jboolean *(*GetBooleanArrayElements)(JNIEnv *, jbooleanArray, jboolean *);
 *     jbyte *(*GetByteArrayElements)(JNIEnv *, jbyteArray, jboolean *);
 *     jchar *(*GetCharArrayElements)(JNIEnv *, jcharArray, jboolean *);
 *     jshort *(*GetShortArrayElements)(JNIEnv *, jshortArray, jboolean *);
 *     jint *(*GetIntArrayElements)(JNIEnv *, jintArray, jboolean *);
 *     jlong *(*GetLongArrayElements)(JNIEnv *, jlongArray, jboolean *);
 *     jfloat *(*GetFloatArrayElements)(JNIEnv *, jfloatArray, jboolean *);
 *     jdouble *(*GetDoubleArrayElements)(JNIEnv *, jdoubleArray, jboolean *);
 *     void (*ReleaseBooleanArrayElements)(JNIEnv *, jbooleanArray, jboolean *, jint);
 *     void (*ReleaseByteArrayElements)(JNIEnv *, jbyteArray, jbyte *, jint);
 *     void (*ReleaseCharArrayElements)(JNIEnv *, jcharArray, jchar *, jint);
 *     void (*ReleaseShortArrayElements)(JNIEnv *, jshortArray, jshort *, jint);
 *     void (*ReleaseIntArrayElements)(JNIEnv *, jintArray, jint *, jint);
 *     void (*ReleaseLongArrayElements)(JNIEnv *, jlongArray, jlong *, jint);
 *     void (*ReleaseFloatArrayElements)(JNIEnv *, jfloatArray, jfloat *, jint);
 *     void (*ReleaseDoubleArrayElements)(JNIEnv *, jdoubleArray, jdouble *, jint);
 *     void (*GetBooleanArrayRegion)(JNIEnv *, jbooleanArray, jsize, jsize, jboolean *);
 *     void (*GetByteArrayRegion)(JNIEnv *, jbyteArray, jsize, jsize, jbyte *);
 *     void (*GetCharArrayRegion)(JNIEnv *, jcharArray, jsize, jsize, jchar *);
 *     void (*GetShortArrayRegion)(JNIEnv *, jshortArray, jsize, jsize, jshort *);
 *     void (*GetIntArrayRegion)(JNIEnv *, jintArray, jsize, jsize, jint *);
 *     void (*GetLongArrayRegion)(JNIEnv *, jlongArray, jsize, jsize, jlong *);
 *     void (*GetFloatArrayRegion)(JNIEnv *, jfloatArray, jsize, jsize, jfloat *);
 *     void (*GetDoubleArrayRegion)(JNIEnv *, jdoubleArray, jsize, jsize, jdouble *);
 *     void (*SetBooleanArrayRegion)(JNIEnv *, jbooleanArray, jsize, jsize, const jboolean *);
 *     void (*SetByteArrayRegion)(JNIEnv *, jbyteArray, jsize, jsize, const jbyte *);
 *     void (*SetCharArrayRegion)(JNIEnv *, jcharArray, jsize, jsize, const jchar *);
 *     void (*SetShortArrayRegion)(JNIEnv *, jshortArray, jsize, jsize, const jshort *);
 *     void (*SetIntArrayRegion)(JNIEnv *, jintArray, jsize, jsize, const jint *);
 *     void (*SetLongArrayRegion)(JNIEnv *, jlongArray, jsize, jsize, const jlong *);
 *     void (*SetFloatArrayRegion)(JNIEnv *, jfloatArray, jsize, jsize, const jfloat *);
 *     void (*SetDoubleArrayRegion)(JNIEnv *, jdoubleArray, jsize, jsize, const jdouble *);
 *     jint (*RegisterNatives)(JNIEnv *, jclass, const JNINativeMethod *, jint);
 *     jint (*UnregisterNatives)(JNIEnv *, jclass);
 *     jint (*MonitorEnter)(JNIEnv *, jobject);
 *     jint (*MonitorExit)(JNIEnv *, jobject);
 *     jint (*GetJavaVM)(JNIEnv *, JavaVM **);
 *     void (*GetStringRegion)(JNIEnv *, jstring, jsize, jsize, jchar *);
 *     void (*GetStringUTFRegion)(JNIEnv *, jstring, jsize, jsize, char *);
 *     void *(*GetPrimitiveArrayCritical)(JNIEnv *, jarray, jboolean *);
 *     void (*ReleasePrimitiveArrayCritical)(JNIEnv *, jarray, void *, jint);
 *     const jchar *(*GetStringCritical)(JNIEnv *, jstring, jboolean *);
 *     void (*ReleaseStringCritical)(JNIEnv *, jstring, const jchar *);
 *     jweak (*NewWeakGlobalRef)(JNIEnv *, jobject);
 *     void (*DeleteWeakGlobalRef)(JNIEnv *, jweak);
 *     jboolean (*ExceptionCheck)(JNIEnv *);
 *     jobject (*NewDirectByteBuffer)(JNIEnv *, void *, jlong);
 *     void *(*GetDirectBufferAddress)(JNIEnv *, jobject);
 *     jlong (*GetDirectBufferCapacity)(JNIEnv *, jobject);
 *     jobjectRefType (*GetObjectRefType)(JNIEnv *, jobject);
 *     jobject (*GetModule)(JNIEnv *, jclass);
 *     jboolean (*IsVirtualThread)(JNIEnv *, jobject);
 * }
 * }
 */
public class JNINativeInterface_ {

    JNINativeInterface_() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        netty_unix_socket_h.C_POINTER.withName("reserved0"),
        netty_unix_socket_h.C_POINTER.withName("reserved1"),
        netty_unix_socket_h.C_POINTER.withName("reserved2"),
        netty_unix_socket_h.C_POINTER.withName("reserved3"),
        netty_unix_socket_h.C_POINTER.withName("GetVersion"),
        netty_unix_socket_h.C_POINTER.withName("DefineClass"),
        netty_unix_socket_h.C_POINTER.withName("FindClass"),
        netty_unix_socket_h.C_POINTER.withName("FromReflectedMethod"),
        netty_unix_socket_h.C_POINTER.withName("FromReflectedField"),
        netty_unix_socket_h.C_POINTER.withName("ToReflectedMethod"),
        netty_unix_socket_h.C_POINTER.withName("GetSuperclass"),
        netty_unix_socket_h.C_POINTER.withName("IsAssignableFrom"),
        netty_unix_socket_h.C_POINTER.withName("ToReflectedField"),
        netty_unix_socket_h.C_POINTER.withName("Throw"),
        netty_unix_socket_h.C_POINTER.withName("ThrowNew"),
        netty_unix_socket_h.C_POINTER.withName("ExceptionOccurred"),
        netty_unix_socket_h.C_POINTER.withName("ExceptionDescribe"),
        netty_unix_socket_h.C_POINTER.withName("ExceptionClear"),
        netty_unix_socket_h.C_POINTER.withName("FatalError"),
        netty_unix_socket_h.C_POINTER.withName("PushLocalFrame"),
        netty_unix_socket_h.C_POINTER.withName("PopLocalFrame"),
        netty_unix_socket_h.C_POINTER.withName("NewGlobalRef"),
        netty_unix_socket_h.C_POINTER.withName("DeleteGlobalRef"),
        netty_unix_socket_h.C_POINTER.withName("DeleteLocalRef"),
        netty_unix_socket_h.C_POINTER.withName("IsSameObject"),
        netty_unix_socket_h.C_POINTER.withName("NewLocalRef"),
        netty_unix_socket_h.C_POINTER.withName("EnsureLocalCapacity"),
        netty_unix_socket_h.C_POINTER.withName("AllocObject"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("NewObjectV"),
        netty_unix_socket_h.C_POINTER.withName("NewObjectA"),
        netty_unix_socket_h.C_POINTER.withName("GetObjectClass"),
        netty_unix_socket_h.C_POINTER.withName("IsInstanceOf"),
        netty_unix_socket_h.C_POINTER.withName("GetMethodID"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallObjectMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallObjectMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallBooleanMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallBooleanMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallByteMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallByteMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallCharMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallCharMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallShortMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallShortMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallIntMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallIntMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallLongMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallLongMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallFloatMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallFloatMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallDoubleMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallDoubleMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallVoidMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallVoidMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallNonvirtualObjectMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallNonvirtualObjectMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallNonvirtualBooleanMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallNonvirtualBooleanMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallNonvirtualByteMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallNonvirtualByteMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallNonvirtualCharMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallNonvirtualCharMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallNonvirtualShortMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallNonvirtualShortMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallNonvirtualIntMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallNonvirtualIntMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallNonvirtualLongMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallNonvirtualLongMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallNonvirtualFloatMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallNonvirtualFloatMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallNonvirtualDoubleMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallNonvirtualDoubleMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallNonvirtualVoidMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallNonvirtualVoidMethodA"),
        netty_unix_socket_h.C_POINTER.withName("GetFieldID"),
        netty_unix_socket_h.C_POINTER.withName("GetObjectField"),
        netty_unix_socket_h.C_POINTER.withName("GetBooleanField"),
        netty_unix_socket_h.C_POINTER.withName("GetByteField"),
        netty_unix_socket_h.C_POINTER.withName("GetCharField"),
        netty_unix_socket_h.C_POINTER.withName("GetShortField"),
        netty_unix_socket_h.C_POINTER.withName("GetIntField"),
        netty_unix_socket_h.C_POINTER.withName("GetLongField"),
        netty_unix_socket_h.C_POINTER.withName("GetFloatField"),
        netty_unix_socket_h.C_POINTER.withName("GetDoubleField"),
        netty_unix_socket_h.C_POINTER.withName("SetObjectField"),
        netty_unix_socket_h.C_POINTER.withName("SetBooleanField"),
        netty_unix_socket_h.C_POINTER.withName("SetByteField"),
        netty_unix_socket_h.C_POINTER.withName("SetCharField"),
        netty_unix_socket_h.C_POINTER.withName("SetShortField"),
        netty_unix_socket_h.C_POINTER.withName("SetIntField"),
        netty_unix_socket_h.C_POINTER.withName("SetLongField"),
        netty_unix_socket_h.C_POINTER.withName("SetFloatField"),
        netty_unix_socket_h.C_POINTER.withName("SetDoubleField"),
        netty_unix_socket_h.C_POINTER.withName("GetStaticMethodID"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallStaticObjectMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallStaticObjectMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallStaticBooleanMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallStaticBooleanMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallStaticByteMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallStaticByteMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallStaticCharMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallStaticCharMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallStaticShortMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallStaticShortMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallStaticIntMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallStaticIntMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallStaticLongMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallStaticLongMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallStaticFloatMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallStaticFloatMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallStaticDoubleMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallStaticDoubleMethodA"),
        MemoryLayout.paddingLayout(8),
        netty_unix_socket_h.C_POINTER.withName("CallStaticVoidMethodV"),
        netty_unix_socket_h.C_POINTER.withName("CallStaticVoidMethodA"),
        netty_unix_socket_h.C_POINTER.withName("GetStaticFieldID"),
        netty_unix_socket_h.C_POINTER.withName("GetStaticObjectField"),
        netty_unix_socket_h.C_POINTER.withName("GetStaticBooleanField"),
        netty_unix_socket_h.C_POINTER.withName("GetStaticByteField"),
        netty_unix_socket_h.C_POINTER.withName("GetStaticCharField"),
        netty_unix_socket_h.C_POINTER.withName("GetStaticShortField"),
        netty_unix_socket_h.C_POINTER.withName("GetStaticIntField"),
        netty_unix_socket_h.C_POINTER.withName("GetStaticLongField"),
        netty_unix_socket_h.C_POINTER.withName("GetStaticFloatField"),
        netty_unix_socket_h.C_POINTER.withName("GetStaticDoubleField"),
        netty_unix_socket_h.C_POINTER.withName("SetStaticObjectField"),
        netty_unix_socket_h.C_POINTER.withName("SetStaticBooleanField"),
        netty_unix_socket_h.C_POINTER.withName("SetStaticByteField"),
        netty_unix_socket_h.C_POINTER.withName("SetStaticCharField"),
        netty_unix_socket_h.C_POINTER.withName("SetStaticShortField"),
        netty_unix_socket_h.C_POINTER.withName("SetStaticIntField"),
        netty_unix_socket_h.C_POINTER.withName("SetStaticLongField"),
        netty_unix_socket_h.C_POINTER.withName("SetStaticFloatField"),
        netty_unix_socket_h.C_POINTER.withName("SetStaticDoubleField"),
        netty_unix_socket_h.C_POINTER.withName("NewString"),
        netty_unix_socket_h.C_POINTER.withName("GetStringLength"),
        netty_unix_socket_h.C_POINTER.withName("GetStringChars"),
        netty_unix_socket_h.C_POINTER.withName("ReleaseStringChars"),
        netty_unix_socket_h.C_POINTER.withName("NewStringUTF"),
        netty_unix_socket_h.C_POINTER.withName("GetStringUTFLength"),
        netty_unix_socket_h.C_POINTER.withName("GetStringUTFChars"),
        netty_unix_socket_h.C_POINTER.withName("ReleaseStringUTFChars"),
        netty_unix_socket_h.C_POINTER.withName("GetArrayLength"),
        netty_unix_socket_h.C_POINTER.withName("NewObjectArray"),
        netty_unix_socket_h.C_POINTER.withName("GetObjectArrayElement"),
        netty_unix_socket_h.C_POINTER.withName("SetObjectArrayElement"),
        netty_unix_socket_h.C_POINTER.withName("NewBooleanArray"),
        netty_unix_socket_h.C_POINTER.withName("NewByteArray"),
        netty_unix_socket_h.C_POINTER.withName("NewCharArray"),
        netty_unix_socket_h.C_POINTER.withName("NewShortArray"),
        netty_unix_socket_h.C_POINTER.withName("NewIntArray"),
        netty_unix_socket_h.C_POINTER.withName("NewLongArray"),
        netty_unix_socket_h.C_POINTER.withName("NewFloatArray"),
        netty_unix_socket_h.C_POINTER.withName("NewDoubleArray"),
        netty_unix_socket_h.C_POINTER.withName("GetBooleanArrayElements"),
        netty_unix_socket_h.C_POINTER.withName("GetByteArrayElements"),
        netty_unix_socket_h.C_POINTER.withName("GetCharArrayElements"),
        netty_unix_socket_h.C_POINTER.withName("GetShortArrayElements"),
        netty_unix_socket_h.C_POINTER.withName("GetIntArrayElements"),
        netty_unix_socket_h.C_POINTER.withName("GetLongArrayElements"),
        netty_unix_socket_h.C_POINTER.withName("GetFloatArrayElements"),
        netty_unix_socket_h.C_POINTER.withName("GetDoubleArrayElements"),
        netty_unix_socket_h.C_POINTER.withName("ReleaseBooleanArrayElements"),
        netty_unix_socket_h.C_POINTER.withName("ReleaseByteArrayElements"),
        netty_unix_socket_h.C_POINTER.withName("ReleaseCharArrayElements"),
        netty_unix_socket_h.C_POINTER.withName("ReleaseShortArrayElements"),
        netty_unix_socket_h.C_POINTER.withName("ReleaseIntArrayElements"),
        netty_unix_socket_h.C_POINTER.withName("ReleaseLongArrayElements"),
        netty_unix_socket_h.C_POINTER.withName("ReleaseFloatArrayElements"),
        netty_unix_socket_h.C_POINTER.withName("ReleaseDoubleArrayElements"),
        netty_unix_socket_h.C_POINTER.withName("GetBooleanArrayRegion"),
        netty_unix_socket_h.C_POINTER.withName("GetByteArrayRegion"),
        netty_unix_socket_h.C_POINTER.withName("GetCharArrayRegion"),
        netty_unix_socket_h.C_POINTER.withName("GetShortArrayRegion"),
        netty_unix_socket_h.C_POINTER.withName("GetIntArrayRegion"),
        netty_unix_socket_h.C_POINTER.withName("GetLongArrayRegion"),
        netty_unix_socket_h.C_POINTER.withName("GetFloatArrayRegion"),
        netty_unix_socket_h.C_POINTER.withName("GetDoubleArrayRegion"),
        netty_unix_socket_h.C_POINTER.withName("SetBooleanArrayRegion"),
        netty_unix_socket_h.C_POINTER.withName("SetByteArrayRegion"),
        netty_unix_socket_h.C_POINTER.withName("SetCharArrayRegion"),
        netty_unix_socket_h.C_POINTER.withName("SetShortArrayRegion"),
        netty_unix_socket_h.C_POINTER.withName("SetIntArrayRegion"),
        netty_unix_socket_h.C_POINTER.withName("SetLongArrayRegion"),
        netty_unix_socket_h.C_POINTER.withName("SetFloatArrayRegion"),
        netty_unix_socket_h.C_POINTER.withName("SetDoubleArrayRegion"),
        netty_unix_socket_h.C_POINTER.withName("RegisterNatives"),
        netty_unix_socket_h.C_POINTER.withName("UnregisterNatives"),
        netty_unix_socket_h.C_POINTER.withName("MonitorEnter"),
        netty_unix_socket_h.C_POINTER.withName("MonitorExit"),
        netty_unix_socket_h.C_POINTER.withName("GetJavaVM"),
        netty_unix_socket_h.C_POINTER.withName("GetStringRegion"),
        netty_unix_socket_h.C_POINTER.withName("GetStringUTFRegion"),
        netty_unix_socket_h.C_POINTER.withName("GetPrimitiveArrayCritical"),
        netty_unix_socket_h.C_POINTER.withName("ReleasePrimitiveArrayCritical"),
        netty_unix_socket_h.C_POINTER.withName("GetStringCritical"),
        netty_unix_socket_h.C_POINTER.withName("ReleaseStringCritical"),
        netty_unix_socket_h.C_POINTER.withName("NewWeakGlobalRef"),
        netty_unix_socket_h.C_POINTER.withName("DeleteWeakGlobalRef"),
        netty_unix_socket_h.C_POINTER.withName("ExceptionCheck"),
        netty_unix_socket_h.C_POINTER.withName("NewDirectByteBuffer"),
        netty_unix_socket_h.C_POINTER.withName("GetDirectBufferAddress"),
        netty_unix_socket_h.C_POINTER.withName("GetDirectBufferCapacity"),
        netty_unix_socket_h.C_POINTER.withName("GetObjectRefType"),
        netty_unix_socket_h.C_POINTER.withName("GetModule"),
        netty_unix_socket_h.C_POINTER.withName("IsVirtualThread")
    ).withName("JNINativeInterface_");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final AddressLayout reserved0$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("reserved0"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *reserved0
     * }
     */
    public static final AddressLayout reserved0$layout() {
        return reserved0$LAYOUT;
    }

    private static final long reserved0$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *reserved0
     * }
     */
    public static final long reserved0$offset() {
        return reserved0$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *reserved0
     * }
     */
    public static MemorySegment reserved0(MemorySegment struct) {
        return struct.get(reserved0$LAYOUT, reserved0$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *reserved0
     * }
     */
    public static void reserved0(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(reserved0$LAYOUT, reserved0$OFFSET, fieldValue);
    }

    private static final AddressLayout reserved1$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("reserved1"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *reserved1
     * }
     */
    public static final AddressLayout reserved1$layout() {
        return reserved1$LAYOUT;
    }

    private static final long reserved1$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *reserved1
     * }
     */
    public static final long reserved1$offset() {
        return reserved1$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *reserved1
     * }
     */
    public static MemorySegment reserved1(MemorySegment struct) {
        return struct.get(reserved1$LAYOUT, reserved1$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *reserved1
     * }
     */
    public static void reserved1(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(reserved1$LAYOUT, reserved1$OFFSET, fieldValue);
    }

    private static final AddressLayout reserved2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("reserved2"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *reserved2
     * }
     */
    public static final AddressLayout reserved2$layout() {
        return reserved2$LAYOUT;
    }

    private static final long reserved2$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *reserved2
     * }
     */
    public static final long reserved2$offset() {
        return reserved2$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *reserved2
     * }
     */
    public static MemorySegment reserved2(MemorySegment struct) {
        return struct.get(reserved2$LAYOUT, reserved2$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *reserved2
     * }
     */
    public static void reserved2(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(reserved2$LAYOUT, reserved2$OFFSET, fieldValue);
    }

    private static final AddressLayout reserved3$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("reserved3"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *reserved3
     * }
     */
    public static final AddressLayout reserved3$layout() {
        return reserved3$LAYOUT;
    }

    private static final long reserved3$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *reserved3
     * }
     */
    public static final long reserved3$offset() {
        return reserved3$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *reserved3
     * }
     */
    public static MemorySegment reserved3(MemorySegment struct) {
        return struct.get(reserved3$LAYOUT, reserved3$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *reserved3
     * }
     */
    public static void reserved3(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(reserved3$LAYOUT, reserved3$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jint (*GetVersion)(JNIEnv *)
     * }
     */
    public static class GetVersion {

        GetVersion() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetVersion.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetVersion.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetVersion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetVersion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jint (*GetVersion)(JNIEnv *)
     * }
     */
    public static final AddressLayout GetVersion$layout() {
        return GetVersion$LAYOUT;
    }

    private static final long GetVersion$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jint (*GetVersion)(JNIEnv *)
     * }
     */
    public static final long GetVersion$offset() {
        return GetVersion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jint (*GetVersion)(JNIEnv *)
     * }
     */
    public static MemorySegment GetVersion(MemorySegment struct) {
        return struct.get(GetVersion$LAYOUT, GetVersion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jint (*GetVersion)(JNIEnv *)
     * }
     */
    public static void GetVersion(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetVersion$LAYOUT, GetVersion$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jclass (*DefineClass)(JNIEnv *, const char *, jobject, const jbyte *, jsize)
     * }
     */
    public static class DefineClass {

        DefineClass() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, int _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(DefineClass.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(DefineClass.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, int _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout DefineClass$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("DefineClass"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jclass (*DefineClass)(JNIEnv *, const char *, jobject, const jbyte *, jsize)
     * }
     */
    public static final AddressLayout DefineClass$layout() {
        return DefineClass$LAYOUT;
    }

    private static final long DefineClass$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jclass (*DefineClass)(JNIEnv *, const char *, jobject, const jbyte *, jsize)
     * }
     */
    public static final long DefineClass$offset() {
        return DefineClass$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jclass (*DefineClass)(JNIEnv *, const char *, jobject, const jbyte *, jsize)
     * }
     */
    public static MemorySegment DefineClass(MemorySegment struct) {
        return struct.get(DefineClass$LAYOUT, DefineClass$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jclass (*DefineClass)(JNIEnv *, const char *, jobject, const jbyte *, jsize)
     * }
     */
    public static void DefineClass(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(DefineClass$LAYOUT, DefineClass$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jclass (*FindClass)(JNIEnv *, const char *)
     * }
     */
    public static class FindClass {

        FindClass() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(FindClass.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(FindClass.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout FindClass$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("FindClass"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jclass (*FindClass)(JNIEnv *, const char *)
     * }
     */
    public static final AddressLayout FindClass$layout() {
        return FindClass$LAYOUT;
    }

    private static final long FindClass$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jclass (*FindClass)(JNIEnv *, const char *)
     * }
     */
    public static final long FindClass$offset() {
        return FindClass$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jclass (*FindClass)(JNIEnv *, const char *)
     * }
     */
    public static MemorySegment FindClass(MemorySegment struct) {
        return struct.get(FindClass$LAYOUT, FindClass$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jclass (*FindClass)(JNIEnv *, const char *)
     * }
     */
    public static void FindClass(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(FindClass$LAYOUT, FindClass$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jmethodID (*FromReflectedMethod)(JNIEnv *, jobject)
     * }
     */
    public static class FromReflectedMethod {

        FromReflectedMethod() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(FromReflectedMethod.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(FromReflectedMethod.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout FromReflectedMethod$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("FromReflectedMethod"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jmethodID (*FromReflectedMethod)(JNIEnv *, jobject)
     * }
     */
    public static final AddressLayout FromReflectedMethod$layout() {
        return FromReflectedMethod$LAYOUT;
    }

    private static final long FromReflectedMethod$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jmethodID (*FromReflectedMethod)(JNIEnv *, jobject)
     * }
     */
    public static final long FromReflectedMethod$offset() {
        return FromReflectedMethod$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jmethodID (*FromReflectedMethod)(JNIEnv *, jobject)
     * }
     */
    public static MemorySegment FromReflectedMethod(MemorySegment struct) {
        return struct.get(FromReflectedMethod$LAYOUT, FromReflectedMethod$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jmethodID (*FromReflectedMethod)(JNIEnv *, jobject)
     * }
     */
    public static void FromReflectedMethod(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(FromReflectedMethod$LAYOUT, FromReflectedMethod$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jfieldID (*FromReflectedField)(JNIEnv *, jobject)
     * }
     */
    public static class FromReflectedField {

        FromReflectedField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(FromReflectedField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(FromReflectedField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout FromReflectedField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("FromReflectedField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jfieldID (*FromReflectedField)(JNIEnv *, jobject)
     * }
     */
    public static final AddressLayout FromReflectedField$layout() {
        return FromReflectedField$LAYOUT;
    }

    private static final long FromReflectedField$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jfieldID (*FromReflectedField)(JNIEnv *, jobject)
     * }
     */
    public static final long FromReflectedField$offset() {
        return FromReflectedField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jfieldID (*FromReflectedField)(JNIEnv *, jobject)
     * }
     */
    public static MemorySegment FromReflectedField(MemorySegment struct) {
        return struct.get(FromReflectedField$LAYOUT, FromReflectedField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jfieldID (*FromReflectedField)(JNIEnv *, jobject)
     * }
     */
    public static void FromReflectedField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(FromReflectedField$LAYOUT, FromReflectedField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jobject (*ToReflectedMethod)(JNIEnv *, jclass, jmethodID, jboolean)
     * }
     */
    public static class ToReflectedMethod {

        ToReflectedMethod() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, byte _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_CHAR
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(ToReflectedMethod.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ToReflectedMethod.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, byte _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ToReflectedMethod$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ToReflectedMethod"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jobject (*ToReflectedMethod)(JNIEnv *, jclass, jmethodID, jboolean)
     * }
     */
    public static final AddressLayout ToReflectedMethod$layout() {
        return ToReflectedMethod$LAYOUT;
    }

    private static final long ToReflectedMethod$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jobject (*ToReflectedMethod)(JNIEnv *, jclass, jmethodID, jboolean)
     * }
     */
    public static final long ToReflectedMethod$offset() {
        return ToReflectedMethod$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jobject (*ToReflectedMethod)(JNIEnv *, jclass, jmethodID, jboolean)
     * }
     */
    public static MemorySegment ToReflectedMethod(MemorySegment struct) {
        return struct.get(ToReflectedMethod$LAYOUT, ToReflectedMethod$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jobject (*ToReflectedMethod)(JNIEnv *, jclass, jmethodID, jboolean)
     * }
     */
    public static void ToReflectedMethod(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ToReflectedMethod$LAYOUT, ToReflectedMethod$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jclass (*GetSuperclass)(JNIEnv *, jclass)
     * }
     */
    public static class GetSuperclass {

        GetSuperclass() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetSuperclass.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetSuperclass.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetSuperclass$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetSuperclass"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jclass (*GetSuperclass)(JNIEnv *, jclass)
     * }
     */
    public static final AddressLayout GetSuperclass$layout() {
        return GetSuperclass$LAYOUT;
    }

    private static final long GetSuperclass$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jclass (*GetSuperclass)(JNIEnv *, jclass)
     * }
     */
    public static final long GetSuperclass$offset() {
        return GetSuperclass$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jclass (*GetSuperclass)(JNIEnv *, jclass)
     * }
     */
    public static MemorySegment GetSuperclass(MemorySegment struct) {
        return struct.get(GetSuperclass$LAYOUT, GetSuperclass$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jclass (*GetSuperclass)(JNIEnv *, jclass)
     * }
     */
    public static void GetSuperclass(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetSuperclass$LAYOUT, GetSuperclass$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jboolean (*IsAssignableFrom)(JNIEnv *, jclass, jclass)
     * }
     */
    public static class IsAssignableFrom {

        IsAssignableFrom() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            byte apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_CHAR,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(IsAssignableFrom.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(IsAssignableFrom.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static byte invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (byte) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout IsAssignableFrom$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("IsAssignableFrom"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jboolean (*IsAssignableFrom)(JNIEnv *, jclass, jclass)
     * }
     */
    public static final AddressLayout IsAssignableFrom$layout() {
        return IsAssignableFrom$LAYOUT;
    }

    private static final long IsAssignableFrom$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jboolean (*IsAssignableFrom)(JNIEnv *, jclass, jclass)
     * }
     */
    public static final long IsAssignableFrom$offset() {
        return IsAssignableFrom$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jboolean (*IsAssignableFrom)(JNIEnv *, jclass, jclass)
     * }
     */
    public static MemorySegment IsAssignableFrom(MemorySegment struct) {
        return struct.get(IsAssignableFrom$LAYOUT, IsAssignableFrom$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jboolean (*IsAssignableFrom)(JNIEnv *, jclass, jclass)
     * }
     */
    public static void IsAssignableFrom(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(IsAssignableFrom$LAYOUT, IsAssignableFrom$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jobject (*ToReflectedField)(JNIEnv *, jclass, jfieldID, jboolean)
     * }
     */
    public static class ToReflectedField {

        ToReflectedField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, byte _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_CHAR
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(ToReflectedField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ToReflectedField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, byte _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ToReflectedField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ToReflectedField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jobject (*ToReflectedField)(JNIEnv *, jclass, jfieldID, jboolean)
     * }
     */
    public static final AddressLayout ToReflectedField$layout() {
        return ToReflectedField$LAYOUT;
    }

    private static final long ToReflectedField$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jobject (*ToReflectedField)(JNIEnv *, jclass, jfieldID, jboolean)
     * }
     */
    public static final long ToReflectedField$offset() {
        return ToReflectedField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jobject (*ToReflectedField)(JNIEnv *, jclass, jfieldID, jboolean)
     * }
     */
    public static MemorySegment ToReflectedField(MemorySegment struct) {
        return struct.get(ToReflectedField$LAYOUT, ToReflectedField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jobject (*ToReflectedField)(JNIEnv *, jclass, jfieldID, jboolean)
     * }
     */
    public static void ToReflectedField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ToReflectedField$LAYOUT, ToReflectedField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jint (*Throw)(JNIEnv *, jthrowable)
     * }
     */
    public static class Throw {

        Throw() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(Throw.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Throw.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout Throw$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("Throw"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jint (*Throw)(JNIEnv *, jthrowable)
     * }
     */
    public static final AddressLayout Throw$layout() {
        return Throw$LAYOUT;
    }

    private static final long Throw$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jint (*Throw)(JNIEnv *, jthrowable)
     * }
     */
    public static final long Throw$offset() {
        return Throw$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jint (*Throw)(JNIEnv *, jthrowable)
     * }
     */
    public static MemorySegment Throw(MemorySegment struct) {
        return struct.get(Throw$LAYOUT, Throw$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jint (*Throw)(JNIEnv *, jthrowable)
     * }
     */
    public static void Throw(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Throw$LAYOUT, Throw$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jint (*ThrowNew)(JNIEnv *, jclass, const char *)
     * }
     */
    public static class ThrowNew {

        ThrowNew() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(ThrowNew.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ThrowNew.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ThrowNew$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ThrowNew"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jint (*ThrowNew)(JNIEnv *, jclass, const char *)
     * }
     */
    public static final AddressLayout ThrowNew$layout() {
        return ThrowNew$LAYOUT;
    }

    private static final long ThrowNew$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jint (*ThrowNew)(JNIEnv *, jclass, const char *)
     * }
     */
    public static final long ThrowNew$offset() {
        return ThrowNew$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jint (*ThrowNew)(JNIEnv *, jclass, const char *)
     * }
     */
    public static MemorySegment ThrowNew(MemorySegment struct) {
        return struct.get(ThrowNew$LAYOUT, ThrowNew$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jint (*ThrowNew)(JNIEnv *, jclass, const char *)
     * }
     */
    public static void ThrowNew(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ThrowNew$LAYOUT, ThrowNew$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jthrowable (*ExceptionOccurred)(JNIEnv *)
     * }
     */
    public static class ExceptionOccurred {

        ExceptionOccurred() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(ExceptionOccurred.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ExceptionOccurred.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ExceptionOccurred$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ExceptionOccurred"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jthrowable (*ExceptionOccurred)(JNIEnv *)
     * }
     */
    public static final AddressLayout ExceptionOccurred$layout() {
        return ExceptionOccurred$LAYOUT;
    }

    private static final long ExceptionOccurred$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jthrowable (*ExceptionOccurred)(JNIEnv *)
     * }
     */
    public static final long ExceptionOccurred$offset() {
        return ExceptionOccurred$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jthrowable (*ExceptionOccurred)(JNIEnv *)
     * }
     */
    public static MemorySegment ExceptionOccurred(MemorySegment struct) {
        return struct.get(ExceptionOccurred$LAYOUT, ExceptionOccurred$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jthrowable (*ExceptionOccurred)(JNIEnv *)
     * }
     */
    public static void ExceptionOccurred(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ExceptionOccurred$LAYOUT, ExceptionOccurred$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ExceptionDescribe)(JNIEnv *)
     * }
     */
    public static class ExceptionDescribe {

        ExceptionDescribe() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(ExceptionDescribe.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ExceptionDescribe.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ExceptionDescribe$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ExceptionDescribe"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ExceptionDescribe)(JNIEnv *)
     * }
     */
    public static final AddressLayout ExceptionDescribe$layout() {
        return ExceptionDescribe$LAYOUT;
    }

    private static final long ExceptionDescribe$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ExceptionDescribe)(JNIEnv *)
     * }
     */
    public static final long ExceptionDescribe$offset() {
        return ExceptionDescribe$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ExceptionDescribe)(JNIEnv *)
     * }
     */
    public static MemorySegment ExceptionDescribe(MemorySegment struct) {
        return struct.get(ExceptionDescribe$LAYOUT, ExceptionDescribe$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ExceptionDescribe)(JNIEnv *)
     * }
     */
    public static void ExceptionDescribe(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ExceptionDescribe$LAYOUT, ExceptionDescribe$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ExceptionClear)(JNIEnv *)
     * }
     */
    public static class ExceptionClear {

        ExceptionClear() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(ExceptionClear.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ExceptionClear.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ExceptionClear$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ExceptionClear"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ExceptionClear)(JNIEnv *)
     * }
     */
    public static final AddressLayout ExceptionClear$layout() {
        return ExceptionClear$LAYOUT;
    }

    private static final long ExceptionClear$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ExceptionClear)(JNIEnv *)
     * }
     */
    public static final long ExceptionClear$offset() {
        return ExceptionClear$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ExceptionClear)(JNIEnv *)
     * }
     */
    public static MemorySegment ExceptionClear(MemorySegment struct) {
        return struct.get(ExceptionClear$LAYOUT, ExceptionClear$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ExceptionClear)(JNIEnv *)
     * }
     */
    public static void ExceptionClear(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ExceptionClear$LAYOUT, ExceptionClear$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*FatalError)(JNIEnv *, const char *)
     * }
     */
    public static class FatalError {

        FatalError() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(FatalError.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(FatalError.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout FatalError$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("FatalError"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*FatalError)(JNIEnv *, const char *)
     * }
     */
    public static final AddressLayout FatalError$layout() {
        return FatalError$LAYOUT;
    }

    private static final long FatalError$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*FatalError)(JNIEnv *, const char *)
     * }
     */
    public static final long FatalError$offset() {
        return FatalError$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*FatalError)(JNIEnv *, const char *)
     * }
     */
    public static MemorySegment FatalError(MemorySegment struct) {
        return struct.get(FatalError$LAYOUT, FatalError$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*FatalError)(JNIEnv *, const char *)
     * }
     */
    public static void FatalError(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(FatalError$LAYOUT, FatalError$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jint (*PushLocalFrame)(JNIEnv *, jint)
     * }
     */
    public static class PushLocalFrame {

        PushLocalFrame() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(PushLocalFrame.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(PushLocalFrame.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout PushLocalFrame$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("PushLocalFrame"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jint (*PushLocalFrame)(JNIEnv *, jint)
     * }
     */
    public static final AddressLayout PushLocalFrame$layout() {
        return PushLocalFrame$LAYOUT;
    }

    private static final long PushLocalFrame$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jint (*PushLocalFrame)(JNIEnv *, jint)
     * }
     */
    public static final long PushLocalFrame$offset() {
        return PushLocalFrame$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jint (*PushLocalFrame)(JNIEnv *, jint)
     * }
     */
    public static MemorySegment PushLocalFrame(MemorySegment struct) {
        return struct.get(PushLocalFrame$LAYOUT, PushLocalFrame$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jint (*PushLocalFrame)(JNIEnv *, jint)
     * }
     */
    public static void PushLocalFrame(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(PushLocalFrame$LAYOUT, PushLocalFrame$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jobject (*PopLocalFrame)(JNIEnv *, jobject)
     * }
     */
    public static class PopLocalFrame {

        PopLocalFrame() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(PopLocalFrame.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(PopLocalFrame.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout PopLocalFrame$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("PopLocalFrame"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jobject (*PopLocalFrame)(JNIEnv *, jobject)
     * }
     */
    public static final AddressLayout PopLocalFrame$layout() {
        return PopLocalFrame$LAYOUT;
    }

    private static final long PopLocalFrame$OFFSET = 160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jobject (*PopLocalFrame)(JNIEnv *, jobject)
     * }
     */
    public static final long PopLocalFrame$offset() {
        return PopLocalFrame$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jobject (*PopLocalFrame)(JNIEnv *, jobject)
     * }
     */
    public static MemorySegment PopLocalFrame(MemorySegment struct) {
        return struct.get(PopLocalFrame$LAYOUT, PopLocalFrame$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jobject (*PopLocalFrame)(JNIEnv *, jobject)
     * }
     */
    public static void PopLocalFrame(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(PopLocalFrame$LAYOUT, PopLocalFrame$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jobject (*NewGlobalRef)(JNIEnv *, jobject)
     * }
     */
    public static class NewGlobalRef {

        NewGlobalRef() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(NewGlobalRef.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(NewGlobalRef.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout NewGlobalRef$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("NewGlobalRef"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jobject (*NewGlobalRef)(JNIEnv *, jobject)
     * }
     */
    public static final AddressLayout NewGlobalRef$layout() {
        return NewGlobalRef$LAYOUT;
    }

    private static final long NewGlobalRef$OFFSET = 168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jobject (*NewGlobalRef)(JNIEnv *, jobject)
     * }
     */
    public static final long NewGlobalRef$offset() {
        return NewGlobalRef$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jobject (*NewGlobalRef)(JNIEnv *, jobject)
     * }
     */
    public static MemorySegment NewGlobalRef(MemorySegment struct) {
        return struct.get(NewGlobalRef$LAYOUT, NewGlobalRef$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jobject (*NewGlobalRef)(JNIEnv *, jobject)
     * }
     */
    public static void NewGlobalRef(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(NewGlobalRef$LAYOUT, NewGlobalRef$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*DeleteGlobalRef)(JNIEnv *, jobject)
     * }
     */
    public static class DeleteGlobalRef {

        DeleteGlobalRef() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(DeleteGlobalRef.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(DeleteGlobalRef.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout DeleteGlobalRef$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("DeleteGlobalRef"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*DeleteGlobalRef)(JNIEnv *, jobject)
     * }
     */
    public static final AddressLayout DeleteGlobalRef$layout() {
        return DeleteGlobalRef$LAYOUT;
    }

    private static final long DeleteGlobalRef$OFFSET = 176;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*DeleteGlobalRef)(JNIEnv *, jobject)
     * }
     */
    public static final long DeleteGlobalRef$offset() {
        return DeleteGlobalRef$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*DeleteGlobalRef)(JNIEnv *, jobject)
     * }
     */
    public static MemorySegment DeleteGlobalRef(MemorySegment struct) {
        return struct.get(DeleteGlobalRef$LAYOUT, DeleteGlobalRef$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*DeleteGlobalRef)(JNIEnv *, jobject)
     * }
     */
    public static void DeleteGlobalRef(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(DeleteGlobalRef$LAYOUT, DeleteGlobalRef$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*DeleteLocalRef)(JNIEnv *, jobject)
     * }
     */
    public static class DeleteLocalRef {

        DeleteLocalRef() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(DeleteLocalRef.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(DeleteLocalRef.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout DeleteLocalRef$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("DeleteLocalRef"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*DeleteLocalRef)(JNIEnv *, jobject)
     * }
     */
    public static final AddressLayout DeleteLocalRef$layout() {
        return DeleteLocalRef$LAYOUT;
    }

    private static final long DeleteLocalRef$OFFSET = 184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*DeleteLocalRef)(JNIEnv *, jobject)
     * }
     */
    public static final long DeleteLocalRef$offset() {
        return DeleteLocalRef$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*DeleteLocalRef)(JNIEnv *, jobject)
     * }
     */
    public static MemorySegment DeleteLocalRef(MemorySegment struct) {
        return struct.get(DeleteLocalRef$LAYOUT, DeleteLocalRef$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*DeleteLocalRef)(JNIEnv *, jobject)
     * }
     */
    public static void DeleteLocalRef(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(DeleteLocalRef$LAYOUT, DeleteLocalRef$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jboolean (*IsSameObject)(JNIEnv *, jobject, jobject)
     * }
     */
    public static class IsSameObject {

        IsSameObject() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            byte apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_CHAR,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(IsSameObject.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(IsSameObject.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static byte invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (byte) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout IsSameObject$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("IsSameObject"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jboolean (*IsSameObject)(JNIEnv *, jobject, jobject)
     * }
     */
    public static final AddressLayout IsSameObject$layout() {
        return IsSameObject$LAYOUT;
    }

    private static final long IsSameObject$OFFSET = 192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jboolean (*IsSameObject)(JNIEnv *, jobject, jobject)
     * }
     */
    public static final long IsSameObject$offset() {
        return IsSameObject$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jboolean (*IsSameObject)(JNIEnv *, jobject, jobject)
     * }
     */
    public static MemorySegment IsSameObject(MemorySegment struct) {
        return struct.get(IsSameObject$LAYOUT, IsSameObject$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jboolean (*IsSameObject)(JNIEnv *, jobject, jobject)
     * }
     */
    public static void IsSameObject(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(IsSameObject$LAYOUT, IsSameObject$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jobject (*NewLocalRef)(JNIEnv *, jobject)
     * }
     */
    public static class NewLocalRef {

        NewLocalRef() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(NewLocalRef.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(NewLocalRef.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout NewLocalRef$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("NewLocalRef"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jobject (*NewLocalRef)(JNIEnv *, jobject)
     * }
     */
    public static final AddressLayout NewLocalRef$layout() {
        return NewLocalRef$LAYOUT;
    }

    private static final long NewLocalRef$OFFSET = 200;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jobject (*NewLocalRef)(JNIEnv *, jobject)
     * }
     */
    public static final long NewLocalRef$offset() {
        return NewLocalRef$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jobject (*NewLocalRef)(JNIEnv *, jobject)
     * }
     */
    public static MemorySegment NewLocalRef(MemorySegment struct) {
        return struct.get(NewLocalRef$LAYOUT, NewLocalRef$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jobject (*NewLocalRef)(JNIEnv *, jobject)
     * }
     */
    public static void NewLocalRef(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(NewLocalRef$LAYOUT, NewLocalRef$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jint (*EnsureLocalCapacity)(JNIEnv *, jint)
     * }
     */
    public static class EnsureLocalCapacity {

        EnsureLocalCapacity() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(EnsureLocalCapacity.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(EnsureLocalCapacity.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout EnsureLocalCapacity$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("EnsureLocalCapacity"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jint (*EnsureLocalCapacity)(JNIEnv *, jint)
     * }
     */
    public static final AddressLayout EnsureLocalCapacity$layout() {
        return EnsureLocalCapacity$LAYOUT;
    }

    private static final long EnsureLocalCapacity$OFFSET = 208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jint (*EnsureLocalCapacity)(JNIEnv *, jint)
     * }
     */
    public static final long EnsureLocalCapacity$offset() {
        return EnsureLocalCapacity$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jint (*EnsureLocalCapacity)(JNIEnv *, jint)
     * }
     */
    public static MemorySegment EnsureLocalCapacity(MemorySegment struct) {
        return struct.get(EnsureLocalCapacity$LAYOUT, EnsureLocalCapacity$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jint (*EnsureLocalCapacity)(JNIEnv *, jint)
     * }
     */
    public static void EnsureLocalCapacity(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(EnsureLocalCapacity$LAYOUT, EnsureLocalCapacity$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jobject (*AllocObject)(JNIEnv *, jclass)
     * }
     */
    public static class AllocObject {

        AllocObject() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(AllocObject.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AllocObject.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout AllocObject$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("AllocObject"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jobject (*AllocObject)(JNIEnv *, jclass)
     * }
     */
    public static final AddressLayout AllocObject$layout() {
        return AllocObject$LAYOUT;
    }

    private static final long AllocObject$OFFSET = 216;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jobject (*AllocObject)(JNIEnv *, jclass)
     * }
     */
    public static final long AllocObject$offset() {
        return AllocObject$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jobject (*AllocObject)(JNIEnv *, jclass)
     * }
     */
    public static MemorySegment AllocObject(MemorySegment struct) {
        return struct.get(AllocObject$LAYOUT, AllocObject$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jobject (*AllocObject)(JNIEnv *, jclass)
     * }
     */
    public static void AllocObject(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AllocObject$LAYOUT, AllocObject$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jobject (*NewObjectV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static class NewObjectV {

        NewObjectV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(NewObjectV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(NewObjectV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout NewObjectV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("NewObjectV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jobject (*NewObjectV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static final AddressLayout NewObjectV$layout() {
        return NewObjectV$LAYOUT;
    }

    private static final long NewObjectV$OFFSET = 232;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jobject (*NewObjectV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static final long NewObjectV$offset() {
        return NewObjectV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jobject (*NewObjectV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static MemorySegment NewObjectV(MemorySegment struct) {
        return struct.get(NewObjectV$LAYOUT, NewObjectV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jobject (*NewObjectV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static void NewObjectV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(NewObjectV$LAYOUT, NewObjectV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jobject (*NewObjectA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static class NewObjectA {

        NewObjectA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(NewObjectA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(NewObjectA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout NewObjectA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("NewObjectA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jobject (*NewObjectA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout NewObjectA$layout() {
        return NewObjectA$LAYOUT;
    }

    private static final long NewObjectA$OFFSET = 240;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jobject (*NewObjectA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final long NewObjectA$offset() {
        return NewObjectA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jobject (*NewObjectA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment NewObjectA(MemorySegment struct) {
        return struct.get(NewObjectA$LAYOUT, NewObjectA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jobject (*NewObjectA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static void NewObjectA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(NewObjectA$LAYOUT, NewObjectA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jclass (*GetObjectClass)(JNIEnv *, jobject)
     * }
     */
    public static class GetObjectClass {

        GetObjectClass() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetObjectClass.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetObjectClass.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetObjectClass$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetObjectClass"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jclass (*GetObjectClass)(JNIEnv *, jobject)
     * }
     */
    public static final AddressLayout GetObjectClass$layout() {
        return GetObjectClass$LAYOUT;
    }

    private static final long GetObjectClass$OFFSET = 248;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jclass (*GetObjectClass)(JNIEnv *, jobject)
     * }
     */
    public static final long GetObjectClass$offset() {
        return GetObjectClass$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jclass (*GetObjectClass)(JNIEnv *, jobject)
     * }
     */
    public static MemorySegment GetObjectClass(MemorySegment struct) {
        return struct.get(GetObjectClass$LAYOUT, GetObjectClass$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jclass (*GetObjectClass)(JNIEnv *, jobject)
     * }
     */
    public static void GetObjectClass(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetObjectClass$LAYOUT, GetObjectClass$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jboolean (*IsInstanceOf)(JNIEnv *, jobject, jclass)
     * }
     */
    public static class IsInstanceOf {

        IsInstanceOf() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            byte apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_CHAR,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(IsInstanceOf.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(IsInstanceOf.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static byte invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (byte) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout IsInstanceOf$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("IsInstanceOf"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jboolean (*IsInstanceOf)(JNIEnv *, jobject, jclass)
     * }
     */
    public static final AddressLayout IsInstanceOf$layout() {
        return IsInstanceOf$LAYOUT;
    }

    private static final long IsInstanceOf$OFFSET = 256;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jboolean (*IsInstanceOf)(JNIEnv *, jobject, jclass)
     * }
     */
    public static final long IsInstanceOf$offset() {
        return IsInstanceOf$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jboolean (*IsInstanceOf)(JNIEnv *, jobject, jclass)
     * }
     */
    public static MemorySegment IsInstanceOf(MemorySegment struct) {
        return struct.get(IsInstanceOf$LAYOUT, IsInstanceOf$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jboolean (*IsInstanceOf)(JNIEnv *, jobject, jclass)
     * }
     */
    public static void IsInstanceOf(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(IsInstanceOf$LAYOUT, IsInstanceOf$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jmethodID (*GetMethodID)(JNIEnv *, jclass, const char *, const char *)
     * }
     */
    public static class GetMethodID {

        GetMethodID() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetMethodID.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetMethodID.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetMethodID$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetMethodID"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jmethodID (*GetMethodID)(JNIEnv *, jclass, const char *, const char *)
     * }
     */
    public static final AddressLayout GetMethodID$layout() {
        return GetMethodID$LAYOUT;
    }

    private static final long GetMethodID$OFFSET = 264;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jmethodID (*GetMethodID)(JNIEnv *, jclass, const char *, const char *)
     * }
     */
    public static final long GetMethodID$offset() {
        return GetMethodID$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jmethodID (*GetMethodID)(JNIEnv *, jclass, const char *, const char *)
     * }
     */
    public static MemorySegment GetMethodID(MemorySegment struct) {
        return struct.get(GetMethodID$LAYOUT, GetMethodID$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jmethodID (*GetMethodID)(JNIEnv *, jclass, const char *, const char *)
     * }
     */
    public static void GetMethodID(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetMethodID$LAYOUT, GetMethodID$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jobject (*CallObjectMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static class CallObjectMethodV {

        CallObjectMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallObjectMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallObjectMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallObjectMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallObjectMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jobject (*CallObjectMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallObjectMethodV$layout() {
        return CallObjectMethodV$LAYOUT;
    }

    private static final long CallObjectMethodV$OFFSET = 280;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jobject (*CallObjectMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static final long CallObjectMethodV$offset() {
        return CallObjectMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jobject (*CallObjectMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallObjectMethodV(MemorySegment struct) {
        return struct.get(CallObjectMethodV$LAYOUT, CallObjectMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jobject (*CallObjectMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static void CallObjectMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallObjectMethodV$LAYOUT, CallObjectMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jobject (*CallObjectMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static class CallObjectMethodA {

        CallObjectMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallObjectMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallObjectMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallObjectMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallObjectMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jobject (*CallObjectMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallObjectMethodA$layout() {
        return CallObjectMethodA$LAYOUT;
    }

    private static final long CallObjectMethodA$OFFSET = 288;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jobject (*CallObjectMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static final long CallObjectMethodA$offset() {
        return CallObjectMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jobject (*CallObjectMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallObjectMethodA(MemorySegment struct) {
        return struct.get(CallObjectMethodA$LAYOUT, CallObjectMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jobject (*CallObjectMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static void CallObjectMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallObjectMethodA$LAYOUT, CallObjectMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jboolean (*CallBooleanMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static class CallBooleanMethodV {

        CallBooleanMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            byte apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_CHAR,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallBooleanMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallBooleanMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static byte invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (byte) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallBooleanMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallBooleanMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jboolean (*CallBooleanMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallBooleanMethodV$layout() {
        return CallBooleanMethodV$LAYOUT;
    }

    private static final long CallBooleanMethodV$OFFSET = 304;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jboolean (*CallBooleanMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static final long CallBooleanMethodV$offset() {
        return CallBooleanMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jboolean (*CallBooleanMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallBooleanMethodV(MemorySegment struct) {
        return struct.get(CallBooleanMethodV$LAYOUT, CallBooleanMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jboolean (*CallBooleanMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static void CallBooleanMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallBooleanMethodV$LAYOUT, CallBooleanMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jboolean (*CallBooleanMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static class CallBooleanMethodA {

        CallBooleanMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            byte apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_CHAR,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallBooleanMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallBooleanMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static byte invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (byte) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallBooleanMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallBooleanMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jboolean (*CallBooleanMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallBooleanMethodA$layout() {
        return CallBooleanMethodA$LAYOUT;
    }

    private static final long CallBooleanMethodA$OFFSET = 312;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jboolean (*CallBooleanMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static final long CallBooleanMethodA$offset() {
        return CallBooleanMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jboolean (*CallBooleanMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallBooleanMethodA(MemorySegment struct) {
        return struct.get(CallBooleanMethodA$LAYOUT, CallBooleanMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jboolean (*CallBooleanMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static void CallBooleanMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallBooleanMethodA$LAYOUT, CallBooleanMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jbyte (*CallByteMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static class CallByteMethodV {

        CallByteMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            byte apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_CHAR,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallByteMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallByteMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static byte invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (byte) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallByteMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallByteMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jbyte (*CallByteMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallByteMethodV$layout() {
        return CallByteMethodV$LAYOUT;
    }

    private static final long CallByteMethodV$OFFSET = 328;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jbyte (*CallByteMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static final long CallByteMethodV$offset() {
        return CallByteMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jbyte (*CallByteMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallByteMethodV(MemorySegment struct) {
        return struct.get(CallByteMethodV$LAYOUT, CallByteMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jbyte (*CallByteMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static void CallByteMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallByteMethodV$LAYOUT, CallByteMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jbyte (*CallByteMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static class CallByteMethodA {

        CallByteMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            byte apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_CHAR,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallByteMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallByteMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static byte invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (byte) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallByteMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallByteMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jbyte (*CallByteMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallByteMethodA$layout() {
        return CallByteMethodA$LAYOUT;
    }

    private static final long CallByteMethodA$OFFSET = 336;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jbyte (*CallByteMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static final long CallByteMethodA$offset() {
        return CallByteMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jbyte (*CallByteMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallByteMethodA(MemorySegment struct) {
        return struct.get(CallByteMethodA$LAYOUT, CallByteMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jbyte (*CallByteMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static void CallByteMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallByteMethodA$LAYOUT, CallByteMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jchar (*CallCharMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static class CallCharMethodV {

        CallCharMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            short apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_SHORT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallCharMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallCharMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static short invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (short) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallCharMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallCharMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jchar (*CallCharMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallCharMethodV$layout() {
        return CallCharMethodV$LAYOUT;
    }

    private static final long CallCharMethodV$OFFSET = 352;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jchar (*CallCharMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static final long CallCharMethodV$offset() {
        return CallCharMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jchar (*CallCharMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallCharMethodV(MemorySegment struct) {
        return struct.get(CallCharMethodV$LAYOUT, CallCharMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jchar (*CallCharMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static void CallCharMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallCharMethodV$LAYOUT, CallCharMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jchar (*CallCharMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static class CallCharMethodA {

        CallCharMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            short apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_SHORT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallCharMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallCharMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static short invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (short) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallCharMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallCharMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jchar (*CallCharMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallCharMethodA$layout() {
        return CallCharMethodA$LAYOUT;
    }

    private static final long CallCharMethodA$OFFSET = 360;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jchar (*CallCharMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static final long CallCharMethodA$offset() {
        return CallCharMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jchar (*CallCharMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallCharMethodA(MemorySegment struct) {
        return struct.get(CallCharMethodA$LAYOUT, CallCharMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jchar (*CallCharMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static void CallCharMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallCharMethodA$LAYOUT, CallCharMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jshort (*CallShortMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static class CallShortMethodV {

        CallShortMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            short apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_SHORT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallShortMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallShortMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static short invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (short) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallShortMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallShortMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jshort (*CallShortMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallShortMethodV$layout() {
        return CallShortMethodV$LAYOUT;
    }

    private static final long CallShortMethodV$OFFSET = 376;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jshort (*CallShortMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static final long CallShortMethodV$offset() {
        return CallShortMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jshort (*CallShortMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallShortMethodV(MemorySegment struct) {
        return struct.get(CallShortMethodV$LAYOUT, CallShortMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jshort (*CallShortMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static void CallShortMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallShortMethodV$LAYOUT, CallShortMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jshort (*CallShortMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static class CallShortMethodA {

        CallShortMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            short apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_SHORT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallShortMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallShortMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static short invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (short) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallShortMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallShortMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jshort (*CallShortMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallShortMethodA$layout() {
        return CallShortMethodA$LAYOUT;
    }

    private static final long CallShortMethodA$OFFSET = 384;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jshort (*CallShortMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static final long CallShortMethodA$offset() {
        return CallShortMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jshort (*CallShortMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallShortMethodA(MemorySegment struct) {
        return struct.get(CallShortMethodA$LAYOUT, CallShortMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jshort (*CallShortMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static void CallShortMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallShortMethodA$LAYOUT, CallShortMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jint (*CallIntMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static class CallIntMethodV {

        CallIntMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallIntMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallIntMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallIntMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallIntMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jint (*CallIntMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallIntMethodV$layout() {
        return CallIntMethodV$LAYOUT;
    }

    private static final long CallIntMethodV$OFFSET = 400;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jint (*CallIntMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static final long CallIntMethodV$offset() {
        return CallIntMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jint (*CallIntMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallIntMethodV(MemorySegment struct) {
        return struct.get(CallIntMethodV$LAYOUT, CallIntMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jint (*CallIntMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static void CallIntMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallIntMethodV$LAYOUT, CallIntMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jint (*CallIntMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static class CallIntMethodA {

        CallIntMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallIntMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallIntMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallIntMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallIntMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jint (*CallIntMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallIntMethodA$layout() {
        return CallIntMethodA$LAYOUT;
    }

    private static final long CallIntMethodA$OFFSET = 408;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jint (*CallIntMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static final long CallIntMethodA$offset() {
        return CallIntMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jint (*CallIntMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallIntMethodA(MemorySegment struct) {
        return struct.get(CallIntMethodA$LAYOUT, CallIntMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jint (*CallIntMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static void CallIntMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallIntMethodA$LAYOUT, CallIntMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jlong (*CallLongMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static class CallLongMethodV {

        CallLongMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_LONG,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallLongMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallLongMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallLongMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallLongMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jlong (*CallLongMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallLongMethodV$layout() {
        return CallLongMethodV$LAYOUT;
    }

    private static final long CallLongMethodV$OFFSET = 424;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jlong (*CallLongMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static final long CallLongMethodV$offset() {
        return CallLongMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jlong (*CallLongMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallLongMethodV(MemorySegment struct) {
        return struct.get(CallLongMethodV$LAYOUT, CallLongMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jlong (*CallLongMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static void CallLongMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallLongMethodV$LAYOUT, CallLongMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jlong (*CallLongMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static class CallLongMethodA {

        CallLongMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_LONG,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallLongMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallLongMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallLongMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallLongMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jlong (*CallLongMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallLongMethodA$layout() {
        return CallLongMethodA$LAYOUT;
    }

    private static final long CallLongMethodA$OFFSET = 432;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jlong (*CallLongMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static final long CallLongMethodA$offset() {
        return CallLongMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jlong (*CallLongMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallLongMethodA(MemorySegment struct) {
        return struct.get(CallLongMethodA$LAYOUT, CallLongMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jlong (*CallLongMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static void CallLongMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallLongMethodA$LAYOUT, CallLongMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jfloat (*CallFloatMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static class CallFloatMethodV {

        CallFloatMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            float apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_FLOAT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallFloatMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallFloatMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static float invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (float) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallFloatMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallFloatMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jfloat (*CallFloatMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallFloatMethodV$layout() {
        return CallFloatMethodV$LAYOUT;
    }

    private static final long CallFloatMethodV$OFFSET = 448;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jfloat (*CallFloatMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static final long CallFloatMethodV$offset() {
        return CallFloatMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jfloat (*CallFloatMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallFloatMethodV(MemorySegment struct) {
        return struct.get(CallFloatMethodV$LAYOUT, CallFloatMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jfloat (*CallFloatMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static void CallFloatMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallFloatMethodV$LAYOUT, CallFloatMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jfloat (*CallFloatMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static class CallFloatMethodA {

        CallFloatMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            float apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_FLOAT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallFloatMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallFloatMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static float invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (float) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallFloatMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallFloatMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jfloat (*CallFloatMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallFloatMethodA$layout() {
        return CallFloatMethodA$LAYOUT;
    }

    private static final long CallFloatMethodA$OFFSET = 456;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jfloat (*CallFloatMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static final long CallFloatMethodA$offset() {
        return CallFloatMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jfloat (*CallFloatMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallFloatMethodA(MemorySegment struct) {
        return struct.get(CallFloatMethodA$LAYOUT, CallFloatMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jfloat (*CallFloatMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static void CallFloatMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallFloatMethodA$LAYOUT, CallFloatMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jdouble (*CallDoubleMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static class CallDoubleMethodV {

        CallDoubleMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            double apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_DOUBLE,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallDoubleMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallDoubleMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static double invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (double) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallDoubleMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallDoubleMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jdouble (*CallDoubleMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallDoubleMethodV$layout() {
        return CallDoubleMethodV$LAYOUT;
    }

    private static final long CallDoubleMethodV$OFFSET = 472;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jdouble (*CallDoubleMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static final long CallDoubleMethodV$offset() {
        return CallDoubleMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jdouble (*CallDoubleMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallDoubleMethodV(MemorySegment struct) {
        return struct.get(CallDoubleMethodV$LAYOUT, CallDoubleMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jdouble (*CallDoubleMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static void CallDoubleMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallDoubleMethodV$LAYOUT, CallDoubleMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jdouble (*CallDoubleMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static class CallDoubleMethodA {

        CallDoubleMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            double apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_DOUBLE,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallDoubleMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallDoubleMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static double invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (double) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallDoubleMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallDoubleMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jdouble (*CallDoubleMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallDoubleMethodA$layout() {
        return CallDoubleMethodA$LAYOUT;
    }

    private static final long CallDoubleMethodA$OFFSET = 480;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jdouble (*CallDoubleMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static final long CallDoubleMethodA$offset() {
        return CallDoubleMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jdouble (*CallDoubleMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallDoubleMethodA(MemorySegment struct) {
        return struct.get(CallDoubleMethodA$LAYOUT, CallDoubleMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jdouble (*CallDoubleMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static void CallDoubleMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallDoubleMethodA$LAYOUT, CallDoubleMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*CallVoidMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static class CallVoidMethodV {

        CallVoidMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallVoidMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallVoidMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallVoidMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallVoidMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*CallVoidMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallVoidMethodV$layout() {
        return CallVoidMethodV$LAYOUT;
    }

    private static final long CallVoidMethodV$OFFSET = 496;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*CallVoidMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static final long CallVoidMethodV$offset() {
        return CallVoidMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*CallVoidMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallVoidMethodV(MemorySegment struct) {
        return struct.get(CallVoidMethodV$LAYOUT, CallVoidMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*CallVoidMethodV)(JNIEnv *, jobject, jmethodID, va_list)
     * }
     */
    public static void CallVoidMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallVoidMethodV$LAYOUT, CallVoidMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*CallVoidMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static class CallVoidMethodA {

        CallVoidMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallVoidMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallVoidMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallVoidMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallVoidMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*CallVoidMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallVoidMethodA$layout() {
        return CallVoidMethodA$LAYOUT;
    }

    private static final long CallVoidMethodA$OFFSET = 504;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*CallVoidMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static final long CallVoidMethodA$offset() {
        return CallVoidMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*CallVoidMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallVoidMethodA(MemorySegment struct) {
        return struct.get(CallVoidMethodA$LAYOUT, CallVoidMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*CallVoidMethodA)(JNIEnv *, jobject, jmethodID, const jvalue *)
     * }
     */
    public static void CallVoidMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallVoidMethodA$LAYOUT, CallVoidMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jobject (*CallNonvirtualObjectMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static class CallNonvirtualObjectMethodV {

        CallNonvirtualObjectMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallNonvirtualObjectMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallNonvirtualObjectMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallNonvirtualObjectMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallNonvirtualObjectMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jobject (*CallNonvirtualObjectMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallNonvirtualObjectMethodV$layout() {
        return CallNonvirtualObjectMethodV$LAYOUT;
    }

    private static final long CallNonvirtualObjectMethodV$OFFSET = 520;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jobject (*CallNonvirtualObjectMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static final long CallNonvirtualObjectMethodV$offset() {
        return CallNonvirtualObjectMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jobject (*CallNonvirtualObjectMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallNonvirtualObjectMethodV(MemorySegment struct) {
        return struct.get(CallNonvirtualObjectMethodV$LAYOUT, CallNonvirtualObjectMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jobject (*CallNonvirtualObjectMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static void CallNonvirtualObjectMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallNonvirtualObjectMethodV$LAYOUT, CallNonvirtualObjectMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jobject (*CallNonvirtualObjectMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static class CallNonvirtualObjectMethodA {

        CallNonvirtualObjectMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallNonvirtualObjectMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallNonvirtualObjectMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallNonvirtualObjectMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallNonvirtualObjectMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jobject (*CallNonvirtualObjectMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallNonvirtualObjectMethodA$layout() {
        return CallNonvirtualObjectMethodA$LAYOUT;
    }

    private static final long CallNonvirtualObjectMethodA$OFFSET = 528;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jobject (*CallNonvirtualObjectMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final long CallNonvirtualObjectMethodA$offset() {
        return CallNonvirtualObjectMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jobject (*CallNonvirtualObjectMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallNonvirtualObjectMethodA(MemorySegment struct) {
        return struct.get(CallNonvirtualObjectMethodA$LAYOUT, CallNonvirtualObjectMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jobject (*CallNonvirtualObjectMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static void CallNonvirtualObjectMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallNonvirtualObjectMethodA$LAYOUT, CallNonvirtualObjectMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jboolean (*CallNonvirtualBooleanMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static class CallNonvirtualBooleanMethodV {

        CallNonvirtualBooleanMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            byte apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_CHAR,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallNonvirtualBooleanMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallNonvirtualBooleanMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static byte invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (byte) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallNonvirtualBooleanMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallNonvirtualBooleanMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jboolean (*CallNonvirtualBooleanMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallNonvirtualBooleanMethodV$layout() {
        return CallNonvirtualBooleanMethodV$LAYOUT;
    }

    private static final long CallNonvirtualBooleanMethodV$OFFSET = 544;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jboolean (*CallNonvirtualBooleanMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static final long CallNonvirtualBooleanMethodV$offset() {
        return CallNonvirtualBooleanMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jboolean (*CallNonvirtualBooleanMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallNonvirtualBooleanMethodV(MemorySegment struct) {
        return struct.get(CallNonvirtualBooleanMethodV$LAYOUT, CallNonvirtualBooleanMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jboolean (*CallNonvirtualBooleanMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static void CallNonvirtualBooleanMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallNonvirtualBooleanMethodV$LAYOUT, CallNonvirtualBooleanMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jboolean (*CallNonvirtualBooleanMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static class CallNonvirtualBooleanMethodA {

        CallNonvirtualBooleanMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            byte apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_CHAR,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallNonvirtualBooleanMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallNonvirtualBooleanMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static byte invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (byte) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallNonvirtualBooleanMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallNonvirtualBooleanMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jboolean (*CallNonvirtualBooleanMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallNonvirtualBooleanMethodA$layout() {
        return CallNonvirtualBooleanMethodA$LAYOUT;
    }

    private static final long CallNonvirtualBooleanMethodA$OFFSET = 552;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jboolean (*CallNonvirtualBooleanMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final long CallNonvirtualBooleanMethodA$offset() {
        return CallNonvirtualBooleanMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jboolean (*CallNonvirtualBooleanMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallNonvirtualBooleanMethodA(MemorySegment struct) {
        return struct.get(CallNonvirtualBooleanMethodA$LAYOUT, CallNonvirtualBooleanMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jboolean (*CallNonvirtualBooleanMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static void CallNonvirtualBooleanMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallNonvirtualBooleanMethodA$LAYOUT, CallNonvirtualBooleanMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jbyte (*CallNonvirtualByteMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static class CallNonvirtualByteMethodV {

        CallNonvirtualByteMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            byte apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_CHAR,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallNonvirtualByteMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallNonvirtualByteMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static byte invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (byte) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallNonvirtualByteMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallNonvirtualByteMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jbyte (*CallNonvirtualByteMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallNonvirtualByteMethodV$layout() {
        return CallNonvirtualByteMethodV$LAYOUT;
    }

    private static final long CallNonvirtualByteMethodV$OFFSET = 568;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jbyte (*CallNonvirtualByteMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static final long CallNonvirtualByteMethodV$offset() {
        return CallNonvirtualByteMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jbyte (*CallNonvirtualByteMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallNonvirtualByteMethodV(MemorySegment struct) {
        return struct.get(CallNonvirtualByteMethodV$LAYOUT, CallNonvirtualByteMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jbyte (*CallNonvirtualByteMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static void CallNonvirtualByteMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallNonvirtualByteMethodV$LAYOUT, CallNonvirtualByteMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jbyte (*CallNonvirtualByteMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static class CallNonvirtualByteMethodA {

        CallNonvirtualByteMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            byte apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_CHAR,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallNonvirtualByteMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallNonvirtualByteMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static byte invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (byte) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallNonvirtualByteMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallNonvirtualByteMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jbyte (*CallNonvirtualByteMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallNonvirtualByteMethodA$layout() {
        return CallNonvirtualByteMethodA$LAYOUT;
    }

    private static final long CallNonvirtualByteMethodA$OFFSET = 576;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jbyte (*CallNonvirtualByteMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final long CallNonvirtualByteMethodA$offset() {
        return CallNonvirtualByteMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jbyte (*CallNonvirtualByteMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallNonvirtualByteMethodA(MemorySegment struct) {
        return struct.get(CallNonvirtualByteMethodA$LAYOUT, CallNonvirtualByteMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jbyte (*CallNonvirtualByteMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static void CallNonvirtualByteMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallNonvirtualByteMethodA$LAYOUT, CallNonvirtualByteMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jchar (*CallNonvirtualCharMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static class CallNonvirtualCharMethodV {

        CallNonvirtualCharMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            short apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_SHORT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallNonvirtualCharMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallNonvirtualCharMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static short invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (short) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallNonvirtualCharMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallNonvirtualCharMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jchar (*CallNonvirtualCharMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallNonvirtualCharMethodV$layout() {
        return CallNonvirtualCharMethodV$LAYOUT;
    }

    private static final long CallNonvirtualCharMethodV$OFFSET = 592;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jchar (*CallNonvirtualCharMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static final long CallNonvirtualCharMethodV$offset() {
        return CallNonvirtualCharMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jchar (*CallNonvirtualCharMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallNonvirtualCharMethodV(MemorySegment struct) {
        return struct.get(CallNonvirtualCharMethodV$LAYOUT, CallNonvirtualCharMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jchar (*CallNonvirtualCharMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static void CallNonvirtualCharMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallNonvirtualCharMethodV$LAYOUT, CallNonvirtualCharMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jchar (*CallNonvirtualCharMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static class CallNonvirtualCharMethodA {

        CallNonvirtualCharMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            short apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_SHORT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallNonvirtualCharMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallNonvirtualCharMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static short invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (short) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallNonvirtualCharMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallNonvirtualCharMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jchar (*CallNonvirtualCharMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallNonvirtualCharMethodA$layout() {
        return CallNonvirtualCharMethodA$LAYOUT;
    }

    private static final long CallNonvirtualCharMethodA$OFFSET = 600;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jchar (*CallNonvirtualCharMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final long CallNonvirtualCharMethodA$offset() {
        return CallNonvirtualCharMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jchar (*CallNonvirtualCharMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallNonvirtualCharMethodA(MemorySegment struct) {
        return struct.get(CallNonvirtualCharMethodA$LAYOUT, CallNonvirtualCharMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jchar (*CallNonvirtualCharMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static void CallNonvirtualCharMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallNonvirtualCharMethodA$LAYOUT, CallNonvirtualCharMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jshort (*CallNonvirtualShortMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static class CallNonvirtualShortMethodV {

        CallNonvirtualShortMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            short apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_SHORT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallNonvirtualShortMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallNonvirtualShortMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static short invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (short) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallNonvirtualShortMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallNonvirtualShortMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jshort (*CallNonvirtualShortMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallNonvirtualShortMethodV$layout() {
        return CallNonvirtualShortMethodV$LAYOUT;
    }

    private static final long CallNonvirtualShortMethodV$OFFSET = 616;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jshort (*CallNonvirtualShortMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static final long CallNonvirtualShortMethodV$offset() {
        return CallNonvirtualShortMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jshort (*CallNonvirtualShortMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallNonvirtualShortMethodV(MemorySegment struct) {
        return struct.get(CallNonvirtualShortMethodV$LAYOUT, CallNonvirtualShortMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jshort (*CallNonvirtualShortMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static void CallNonvirtualShortMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallNonvirtualShortMethodV$LAYOUT, CallNonvirtualShortMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jshort (*CallNonvirtualShortMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static class CallNonvirtualShortMethodA {

        CallNonvirtualShortMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            short apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_SHORT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallNonvirtualShortMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallNonvirtualShortMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static short invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (short) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallNonvirtualShortMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallNonvirtualShortMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jshort (*CallNonvirtualShortMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallNonvirtualShortMethodA$layout() {
        return CallNonvirtualShortMethodA$LAYOUT;
    }

    private static final long CallNonvirtualShortMethodA$OFFSET = 624;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jshort (*CallNonvirtualShortMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final long CallNonvirtualShortMethodA$offset() {
        return CallNonvirtualShortMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jshort (*CallNonvirtualShortMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallNonvirtualShortMethodA(MemorySegment struct) {
        return struct.get(CallNonvirtualShortMethodA$LAYOUT, CallNonvirtualShortMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jshort (*CallNonvirtualShortMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static void CallNonvirtualShortMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallNonvirtualShortMethodA$LAYOUT, CallNonvirtualShortMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jint (*CallNonvirtualIntMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static class CallNonvirtualIntMethodV {

        CallNonvirtualIntMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallNonvirtualIntMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallNonvirtualIntMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallNonvirtualIntMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallNonvirtualIntMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jint (*CallNonvirtualIntMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallNonvirtualIntMethodV$layout() {
        return CallNonvirtualIntMethodV$LAYOUT;
    }

    private static final long CallNonvirtualIntMethodV$OFFSET = 640;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jint (*CallNonvirtualIntMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static final long CallNonvirtualIntMethodV$offset() {
        return CallNonvirtualIntMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jint (*CallNonvirtualIntMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallNonvirtualIntMethodV(MemorySegment struct) {
        return struct.get(CallNonvirtualIntMethodV$LAYOUT, CallNonvirtualIntMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jint (*CallNonvirtualIntMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static void CallNonvirtualIntMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallNonvirtualIntMethodV$LAYOUT, CallNonvirtualIntMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jint (*CallNonvirtualIntMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static class CallNonvirtualIntMethodA {

        CallNonvirtualIntMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallNonvirtualIntMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallNonvirtualIntMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallNonvirtualIntMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallNonvirtualIntMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jint (*CallNonvirtualIntMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallNonvirtualIntMethodA$layout() {
        return CallNonvirtualIntMethodA$LAYOUT;
    }

    private static final long CallNonvirtualIntMethodA$OFFSET = 648;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jint (*CallNonvirtualIntMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final long CallNonvirtualIntMethodA$offset() {
        return CallNonvirtualIntMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jint (*CallNonvirtualIntMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallNonvirtualIntMethodA(MemorySegment struct) {
        return struct.get(CallNonvirtualIntMethodA$LAYOUT, CallNonvirtualIntMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jint (*CallNonvirtualIntMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static void CallNonvirtualIntMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallNonvirtualIntMethodA$LAYOUT, CallNonvirtualIntMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jlong (*CallNonvirtualLongMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static class CallNonvirtualLongMethodV {

        CallNonvirtualLongMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_LONG,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallNonvirtualLongMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallNonvirtualLongMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallNonvirtualLongMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallNonvirtualLongMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jlong (*CallNonvirtualLongMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallNonvirtualLongMethodV$layout() {
        return CallNonvirtualLongMethodV$LAYOUT;
    }

    private static final long CallNonvirtualLongMethodV$OFFSET = 664;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jlong (*CallNonvirtualLongMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static final long CallNonvirtualLongMethodV$offset() {
        return CallNonvirtualLongMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jlong (*CallNonvirtualLongMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallNonvirtualLongMethodV(MemorySegment struct) {
        return struct.get(CallNonvirtualLongMethodV$LAYOUT, CallNonvirtualLongMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jlong (*CallNonvirtualLongMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static void CallNonvirtualLongMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallNonvirtualLongMethodV$LAYOUT, CallNonvirtualLongMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jlong (*CallNonvirtualLongMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static class CallNonvirtualLongMethodA {

        CallNonvirtualLongMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_LONG,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallNonvirtualLongMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallNonvirtualLongMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallNonvirtualLongMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallNonvirtualLongMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jlong (*CallNonvirtualLongMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallNonvirtualLongMethodA$layout() {
        return CallNonvirtualLongMethodA$LAYOUT;
    }

    private static final long CallNonvirtualLongMethodA$OFFSET = 672;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jlong (*CallNonvirtualLongMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final long CallNonvirtualLongMethodA$offset() {
        return CallNonvirtualLongMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jlong (*CallNonvirtualLongMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallNonvirtualLongMethodA(MemorySegment struct) {
        return struct.get(CallNonvirtualLongMethodA$LAYOUT, CallNonvirtualLongMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jlong (*CallNonvirtualLongMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static void CallNonvirtualLongMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallNonvirtualLongMethodA$LAYOUT, CallNonvirtualLongMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jfloat (*CallNonvirtualFloatMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static class CallNonvirtualFloatMethodV {

        CallNonvirtualFloatMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            float apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_FLOAT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallNonvirtualFloatMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallNonvirtualFloatMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static float invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (float) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallNonvirtualFloatMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallNonvirtualFloatMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jfloat (*CallNonvirtualFloatMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallNonvirtualFloatMethodV$layout() {
        return CallNonvirtualFloatMethodV$LAYOUT;
    }

    private static final long CallNonvirtualFloatMethodV$OFFSET = 688;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jfloat (*CallNonvirtualFloatMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static final long CallNonvirtualFloatMethodV$offset() {
        return CallNonvirtualFloatMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jfloat (*CallNonvirtualFloatMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallNonvirtualFloatMethodV(MemorySegment struct) {
        return struct.get(CallNonvirtualFloatMethodV$LAYOUT, CallNonvirtualFloatMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jfloat (*CallNonvirtualFloatMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static void CallNonvirtualFloatMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallNonvirtualFloatMethodV$LAYOUT, CallNonvirtualFloatMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jfloat (*CallNonvirtualFloatMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static class CallNonvirtualFloatMethodA {

        CallNonvirtualFloatMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            float apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_FLOAT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallNonvirtualFloatMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallNonvirtualFloatMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static float invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (float) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallNonvirtualFloatMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallNonvirtualFloatMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jfloat (*CallNonvirtualFloatMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallNonvirtualFloatMethodA$layout() {
        return CallNonvirtualFloatMethodA$LAYOUT;
    }

    private static final long CallNonvirtualFloatMethodA$OFFSET = 696;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jfloat (*CallNonvirtualFloatMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final long CallNonvirtualFloatMethodA$offset() {
        return CallNonvirtualFloatMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jfloat (*CallNonvirtualFloatMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallNonvirtualFloatMethodA(MemorySegment struct) {
        return struct.get(CallNonvirtualFloatMethodA$LAYOUT, CallNonvirtualFloatMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jfloat (*CallNonvirtualFloatMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static void CallNonvirtualFloatMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallNonvirtualFloatMethodA$LAYOUT, CallNonvirtualFloatMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jdouble (*CallNonvirtualDoubleMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static class CallNonvirtualDoubleMethodV {

        CallNonvirtualDoubleMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            double apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_DOUBLE,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallNonvirtualDoubleMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallNonvirtualDoubleMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static double invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (double) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallNonvirtualDoubleMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallNonvirtualDoubleMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jdouble (*CallNonvirtualDoubleMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallNonvirtualDoubleMethodV$layout() {
        return CallNonvirtualDoubleMethodV$LAYOUT;
    }

    private static final long CallNonvirtualDoubleMethodV$OFFSET = 712;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jdouble (*CallNonvirtualDoubleMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static final long CallNonvirtualDoubleMethodV$offset() {
        return CallNonvirtualDoubleMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jdouble (*CallNonvirtualDoubleMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallNonvirtualDoubleMethodV(MemorySegment struct) {
        return struct.get(CallNonvirtualDoubleMethodV$LAYOUT, CallNonvirtualDoubleMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jdouble (*CallNonvirtualDoubleMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static void CallNonvirtualDoubleMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallNonvirtualDoubleMethodV$LAYOUT, CallNonvirtualDoubleMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jdouble (*CallNonvirtualDoubleMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static class CallNonvirtualDoubleMethodA {

        CallNonvirtualDoubleMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            double apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_DOUBLE,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallNonvirtualDoubleMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallNonvirtualDoubleMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static double invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (double) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallNonvirtualDoubleMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallNonvirtualDoubleMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jdouble (*CallNonvirtualDoubleMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallNonvirtualDoubleMethodA$layout() {
        return CallNonvirtualDoubleMethodA$LAYOUT;
    }

    private static final long CallNonvirtualDoubleMethodA$OFFSET = 720;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jdouble (*CallNonvirtualDoubleMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final long CallNonvirtualDoubleMethodA$offset() {
        return CallNonvirtualDoubleMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jdouble (*CallNonvirtualDoubleMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallNonvirtualDoubleMethodA(MemorySegment struct) {
        return struct.get(CallNonvirtualDoubleMethodA$LAYOUT, CallNonvirtualDoubleMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jdouble (*CallNonvirtualDoubleMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static void CallNonvirtualDoubleMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallNonvirtualDoubleMethodA$LAYOUT, CallNonvirtualDoubleMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*CallNonvirtualVoidMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static class CallNonvirtualVoidMethodV {

        CallNonvirtualVoidMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallNonvirtualVoidMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallNonvirtualVoidMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallNonvirtualVoidMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallNonvirtualVoidMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*CallNonvirtualVoidMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallNonvirtualVoidMethodV$layout() {
        return CallNonvirtualVoidMethodV$LAYOUT;
    }

    private static final long CallNonvirtualVoidMethodV$OFFSET = 736;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*CallNonvirtualVoidMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static final long CallNonvirtualVoidMethodV$offset() {
        return CallNonvirtualVoidMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*CallNonvirtualVoidMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallNonvirtualVoidMethodV(MemorySegment struct) {
        return struct.get(CallNonvirtualVoidMethodV$LAYOUT, CallNonvirtualVoidMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*CallNonvirtualVoidMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list)
     * }
     */
    public static void CallNonvirtualVoidMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallNonvirtualVoidMethodV$LAYOUT, CallNonvirtualVoidMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*CallNonvirtualVoidMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static class CallNonvirtualVoidMethodA {

        CallNonvirtualVoidMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallNonvirtualVoidMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallNonvirtualVoidMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallNonvirtualVoidMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallNonvirtualVoidMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*CallNonvirtualVoidMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallNonvirtualVoidMethodA$layout() {
        return CallNonvirtualVoidMethodA$LAYOUT;
    }

    private static final long CallNonvirtualVoidMethodA$OFFSET = 744;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*CallNonvirtualVoidMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final long CallNonvirtualVoidMethodA$offset() {
        return CallNonvirtualVoidMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*CallNonvirtualVoidMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallNonvirtualVoidMethodA(MemorySegment struct) {
        return struct.get(CallNonvirtualVoidMethodA$LAYOUT, CallNonvirtualVoidMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*CallNonvirtualVoidMethodA)(JNIEnv *, jobject, jclass, jmethodID, const jvalue *)
     * }
     */
    public static void CallNonvirtualVoidMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallNonvirtualVoidMethodA$LAYOUT, CallNonvirtualVoidMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jfieldID (*GetFieldID)(JNIEnv *, jclass, const char *, const char *)
     * }
     */
    public static class GetFieldID {

        GetFieldID() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetFieldID.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetFieldID.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetFieldID$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetFieldID"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jfieldID (*GetFieldID)(JNIEnv *, jclass, const char *, const char *)
     * }
     */
    public static final AddressLayout GetFieldID$layout() {
        return GetFieldID$LAYOUT;
    }

    private static final long GetFieldID$OFFSET = 752;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jfieldID (*GetFieldID)(JNIEnv *, jclass, const char *, const char *)
     * }
     */
    public static final long GetFieldID$offset() {
        return GetFieldID$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jfieldID (*GetFieldID)(JNIEnv *, jclass, const char *, const char *)
     * }
     */
    public static MemorySegment GetFieldID(MemorySegment struct) {
        return struct.get(GetFieldID$LAYOUT, GetFieldID$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jfieldID (*GetFieldID)(JNIEnv *, jclass, const char *, const char *)
     * }
     */
    public static void GetFieldID(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetFieldID$LAYOUT, GetFieldID$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jobject (*GetObjectField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static class GetObjectField {

        GetObjectField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetObjectField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetObjectField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetObjectField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetObjectField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jobject (*GetObjectField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static final AddressLayout GetObjectField$layout() {
        return GetObjectField$LAYOUT;
    }

    private static final long GetObjectField$OFFSET = 760;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jobject (*GetObjectField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static final long GetObjectField$offset() {
        return GetObjectField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jobject (*GetObjectField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static MemorySegment GetObjectField(MemorySegment struct) {
        return struct.get(GetObjectField$LAYOUT, GetObjectField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jobject (*GetObjectField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static void GetObjectField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetObjectField$LAYOUT, GetObjectField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jboolean (*GetBooleanField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static class GetBooleanField {

        GetBooleanField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            byte apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_CHAR,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetBooleanField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetBooleanField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static byte invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (byte) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetBooleanField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetBooleanField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jboolean (*GetBooleanField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static final AddressLayout GetBooleanField$layout() {
        return GetBooleanField$LAYOUT;
    }

    private static final long GetBooleanField$OFFSET = 768;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jboolean (*GetBooleanField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static final long GetBooleanField$offset() {
        return GetBooleanField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jboolean (*GetBooleanField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static MemorySegment GetBooleanField(MemorySegment struct) {
        return struct.get(GetBooleanField$LAYOUT, GetBooleanField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jboolean (*GetBooleanField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static void GetBooleanField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetBooleanField$LAYOUT, GetBooleanField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jbyte (*GetByteField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static class GetByteField {

        GetByteField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            byte apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_CHAR,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetByteField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetByteField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static byte invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (byte) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetByteField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetByteField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jbyte (*GetByteField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static final AddressLayout GetByteField$layout() {
        return GetByteField$LAYOUT;
    }

    private static final long GetByteField$OFFSET = 776;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jbyte (*GetByteField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static final long GetByteField$offset() {
        return GetByteField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jbyte (*GetByteField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static MemorySegment GetByteField(MemorySegment struct) {
        return struct.get(GetByteField$LAYOUT, GetByteField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jbyte (*GetByteField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static void GetByteField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetByteField$LAYOUT, GetByteField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jchar (*GetCharField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static class GetCharField {

        GetCharField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            short apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_SHORT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetCharField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetCharField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static short invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (short) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetCharField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetCharField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jchar (*GetCharField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static final AddressLayout GetCharField$layout() {
        return GetCharField$LAYOUT;
    }

    private static final long GetCharField$OFFSET = 784;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jchar (*GetCharField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static final long GetCharField$offset() {
        return GetCharField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jchar (*GetCharField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static MemorySegment GetCharField(MemorySegment struct) {
        return struct.get(GetCharField$LAYOUT, GetCharField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jchar (*GetCharField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static void GetCharField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetCharField$LAYOUT, GetCharField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jshort (*GetShortField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static class GetShortField {

        GetShortField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            short apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_SHORT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetShortField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetShortField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static short invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (short) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetShortField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetShortField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jshort (*GetShortField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static final AddressLayout GetShortField$layout() {
        return GetShortField$LAYOUT;
    }

    private static final long GetShortField$OFFSET = 792;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jshort (*GetShortField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static final long GetShortField$offset() {
        return GetShortField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jshort (*GetShortField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static MemorySegment GetShortField(MemorySegment struct) {
        return struct.get(GetShortField$LAYOUT, GetShortField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jshort (*GetShortField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static void GetShortField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetShortField$LAYOUT, GetShortField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jint (*GetIntField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static class GetIntField {

        GetIntField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetIntField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetIntField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetIntField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetIntField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jint (*GetIntField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static final AddressLayout GetIntField$layout() {
        return GetIntField$LAYOUT;
    }

    private static final long GetIntField$OFFSET = 800;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jint (*GetIntField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static final long GetIntField$offset() {
        return GetIntField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jint (*GetIntField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static MemorySegment GetIntField(MemorySegment struct) {
        return struct.get(GetIntField$LAYOUT, GetIntField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jint (*GetIntField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static void GetIntField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetIntField$LAYOUT, GetIntField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jlong (*GetLongField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static class GetLongField {

        GetLongField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_LONG,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetLongField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetLongField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetLongField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetLongField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jlong (*GetLongField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static final AddressLayout GetLongField$layout() {
        return GetLongField$LAYOUT;
    }

    private static final long GetLongField$OFFSET = 808;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jlong (*GetLongField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static final long GetLongField$offset() {
        return GetLongField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jlong (*GetLongField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static MemorySegment GetLongField(MemorySegment struct) {
        return struct.get(GetLongField$LAYOUT, GetLongField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jlong (*GetLongField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static void GetLongField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetLongField$LAYOUT, GetLongField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jfloat (*GetFloatField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static class GetFloatField {

        GetFloatField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            float apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_FLOAT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetFloatField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetFloatField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static float invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (float) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetFloatField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetFloatField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jfloat (*GetFloatField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static final AddressLayout GetFloatField$layout() {
        return GetFloatField$LAYOUT;
    }

    private static final long GetFloatField$OFFSET = 816;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jfloat (*GetFloatField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static final long GetFloatField$offset() {
        return GetFloatField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jfloat (*GetFloatField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static MemorySegment GetFloatField(MemorySegment struct) {
        return struct.get(GetFloatField$LAYOUT, GetFloatField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jfloat (*GetFloatField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static void GetFloatField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetFloatField$LAYOUT, GetFloatField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jdouble (*GetDoubleField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static class GetDoubleField {

        GetDoubleField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            double apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_DOUBLE,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetDoubleField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetDoubleField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static double invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (double) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetDoubleField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetDoubleField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jdouble (*GetDoubleField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static final AddressLayout GetDoubleField$layout() {
        return GetDoubleField$LAYOUT;
    }

    private static final long GetDoubleField$OFFSET = 824;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jdouble (*GetDoubleField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static final long GetDoubleField$offset() {
        return GetDoubleField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jdouble (*GetDoubleField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static MemorySegment GetDoubleField(MemorySegment struct) {
        return struct.get(GetDoubleField$LAYOUT, GetDoubleField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jdouble (*GetDoubleField)(JNIEnv *, jobject, jfieldID)
     * }
     */
    public static void GetDoubleField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetDoubleField$LAYOUT, GetDoubleField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetObjectField)(JNIEnv *, jobject, jfieldID, jobject)
     * }
     */
    public static class SetObjectField {

        SetObjectField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetObjectField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetObjectField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetObjectField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetObjectField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetObjectField)(JNIEnv *, jobject, jfieldID, jobject)
     * }
     */
    public static final AddressLayout SetObjectField$layout() {
        return SetObjectField$LAYOUT;
    }

    private static final long SetObjectField$OFFSET = 832;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetObjectField)(JNIEnv *, jobject, jfieldID, jobject)
     * }
     */
    public static final long SetObjectField$offset() {
        return SetObjectField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetObjectField)(JNIEnv *, jobject, jfieldID, jobject)
     * }
     */
    public static MemorySegment SetObjectField(MemorySegment struct) {
        return struct.get(SetObjectField$LAYOUT, SetObjectField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetObjectField)(JNIEnv *, jobject, jfieldID, jobject)
     * }
     */
    public static void SetObjectField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetObjectField$LAYOUT, SetObjectField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetBooleanField)(JNIEnv *, jobject, jfieldID, jboolean)
     * }
     */
    public static class SetBooleanField {

        SetBooleanField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, byte _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_CHAR
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetBooleanField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetBooleanField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, byte _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetBooleanField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetBooleanField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetBooleanField)(JNIEnv *, jobject, jfieldID, jboolean)
     * }
     */
    public static final AddressLayout SetBooleanField$layout() {
        return SetBooleanField$LAYOUT;
    }

    private static final long SetBooleanField$OFFSET = 840;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetBooleanField)(JNIEnv *, jobject, jfieldID, jboolean)
     * }
     */
    public static final long SetBooleanField$offset() {
        return SetBooleanField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetBooleanField)(JNIEnv *, jobject, jfieldID, jboolean)
     * }
     */
    public static MemorySegment SetBooleanField(MemorySegment struct) {
        return struct.get(SetBooleanField$LAYOUT, SetBooleanField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetBooleanField)(JNIEnv *, jobject, jfieldID, jboolean)
     * }
     */
    public static void SetBooleanField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetBooleanField$LAYOUT, SetBooleanField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetByteField)(JNIEnv *, jobject, jfieldID, jbyte)
     * }
     */
    public static class SetByteField {

        SetByteField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, byte _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_CHAR
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetByteField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetByteField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, byte _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetByteField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetByteField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetByteField)(JNIEnv *, jobject, jfieldID, jbyte)
     * }
     */
    public static final AddressLayout SetByteField$layout() {
        return SetByteField$LAYOUT;
    }

    private static final long SetByteField$OFFSET = 848;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetByteField)(JNIEnv *, jobject, jfieldID, jbyte)
     * }
     */
    public static final long SetByteField$offset() {
        return SetByteField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetByteField)(JNIEnv *, jobject, jfieldID, jbyte)
     * }
     */
    public static MemorySegment SetByteField(MemorySegment struct) {
        return struct.get(SetByteField$LAYOUT, SetByteField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetByteField)(JNIEnv *, jobject, jfieldID, jbyte)
     * }
     */
    public static void SetByteField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetByteField$LAYOUT, SetByteField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetCharField)(JNIEnv *, jobject, jfieldID, jchar)
     * }
     */
    public static class SetCharField {

        SetCharField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, short _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_SHORT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetCharField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetCharField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, short _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetCharField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetCharField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetCharField)(JNIEnv *, jobject, jfieldID, jchar)
     * }
     */
    public static final AddressLayout SetCharField$layout() {
        return SetCharField$LAYOUT;
    }

    private static final long SetCharField$OFFSET = 856;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetCharField)(JNIEnv *, jobject, jfieldID, jchar)
     * }
     */
    public static final long SetCharField$offset() {
        return SetCharField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetCharField)(JNIEnv *, jobject, jfieldID, jchar)
     * }
     */
    public static MemorySegment SetCharField(MemorySegment struct) {
        return struct.get(SetCharField$LAYOUT, SetCharField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetCharField)(JNIEnv *, jobject, jfieldID, jchar)
     * }
     */
    public static void SetCharField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetCharField$LAYOUT, SetCharField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetShortField)(JNIEnv *, jobject, jfieldID, jshort)
     * }
     */
    public static class SetShortField {

        SetShortField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, short _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_SHORT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetShortField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetShortField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, short _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetShortField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetShortField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetShortField)(JNIEnv *, jobject, jfieldID, jshort)
     * }
     */
    public static final AddressLayout SetShortField$layout() {
        return SetShortField$LAYOUT;
    }

    private static final long SetShortField$OFFSET = 864;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetShortField)(JNIEnv *, jobject, jfieldID, jshort)
     * }
     */
    public static final long SetShortField$offset() {
        return SetShortField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetShortField)(JNIEnv *, jobject, jfieldID, jshort)
     * }
     */
    public static MemorySegment SetShortField(MemorySegment struct) {
        return struct.get(SetShortField$LAYOUT, SetShortField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetShortField)(JNIEnv *, jobject, jfieldID, jshort)
     * }
     */
    public static void SetShortField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetShortField$LAYOUT, SetShortField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetIntField)(JNIEnv *, jobject, jfieldID, jint)
     * }
     */
    public static class SetIntField {

        SetIntField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetIntField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetIntField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetIntField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetIntField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetIntField)(JNIEnv *, jobject, jfieldID, jint)
     * }
     */
    public static final AddressLayout SetIntField$layout() {
        return SetIntField$LAYOUT;
    }

    private static final long SetIntField$OFFSET = 872;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetIntField)(JNIEnv *, jobject, jfieldID, jint)
     * }
     */
    public static final long SetIntField$offset() {
        return SetIntField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetIntField)(JNIEnv *, jobject, jfieldID, jint)
     * }
     */
    public static MemorySegment SetIntField(MemorySegment struct) {
        return struct.get(SetIntField$LAYOUT, SetIntField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetIntField)(JNIEnv *, jobject, jfieldID, jint)
     * }
     */
    public static void SetIntField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetIntField$LAYOUT, SetIntField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetLongField)(JNIEnv *, jobject, jfieldID, jlong)
     * }
     */
    public static class SetLongField {

        SetLongField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetLongField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetLongField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetLongField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetLongField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetLongField)(JNIEnv *, jobject, jfieldID, jlong)
     * }
     */
    public static final AddressLayout SetLongField$layout() {
        return SetLongField$LAYOUT;
    }

    private static final long SetLongField$OFFSET = 880;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetLongField)(JNIEnv *, jobject, jfieldID, jlong)
     * }
     */
    public static final long SetLongField$offset() {
        return SetLongField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetLongField)(JNIEnv *, jobject, jfieldID, jlong)
     * }
     */
    public static MemorySegment SetLongField(MemorySegment struct) {
        return struct.get(SetLongField$LAYOUT, SetLongField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetLongField)(JNIEnv *, jobject, jfieldID, jlong)
     * }
     */
    public static void SetLongField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetLongField$LAYOUT, SetLongField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetFloatField)(JNIEnv *, jobject, jfieldID, jfloat)
     * }
     */
    public static class SetFloatField {

        SetFloatField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, float _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_FLOAT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetFloatField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetFloatField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, float _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetFloatField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetFloatField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetFloatField)(JNIEnv *, jobject, jfieldID, jfloat)
     * }
     */
    public static final AddressLayout SetFloatField$layout() {
        return SetFloatField$LAYOUT;
    }

    private static final long SetFloatField$OFFSET = 888;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetFloatField)(JNIEnv *, jobject, jfieldID, jfloat)
     * }
     */
    public static final long SetFloatField$offset() {
        return SetFloatField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetFloatField)(JNIEnv *, jobject, jfieldID, jfloat)
     * }
     */
    public static MemorySegment SetFloatField(MemorySegment struct) {
        return struct.get(SetFloatField$LAYOUT, SetFloatField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetFloatField)(JNIEnv *, jobject, jfieldID, jfloat)
     * }
     */
    public static void SetFloatField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetFloatField$LAYOUT, SetFloatField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetDoubleField)(JNIEnv *, jobject, jfieldID, jdouble)
     * }
     */
    public static class SetDoubleField {

        SetDoubleField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, double _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_DOUBLE
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetDoubleField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetDoubleField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, double _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetDoubleField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetDoubleField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetDoubleField)(JNIEnv *, jobject, jfieldID, jdouble)
     * }
     */
    public static final AddressLayout SetDoubleField$layout() {
        return SetDoubleField$LAYOUT;
    }

    private static final long SetDoubleField$OFFSET = 896;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetDoubleField)(JNIEnv *, jobject, jfieldID, jdouble)
     * }
     */
    public static final long SetDoubleField$offset() {
        return SetDoubleField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetDoubleField)(JNIEnv *, jobject, jfieldID, jdouble)
     * }
     */
    public static MemorySegment SetDoubleField(MemorySegment struct) {
        return struct.get(SetDoubleField$LAYOUT, SetDoubleField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetDoubleField)(JNIEnv *, jobject, jfieldID, jdouble)
     * }
     */
    public static void SetDoubleField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetDoubleField$LAYOUT, SetDoubleField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jmethodID (*GetStaticMethodID)(JNIEnv *, jclass, const char *, const char *)
     * }
     */
    public static class GetStaticMethodID {

        GetStaticMethodID() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetStaticMethodID.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStaticMethodID.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStaticMethodID$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStaticMethodID"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jmethodID (*GetStaticMethodID)(JNIEnv *, jclass, const char *, const char *)
     * }
     */
    public static final AddressLayout GetStaticMethodID$layout() {
        return GetStaticMethodID$LAYOUT;
    }

    private static final long GetStaticMethodID$OFFSET = 904;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jmethodID (*GetStaticMethodID)(JNIEnv *, jclass, const char *, const char *)
     * }
     */
    public static final long GetStaticMethodID$offset() {
        return GetStaticMethodID$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jmethodID (*GetStaticMethodID)(JNIEnv *, jclass, const char *, const char *)
     * }
     */
    public static MemorySegment GetStaticMethodID(MemorySegment struct) {
        return struct.get(GetStaticMethodID$LAYOUT, GetStaticMethodID$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jmethodID (*GetStaticMethodID)(JNIEnv *, jclass, const char *, const char *)
     * }
     */
    public static void GetStaticMethodID(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStaticMethodID$LAYOUT, GetStaticMethodID$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jobject (*CallStaticObjectMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static class CallStaticObjectMethodV {

        CallStaticObjectMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallStaticObjectMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallStaticObjectMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallStaticObjectMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallStaticObjectMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jobject (*CallStaticObjectMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallStaticObjectMethodV$layout() {
        return CallStaticObjectMethodV$LAYOUT;
    }

    private static final long CallStaticObjectMethodV$OFFSET = 920;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jobject (*CallStaticObjectMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static final long CallStaticObjectMethodV$offset() {
        return CallStaticObjectMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jobject (*CallStaticObjectMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallStaticObjectMethodV(MemorySegment struct) {
        return struct.get(CallStaticObjectMethodV$LAYOUT, CallStaticObjectMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jobject (*CallStaticObjectMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static void CallStaticObjectMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallStaticObjectMethodV$LAYOUT, CallStaticObjectMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jobject (*CallStaticObjectMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static class CallStaticObjectMethodA {

        CallStaticObjectMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallStaticObjectMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallStaticObjectMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallStaticObjectMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallStaticObjectMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jobject (*CallStaticObjectMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallStaticObjectMethodA$layout() {
        return CallStaticObjectMethodA$LAYOUT;
    }

    private static final long CallStaticObjectMethodA$OFFSET = 928;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jobject (*CallStaticObjectMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final long CallStaticObjectMethodA$offset() {
        return CallStaticObjectMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jobject (*CallStaticObjectMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallStaticObjectMethodA(MemorySegment struct) {
        return struct.get(CallStaticObjectMethodA$LAYOUT, CallStaticObjectMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jobject (*CallStaticObjectMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static void CallStaticObjectMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallStaticObjectMethodA$LAYOUT, CallStaticObjectMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jboolean (*CallStaticBooleanMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static class CallStaticBooleanMethodV {

        CallStaticBooleanMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            byte apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_CHAR,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallStaticBooleanMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallStaticBooleanMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static byte invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (byte) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallStaticBooleanMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallStaticBooleanMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jboolean (*CallStaticBooleanMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallStaticBooleanMethodV$layout() {
        return CallStaticBooleanMethodV$LAYOUT;
    }

    private static final long CallStaticBooleanMethodV$OFFSET = 944;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jboolean (*CallStaticBooleanMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static final long CallStaticBooleanMethodV$offset() {
        return CallStaticBooleanMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jboolean (*CallStaticBooleanMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallStaticBooleanMethodV(MemorySegment struct) {
        return struct.get(CallStaticBooleanMethodV$LAYOUT, CallStaticBooleanMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jboolean (*CallStaticBooleanMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static void CallStaticBooleanMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallStaticBooleanMethodV$LAYOUT, CallStaticBooleanMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jboolean (*CallStaticBooleanMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static class CallStaticBooleanMethodA {

        CallStaticBooleanMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            byte apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_CHAR,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallStaticBooleanMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallStaticBooleanMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static byte invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (byte) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallStaticBooleanMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallStaticBooleanMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jboolean (*CallStaticBooleanMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallStaticBooleanMethodA$layout() {
        return CallStaticBooleanMethodA$LAYOUT;
    }

    private static final long CallStaticBooleanMethodA$OFFSET = 952;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jboolean (*CallStaticBooleanMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final long CallStaticBooleanMethodA$offset() {
        return CallStaticBooleanMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jboolean (*CallStaticBooleanMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallStaticBooleanMethodA(MemorySegment struct) {
        return struct.get(CallStaticBooleanMethodA$LAYOUT, CallStaticBooleanMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jboolean (*CallStaticBooleanMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static void CallStaticBooleanMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallStaticBooleanMethodA$LAYOUT, CallStaticBooleanMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jbyte (*CallStaticByteMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static class CallStaticByteMethodV {

        CallStaticByteMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            byte apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_CHAR,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallStaticByteMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallStaticByteMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static byte invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (byte) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallStaticByteMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallStaticByteMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jbyte (*CallStaticByteMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallStaticByteMethodV$layout() {
        return CallStaticByteMethodV$LAYOUT;
    }

    private static final long CallStaticByteMethodV$OFFSET = 968;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jbyte (*CallStaticByteMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static final long CallStaticByteMethodV$offset() {
        return CallStaticByteMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jbyte (*CallStaticByteMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallStaticByteMethodV(MemorySegment struct) {
        return struct.get(CallStaticByteMethodV$LAYOUT, CallStaticByteMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jbyte (*CallStaticByteMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static void CallStaticByteMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallStaticByteMethodV$LAYOUT, CallStaticByteMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jbyte (*CallStaticByteMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static class CallStaticByteMethodA {

        CallStaticByteMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            byte apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_CHAR,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallStaticByteMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallStaticByteMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static byte invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (byte) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallStaticByteMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallStaticByteMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jbyte (*CallStaticByteMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallStaticByteMethodA$layout() {
        return CallStaticByteMethodA$LAYOUT;
    }

    private static final long CallStaticByteMethodA$OFFSET = 976;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jbyte (*CallStaticByteMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final long CallStaticByteMethodA$offset() {
        return CallStaticByteMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jbyte (*CallStaticByteMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallStaticByteMethodA(MemorySegment struct) {
        return struct.get(CallStaticByteMethodA$LAYOUT, CallStaticByteMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jbyte (*CallStaticByteMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static void CallStaticByteMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallStaticByteMethodA$LAYOUT, CallStaticByteMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jchar (*CallStaticCharMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static class CallStaticCharMethodV {

        CallStaticCharMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            short apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_SHORT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallStaticCharMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallStaticCharMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static short invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (short) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallStaticCharMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallStaticCharMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jchar (*CallStaticCharMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallStaticCharMethodV$layout() {
        return CallStaticCharMethodV$LAYOUT;
    }

    private static final long CallStaticCharMethodV$OFFSET = 992;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jchar (*CallStaticCharMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static final long CallStaticCharMethodV$offset() {
        return CallStaticCharMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jchar (*CallStaticCharMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallStaticCharMethodV(MemorySegment struct) {
        return struct.get(CallStaticCharMethodV$LAYOUT, CallStaticCharMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jchar (*CallStaticCharMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static void CallStaticCharMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallStaticCharMethodV$LAYOUT, CallStaticCharMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jchar (*CallStaticCharMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static class CallStaticCharMethodA {

        CallStaticCharMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            short apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_SHORT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallStaticCharMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallStaticCharMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static short invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (short) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallStaticCharMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallStaticCharMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jchar (*CallStaticCharMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallStaticCharMethodA$layout() {
        return CallStaticCharMethodA$LAYOUT;
    }

    private static final long CallStaticCharMethodA$OFFSET = 1000;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jchar (*CallStaticCharMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final long CallStaticCharMethodA$offset() {
        return CallStaticCharMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jchar (*CallStaticCharMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallStaticCharMethodA(MemorySegment struct) {
        return struct.get(CallStaticCharMethodA$LAYOUT, CallStaticCharMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jchar (*CallStaticCharMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static void CallStaticCharMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallStaticCharMethodA$LAYOUT, CallStaticCharMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jshort (*CallStaticShortMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static class CallStaticShortMethodV {

        CallStaticShortMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            short apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_SHORT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallStaticShortMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallStaticShortMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static short invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (short) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallStaticShortMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallStaticShortMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jshort (*CallStaticShortMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallStaticShortMethodV$layout() {
        return CallStaticShortMethodV$LAYOUT;
    }

    private static final long CallStaticShortMethodV$OFFSET = 1016;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jshort (*CallStaticShortMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static final long CallStaticShortMethodV$offset() {
        return CallStaticShortMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jshort (*CallStaticShortMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallStaticShortMethodV(MemorySegment struct) {
        return struct.get(CallStaticShortMethodV$LAYOUT, CallStaticShortMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jshort (*CallStaticShortMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static void CallStaticShortMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallStaticShortMethodV$LAYOUT, CallStaticShortMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jshort (*CallStaticShortMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static class CallStaticShortMethodA {

        CallStaticShortMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            short apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_SHORT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallStaticShortMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallStaticShortMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static short invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (short) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallStaticShortMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallStaticShortMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jshort (*CallStaticShortMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallStaticShortMethodA$layout() {
        return CallStaticShortMethodA$LAYOUT;
    }

    private static final long CallStaticShortMethodA$OFFSET = 1024;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jshort (*CallStaticShortMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final long CallStaticShortMethodA$offset() {
        return CallStaticShortMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jshort (*CallStaticShortMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallStaticShortMethodA(MemorySegment struct) {
        return struct.get(CallStaticShortMethodA$LAYOUT, CallStaticShortMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jshort (*CallStaticShortMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static void CallStaticShortMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallStaticShortMethodA$LAYOUT, CallStaticShortMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jint (*CallStaticIntMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static class CallStaticIntMethodV {

        CallStaticIntMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallStaticIntMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallStaticIntMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallStaticIntMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallStaticIntMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jint (*CallStaticIntMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallStaticIntMethodV$layout() {
        return CallStaticIntMethodV$LAYOUT;
    }

    private static final long CallStaticIntMethodV$OFFSET = 1040;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jint (*CallStaticIntMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static final long CallStaticIntMethodV$offset() {
        return CallStaticIntMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jint (*CallStaticIntMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallStaticIntMethodV(MemorySegment struct) {
        return struct.get(CallStaticIntMethodV$LAYOUT, CallStaticIntMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jint (*CallStaticIntMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static void CallStaticIntMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallStaticIntMethodV$LAYOUT, CallStaticIntMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jint (*CallStaticIntMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static class CallStaticIntMethodA {

        CallStaticIntMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallStaticIntMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallStaticIntMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallStaticIntMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallStaticIntMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jint (*CallStaticIntMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallStaticIntMethodA$layout() {
        return CallStaticIntMethodA$LAYOUT;
    }

    private static final long CallStaticIntMethodA$OFFSET = 1048;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jint (*CallStaticIntMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final long CallStaticIntMethodA$offset() {
        return CallStaticIntMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jint (*CallStaticIntMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallStaticIntMethodA(MemorySegment struct) {
        return struct.get(CallStaticIntMethodA$LAYOUT, CallStaticIntMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jint (*CallStaticIntMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static void CallStaticIntMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallStaticIntMethodA$LAYOUT, CallStaticIntMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jlong (*CallStaticLongMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static class CallStaticLongMethodV {

        CallStaticLongMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_LONG,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallStaticLongMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallStaticLongMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallStaticLongMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallStaticLongMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jlong (*CallStaticLongMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallStaticLongMethodV$layout() {
        return CallStaticLongMethodV$LAYOUT;
    }

    private static final long CallStaticLongMethodV$OFFSET = 1064;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jlong (*CallStaticLongMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static final long CallStaticLongMethodV$offset() {
        return CallStaticLongMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jlong (*CallStaticLongMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallStaticLongMethodV(MemorySegment struct) {
        return struct.get(CallStaticLongMethodV$LAYOUT, CallStaticLongMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jlong (*CallStaticLongMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static void CallStaticLongMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallStaticLongMethodV$LAYOUT, CallStaticLongMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jlong (*CallStaticLongMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static class CallStaticLongMethodA {

        CallStaticLongMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_LONG,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallStaticLongMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallStaticLongMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallStaticLongMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallStaticLongMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jlong (*CallStaticLongMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallStaticLongMethodA$layout() {
        return CallStaticLongMethodA$LAYOUT;
    }

    private static final long CallStaticLongMethodA$OFFSET = 1072;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jlong (*CallStaticLongMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final long CallStaticLongMethodA$offset() {
        return CallStaticLongMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jlong (*CallStaticLongMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallStaticLongMethodA(MemorySegment struct) {
        return struct.get(CallStaticLongMethodA$LAYOUT, CallStaticLongMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jlong (*CallStaticLongMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static void CallStaticLongMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallStaticLongMethodA$LAYOUT, CallStaticLongMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jfloat (*CallStaticFloatMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static class CallStaticFloatMethodV {

        CallStaticFloatMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            float apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_FLOAT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallStaticFloatMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallStaticFloatMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static float invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (float) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallStaticFloatMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallStaticFloatMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jfloat (*CallStaticFloatMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallStaticFloatMethodV$layout() {
        return CallStaticFloatMethodV$LAYOUT;
    }

    private static final long CallStaticFloatMethodV$OFFSET = 1088;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jfloat (*CallStaticFloatMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static final long CallStaticFloatMethodV$offset() {
        return CallStaticFloatMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jfloat (*CallStaticFloatMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallStaticFloatMethodV(MemorySegment struct) {
        return struct.get(CallStaticFloatMethodV$LAYOUT, CallStaticFloatMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jfloat (*CallStaticFloatMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static void CallStaticFloatMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallStaticFloatMethodV$LAYOUT, CallStaticFloatMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jfloat (*CallStaticFloatMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static class CallStaticFloatMethodA {

        CallStaticFloatMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            float apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_FLOAT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallStaticFloatMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallStaticFloatMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static float invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (float) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallStaticFloatMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallStaticFloatMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jfloat (*CallStaticFloatMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallStaticFloatMethodA$layout() {
        return CallStaticFloatMethodA$LAYOUT;
    }

    private static final long CallStaticFloatMethodA$OFFSET = 1096;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jfloat (*CallStaticFloatMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final long CallStaticFloatMethodA$offset() {
        return CallStaticFloatMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jfloat (*CallStaticFloatMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallStaticFloatMethodA(MemorySegment struct) {
        return struct.get(CallStaticFloatMethodA$LAYOUT, CallStaticFloatMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jfloat (*CallStaticFloatMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static void CallStaticFloatMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallStaticFloatMethodA$LAYOUT, CallStaticFloatMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jdouble (*CallStaticDoubleMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static class CallStaticDoubleMethodV {

        CallStaticDoubleMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            double apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_DOUBLE,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallStaticDoubleMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallStaticDoubleMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static double invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (double) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallStaticDoubleMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallStaticDoubleMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jdouble (*CallStaticDoubleMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallStaticDoubleMethodV$layout() {
        return CallStaticDoubleMethodV$LAYOUT;
    }

    private static final long CallStaticDoubleMethodV$OFFSET = 1112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jdouble (*CallStaticDoubleMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static final long CallStaticDoubleMethodV$offset() {
        return CallStaticDoubleMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jdouble (*CallStaticDoubleMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallStaticDoubleMethodV(MemorySegment struct) {
        return struct.get(CallStaticDoubleMethodV$LAYOUT, CallStaticDoubleMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jdouble (*CallStaticDoubleMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static void CallStaticDoubleMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallStaticDoubleMethodV$LAYOUT, CallStaticDoubleMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jdouble (*CallStaticDoubleMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static class CallStaticDoubleMethodA {

        CallStaticDoubleMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            double apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_DOUBLE,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallStaticDoubleMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallStaticDoubleMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static double invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (double) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallStaticDoubleMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallStaticDoubleMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jdouble (*CallStaticDoubleMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallStaticDoubleMethodA$layout() {
        return CallStaticDoubleMethodA$LAYOUT;
    }

    private static final long CallStaticDoubleMethodA$OFFSET = 1120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jdouble (*CallStaticDoubleMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final long CallStaticDoubleMethodA$offset() {
        return CallStaticDoubleMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jdouble (*CallStaticDoubleMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallStaticDoubleMethodA(MemorySegment struct) {
        return struct.get(CallStaticDoubleMethodA$LAYOUT, CallStaticDoubleMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jdouble (*CallStaticDoubleMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static void CallStaticDoubleMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallStaticDoubleMethodA$LAYOUT, CallStaticDoubleMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*CallStaticVoidMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static class CallStaticVoidMethodV {

        CallStaticVoidMethodV() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallStaticVoidMethodV.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallStaticVoidMethodV.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallStaticVoidMethodV$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallStaticVoidMethodV"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*CallStaticVoidMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static final AddressLayout CallStaticVoidMethodV$layout() {
        return CallStaticVoidMethodV$LAYOUT;
    }

    private static final long CallStaticVoidMethodV$OFFSET = 1136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*CallStaticVoidMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static final long CallStaticVoidMethodV$offset() {
        return CallStaticVoidMethodV$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*CallStaticVoidMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static MemorySegment CallStaticVoidMethodV(MemorySegment struct) {
        return struct.get(CallStaticVoidMethodV$LAYOUT, CallStaticVoidMethodV$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*CallStaticVoidMethodV)(JNIEnv *, jclass, jmethodID, va_list)
     * }
     */
    public static void CallStaticVoidMethodV(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallStaticVoidMethodV$LAYOUT, CallStaticVoidMethodV$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*CallStaticVoidMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static class CallStaticVoidMethodA {

        CallStaticVoidMethodA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(CallStaticVoidMethodA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CallStaticVoidMethodA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout CallStaticVoidMethodA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("CallStaticVoidMethodA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*CallStaticVoidMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final AddressLayout CallStaticVoidMethodA$layout() {
        return CallStaticVoidMethodA$LAYOUT;
    }

    private static final long CallStaticVoidMethodA$OFFSET = 1144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*CallStaticVoidMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static final long CallStaticVoidMethodA$offset() {
        return CallStaticVoidMethodA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*CallStaticVoidMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static MemorySegment CallStaticVoidMethodA(MemorySegment struct) {
        return struct.get(CallStaticVoidMethodA$LAYOUT, CallStaticVoidMethodA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*CallStaticVoidMethodA)(JNIEnv *, jclass, jmethodID, const jvalue *)
     * }
     */
    public static void CallStaticVoidMethodA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CallStaticVoidMethodA$LAYOUT, CallStaticVoidMethodA$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jfieldID (*GetStaticFieldID)(JNIEnv *, jclass, const char *, const char *)
     * }
     */
    public static class GetStaticFieldID {

        GetStaticFieldID() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetStaticFieldID.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStaticFieldID.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStaticFieldID$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStaticFieldID"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jfieldID (*GetStaticFieldID)(JNIEnv *, jclass, const char *, const char *)
     * }
     */
    public static final AddressLayout GetStaticFieldID$layout() {
        return GetStaticFieldID$LAYOUT;
    }

    private static final long GetStaticFieldID$OFFSET = 1152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jfieldID (*GetStaticFieldID)(JNIEnv *, jclass, const char *, const char *)
     * }
     */
    public static final long GetStaticFieldID$offset() {
        return GetStaticFieldID$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jfieldID (*GetStaticFieldID)(JNIEnv *, jclass, const char *, const char *)
     * }
     */
    public static MemorySegment GetStaticFieldID(MemorySegment struct) {
        return struct.get(GetStaticFieldID$LAYOUT, GetStaticFieldID$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jfieldID (*GetStaticFieldID)(JNIEnv *, jclass, const char *, const char *)
     * }
     */
    public static void GetStaticFieldID(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStaticFieldID$LAYOUT, GetStaticFieldID$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jobject (*GetStaticObjectField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static class GetStaticObjectField {

        GetStaticObjectField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetStaticObjectField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStaticObjectField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStaticObjectField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStaticObjectField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jobject (*GetStaticObjectField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static final AddressLayout GetStaticObjectField$layout() {
        return GetStaticObjectField$LAYOUT;
    }

    private static final long GetStaticObjectField$OFFSET = 1160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jobject (*GetStaticObjectField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static final long GetStaticObjectField$offset() {
        return GetStaticObjectField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jobject (*GetStaticObjectField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static MemorySegment GetStaticObjectField(MemorySegment struct) {
        return struct.get(GetStaticObjectField$LAYOUT, GetStaticObjectField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jobject (*GetStaticObjectField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static void GetStaticObjectField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStaticObjectField$LAYOUT, GetStaticObjectField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jboolean (*GetStaticBooleanField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static class GetStaticBooleanField {

        GetStaticBooleanField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            byte apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_CHAR,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetStaticBooleanField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStaticBooleanField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static byte invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (byte) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStaticBooleanField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStaticBooleanField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jboolean (*GetStaticBooleanField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static final AddressLayout GetStaticBooleanField$layout() {
        return GetStaticBooleanField$LAYOUT;
    }

    private static final long GetStaticBooleanField$OFFSET = 1168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jboolean (*GetStaticBooleanField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static final long GetStaticBooleanField$offset() {
        return GetStaticBooleanField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jboolean (*GetStaticBooleanField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static MemorySegment GetStaticBooleanField(MemorySegment struct) {
        return struct.get(GetStaticBooleanField$LAYOUT, GetStaticBooleanField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jboolean (*GetStaticBooleanField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static void GetStaticBooleanField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStaticBooleanField$LAYOUT, GetStaticBooleanField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jbyte (*GetStaticByteField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static class GetStaticByteField {

        GetStaticByteField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            byte apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_CHAR,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetStaticByteField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStaticByteField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static byte invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (byte) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStaticByteField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStaticByteField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jbyte (*GetStaticByteField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static final AddressLayout GetStaticByteField$layout() {
        return GetStaticByteField$LAYOUT;
    }

    private static final long GetStaticByteField$OFFSET = 1176;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jbyte (*GetStaticByteField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static final long GetStaticByteField$offset() {
        return GetStaticByteField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jbyte (*GetStaticByteField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static MemorySegment GetStaticByteField(MemorySegment struct) {
        return struct.get(GetStaticByteField$LAYOUT, GetStaticByteField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jbyte (*GetStaticByteField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static void GetStaticByteField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStaticByteField$LAYOUT, GetStaticByteField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jchar (*GetStaticCharField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static class GetStaticCharField {

        GetStaticCharField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            short apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_SHORT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetStaticCharField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStaticCharField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static short invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (short) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStaticCharField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStaticCharField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jchar (*GetStaticCharField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static final AddressLayout GetStaticCharField$layout() {
        return GetStaticCharField$LAYOUT;
    }

    private static final long GetStaticCharField$OFFSET = 1184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jchar (*GetStaticCharField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static final long GetStaticCharField$offset() {
        return GetStaticCharField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jchar (*GetStaticCharField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static MemorySegment GetStaticCharField(MemorySegment struct) {
        return struct.get(GetStaticCharField$LAYOUT, GetStaticCharField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jchar (*GetStaticCharField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static void GetStaticCharField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStaticCharField$LAYOUT, GetStaticCharField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jshort (*GetStaticShortField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static class GetStaticShortField {

        GetStaticShortField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            short apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_SHORT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetStaticShortField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStaticShortField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static short invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (short) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStaticShortField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStaticShortField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jshort (*GetStaticShortField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static final AddressLayout GetStaticShortField$layout() {
        return GetStaticShortField$LAYOUT;
    }

    private static final long GetStaticShortField$OFFSET = 1192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jshort (*GetStaticShortField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static final long GetStaticShortField$offset() {
        return GetStaticShortField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jshort (*GetStaticShortField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static MemorySegment GetStaticShortField(MemorySegment struct) {
        return struct.get(GetStaticShortField$LAYOUT, GetStaticShortField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jshort (*GetStaticShortField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static void GetStaticShortField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStaticShortField$LAYOUT, GetStaticShortField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jint (*GetStaticIntField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static class GetStaticIntField {

        GetStaticIntField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetStaticIntField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStaticIntField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStaticIntField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStaticIntField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jint (*GetStaticIntField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static final AddressLayout GetStaticIntField$layout() {
        return GetStaticIntField$LAYOUT;
    }

    private static final long GetStaticIntField$OFFSET = 1200;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jint (*GetStaticIntField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static final long GetStaticIntField$offset() {
        return GetStaticIntField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jint (*GetStaticIntField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static MemorySegment GetStaticIntField(MemorySegment struct) {
        return struct.get(GetStaticIntField$LAYOUT, GetStaticIntField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jint (*GetStaticIntField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static void GetStaticIntField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStaticIntField$LAYOUT, GetStaticIntField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jlong (*GetStaticLongField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static class GetStaticLongField {

        GetStaticLongField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_LONG,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetStaticLongField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStaticLongField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStaticLongField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStaticLongField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jlong (*GetStaticLongField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static final AddressLayout GetStaticLongField$layout() {
        return GetStaticLongField$LAYOUT;
    }

    private static final long GetStaticLongField$OFFSET = 1208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jlong (*GetStaticLongField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static final long GetStaticLongField$offset() {
        return GetStaticLongField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jlong (*GetStaticLongField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static MemorySegment GetStaticLongField(MemorySegment struct) {
        return struct.get(GetStaticLongField$LAYOUT, GetStaticLongField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jlong (*GetStaticLongField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static void GetStaticLongField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStaticLongField$LAYOUT, GetStaticLongField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jfloat (*GetStaticFloatField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static class GetStaticFloatField {

        GetStaticFloatField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            float apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_FLOAT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetStaticFloatField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStaticFloatField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static float invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (float) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStaticFloatField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStaticFloatField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jfloat (*GetStaticFloatField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static final AddressLayout GetStaticFloatField$layout() {
        return GetStaticFloatField$LAYOUT;
    }

    private static final long GetStaticFloatField$OFFSET = 1216;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jfloat (*GetStaticFloatField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static final long GetStaticFloatField$offset() {
        return GetStaticFloatField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jfloat (*GetStaticFloatField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static MemorySegment GetStaticFloatField(MemorySegment struct) {
        return struct.get(GetStaticFloatField$LAYOUT, GetStaticFloatField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jfloat (*GetStaticFloatField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static void GetStaticFloatField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStaticFloatField$LAYOUT, GetStaticFloatField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jdouble (*GetStaticDoubleField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static class GetStaticDoubleField {

        GetStaticDoubleField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            double apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_DOUBLE,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetStaticDoubleField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStaticDoubleField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static double invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (double) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStaticDoubleField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStaticDoubleField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jdouble (*GetStaticDoubleField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static final AddressLayout GetStaticDoubleField$layout() {
        return GetStaticDoubleField$LAYOUT;
    }

    private static final long GetStaticDoubleField$OFFSET = 1224;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jdouble (*GetStaticDoubleField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static final long GetStaticDoubleField$offset() {
        return GetStaticDoubleField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jdouble (*GetStaticDoubleField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static MemorySegment GetStaticDoubleField(MemorySegment struct) {
        return struct.get(GetStaticDoubleField$LAYOUT, GetStaticDoubleField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jdouble (*GetStaticDoubleField)(JNIEnv *, jclass, jfieldID)
     * }
     */
    public static void GetStaticDoubleField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStaticDoubleField$LAYOUT, GetStaticDoubleField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetStaticObjectField)(JNIEnv *, jclass, jfieldID, jobject)
     * }
     */
    public static class SetStaticObjectField {

        SetStaticObjectField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetStaticObjectField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetStaticObjectField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetStaticObjectField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetStaticObjectField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetStaticObjectField)(JNIEnv *, jclass, jfieldID, jobject)
     * }
     */
    public static final AddressLayout SetStaticObjectField$layout() {
        return SetStaticObjectField$LAYOUT;
    }

    private static final long SetStaticObjectField$OFFSET = 1232;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetStaticObjectField)(JNIEnv *, jclass, jfieldID, jobject)
     * }
     */
    public static final long SetStaticObjectField$offset() {
        return SetStaticObjectField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetStaticObjectField)(JNIEnv *, jclass, jfieldID, jobject)
     * }
     */
    public static MemorySegment SetStaticObjectField(MemorySegment struct) {
        return struct.get(SetStaticObjectField$LAYOUT, SetStaticObjectField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetStaticObjectField)(JNIEnv *, jclass, jfieldID, jobject)
     * }
     */
    public static void SetStaticObjectField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetStaticObjectField$LAYOUT, SetStaticObjectField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetStaticBooleanField)(JNIEnv *, jclass, jfieldID, jboolean)
     * }
     */
    public static class SetStaticBooleanField {

        SetStaticBooleanField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, byte _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_CHAR
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetStaticBooleanField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetStaticBooleanField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, byte _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetStaticBooleanField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetStaticBooleanField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetStaticBooleanField)(JNIEnv *, jclass, jfieldID, jboolean)
     * }
     */
    public static final AddressLayout SetStaticBooleanField$layout() {
        return SetStaticBooleanField$LAYOUT;
    }

    private static final long SetStaticBooleanField$OFFSET = 1240;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetStaticBooleanField)(JNIEnv *, jclass, jfieldID, jboolean)
     * }
     */
    public static final long SetStaticBooleanField$offset() {
        return SetStaticBooleanField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetStaticBooleanField)(JNIEnv *, jclass, jfieldID, jboolean)
     * }
     */
    public static MemorySegment SetStaticBooleanField(MemorySegment struct) {
        return struct.get(SetStaticBooleanField$LAYOUT, SetStaticBooleanField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetStaticBooleanField)(JNIEnv *, jclass, jfieldID, jboolean)
     * }
     */
    public static void SetStaticBooleanField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetStaticBooleanField$LAYOUT, SetStaticBooleanField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetStaticByteField)(JNIEnv *, jclass, jfieldID, jbyte)
     * }
     */
    public static class SetStaticByteField {

        SetStaticByteField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, byte _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_CHAR
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetStaticByteField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetStaticByteField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, byte _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetStaticByteField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetStaticByteField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetStaticByteField)(JNIEnv *, jclass, jfieldID, jbyte)
     * }
     */
    public static final AddressLayout SetStaticByteField$layout() {
        return SetStaticByteField$LAYOUT;
    }

    private static final long SetStaticByteField$OFFSET = 1248;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetStaticByteField)(JNIEnv *, jclass, jfieldID, jbyte)
     * }
     */
    public static final long SetStaticByteField$offset() {
        return SetStaticByteField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetStaticByteField)(JNIEnv *, jclass, jfieldID, jbyte)
     * }
     */
    public static MemorySegment SetStaticByteField(MemorySegment struct) {
        return struct.get(SetStaticByteField$LAYOUT, SetStaticByteField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetStaticByteField)(JNIEnv *, jclass, jfieldID, jbyte)
     * }
     */
    public static void SetStaticByteField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetStaticByteField$LAYOUT, SetStaticByteField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetStaticCharField)(JNIEnv *, jclass, jfieldID, jchar)
     * }
     */
    public static class SetStaticCharField {

        SetStaticCharField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, short _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_SHORT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetStaticCharField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetStaticCharField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, short _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetStaticCharField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetStaticCharField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetStaticCharField)(JNIEnv *, jclass, jfieldID, jchar)
     * }
     */
    public static final AddressLayout SetStaticCharField$layout() {
        return SetStaticCharField$LAYOUT;
    }

    private static final long SetStaticCharField$OFFSET = 1256;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetStaticCharField)(JNIEnv *, jclass, jfieldID, jchar)
     * }
     */
    public static final long SetStaticCharField$offset() {
        return SetStaticCharField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetStaticCharField)(JNIEnv *, jclass, jfieldID, jchar)
     * }
     */
    public static MemorySegment SetStaticCharField(MemorySegment struct) {
        return struct.get(SetStaticCharField$LAYOUT, SetStaticCharField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetStaticCharField)(JNIEnv *, jclass, jfieldID, jchar)
     * }
     */
    public static void SetStaticCharField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetStaticCharField$LAYOUT, SetStaticCharField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetStaticShortField)(JNIEnv *, jclass, jfieldID, jshort)
     * }
     */
    public static class SetStaticShortField {

        SetStaticShortField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, short _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_SHORT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetStaticShortField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetStaticShortField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, short _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetStaticShortField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetStaticShortField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetStaticShortField)(JNIEnv *, jclass, jfieldID, jshort)
     * }
     */
    public static final AddressLayout SetStaticShortField$layout() {
        return SetStaticShortField$LAYOUT;
    }

    private static final long SetStaticShortField$OFFSET = 1264;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetStaticShortField)(JNIEnv *, jclass, jfieldID, jshort)
     * }
     */
    public static final long SetStaticShortField$offset() {
        return SetStaticShortField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetStaticShortField)(JNIEnv *, jclass, jfieldID, jshort)
     * }
     */
    public static MemorySegment SetStaticShortField(MemorySegment struct) {
        return struct.get(SetStaticShortField$LAYOUT, SetStaticShortField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetStaticShortField)(JNIEnv *, jclass, jfieldID, jshort)
     * }
     */
    public static void SetStaticShortField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetStaticShortField$LAYOUT, SetStaticShortField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetStaticIntField)(JNIEnv *, jclass, jfieldID, jint)
     * }
     */
    public static class SetStaticIntField {

        SetStaticIntField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetStaticIntField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetStaticIntField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetStaticIntField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetStaticIntField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetStaticIntField)(JNIEnv *, jclass, jfieldID, jint)
     * }
     */
    public static final AddressLayout SetStaticIntField$layout() {
        return SetStaticIntField$LAYOUT;
    }

    private static final long SetStaticIntField$OFFSET = 1272;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetStaticIntField)(JNIEnv *, jclass, jfieldID, jint)
     * }
     */
    public static final long SetStaticIntField$offset() {
        return SetStaticIntField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetStaticIntField)(JNIEnv *, jclass, jfieldID, jint)
     * }
     */
    public static MemorySegment SetStaticIntField(MemorySegment struct) {
        return struct.get(SetStaticIntField$LAYOUT, SetStaticIntField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetStaticIntField)(JNIEnv *, jclass, jfieldID, jint)
     * }
     */
    public static void SetStaticIntField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetStaticIntField$LAYOUT, SetStaticIntField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetStaticLongField)(JNIEnv *, jclass, jfieldID, jlong)
     * }
     */
    public static class SetStaticLongField {

        SetStaticLongField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetStaticLongField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetStaticLongField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetStaticLongField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetStaticLongField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetStaticLongField)(JNIEnv *, jclass, jfieldID, jlong)
     * }
     */
    public static final AddressLayout SetStaticLongField$layout() {
        return SetStaticLongField$LAYOUT;
    }

    private static final long SetStaticLongField$OFFSET = 1280;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetStaticLongField)(JNIEnv *, jclass, jfieldID, jlong)
     * }
     */
    public static final long SetStaticLongField$offset() {
        return SetStaticLongField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetStaticLongField)(JNIEnv *, jclass, jfieldID, jlong)
     * }
     */
    public static MemorySegment SetStaticLongField(MemorySegment struct) {
        return struct.get(SetStaticLongField$LAYOUT, SetStaticLongField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetStaticLongField)(JNIEnv *, jclass, jfieldID, jlong)
     * }
     */
    public static void SetStaticLongField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetStaticLongField$LAYOUT, SetStaticLongField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetStaticFloatField)(JNIEnv *, jclass, jfieldID, jfloat)
     * }
     */
    public static class SetStaticFloatField {

        SetStaticFloatField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, float _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_FLOAT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetStaticFloatField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetStaticFloatField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, float _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetStaticFloatField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetStaticFloatField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetStaticFloatField)(JNIEnv *, jclass, jfieldID, jfloat)
     * }
     */
    public static final AddressLayout SetStaticFloatField$layout() {
        return SetStaticFloatField$LAYOUT;
    }

    private static final long SetStaticFloatField$OFFSET = 1288;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetStaticFloatField)(JNIEnv *, jclass, jfieldID, jfloat)
     * }
     */
    public static final long SetStaticFloatField$offset() {
        return SetStaticFloatField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetStaticFloatField)(JNIEnv *, jclass, jfieldID, jfloat)
     * }
     */
    public static MemorySegment SetStaticFloatField(MemorySegment struct) {
        return struct.get(SetStaticFloatField$LAYOUT, SetStaticFloatField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetStaticFloatField)(JNIEnv *, jclass, jfieldID, jfloat)
     * }
     */
    public static void SetStaticFloatField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetStaticFloatField$LAYOUT, SetStaticFloatField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetStaticDoubleField)(JNIEnv *, jclass, jfieldID, jdouble)
     * }
     */
    public static class SetStaticDoubleField {

        SetStaticDoubleField() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, double _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_DOUBLE
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetStaticDoubleField.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetStaticDoubleField.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, double _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetStaticDoubleField$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetStaticDoubleField"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetStaticDoubleField)(JNIEnv *, jclass, jfieldID, jdouble)
     * }
     */
    public static final AddressLayout SetStaticDoubleField$layout() {
        return SetStaticDoubleField$LAYOUT;
    }

    private static final long SetStaticDoubleField$OFFSET = 1296;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetStaticDoubleField)(JNIEnv *, jclass, jfieldID, jdouble)
     * }
     */
    public static final long SetStaticDoubleField$offset() {
        return SetStaticDoubleField$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetStaticDoubleField)(JNIEnv *, jclass, jfieldID, jdouble)
     * }
     */
    public static MemorySegment SetStaticDoubleField(MemorySegment struct) {
        return struct.get(SetStaticDoubleField$LAYOUT, SetStaticDoubleField$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetStaticDoubleField)(JNIEnv *, jclass, jfieldID, jdouble)
     * }
     */
    public static void SetStaticDoubleField(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetStaticDoubleField$LAYOUT, SetStaticDoubleField$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jstring (*NewString)(JNIEnv *, const jchar *, jsize)
     * }
     */
    public static class NewString {

        NewString() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, int _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(NewString.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(NewString.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout NewString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("NewString"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jstring (*NewString)(JNIEnv *, const jchar *, jsize)
     * }
     */
    public static final AddressLayout NewString$layout() {
        return NewString$LAYOUT;
    }

    private static final long NewString$OFFSET = 1304;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jstring (*NewString)(JNIEnv *, const jchar *, jsize)
     * }
     */
    public static final long NewString$offset() {
        return NewString$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jstring (*NewString)(JNIEnv *, const jchar *, jsize)
     * }
     */
    public static MemorySegment NewString(MemorySegment struct) {
        return struct.get(NewString$LAYOUT, NewString$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jstring (*NewString)(JNIEnv *, const jchar *, jsize)
     * }
     */
    public static void NewString(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(NewString$LAYOUT, NewString$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jsize (*GetStringLength)(JNIEnv *, jstring)
     * }
     */
    public static class GetStringLength {

        GetStringLength() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetStringLength.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStringLength.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStringLength$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStringLength"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jsize (*GetStringLength)(JNIEnv *, jstring)
     * }
     */
    public static final AddressLayout GetStringLength$layout() {
        return GetStringLength$LAYOUT;
    }

    private static final long GetStringLength$OFFSET = 1312;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jsize (*GetStringLength)(JNIEnv *, jstring)
     * }
     */
    public static final long GetStringLength$offset() {
        return GetStringLength$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jsize (*GetStringLength)(JNIEnv *, jstring)
     * }
     */
    public static MemorySegment GetStringLength(MemorySegment struct) {
        return struct.get(GetStringLength$LAYOUT, GetStringLength$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jsize (*GetStringLength)(JNIEnv *, jstring)
     * }
     */
    public static void GetStringLength(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStringLength$LAYOUT, GetStringLength$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const jchar *(*GetStringChars)(JNIEnv *, jstring, jboolean *)
     * }
     */
    public static class GetStringChars {

        GetStringChars() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetStringChars.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStringChars.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStringChars$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStringChars"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const jchar *(*GetStringChars)(JNIEnv *, jstring, jboolean *)
     * }
     */
    public static final AddressLayout GetStringChars$layout() {
        return GetStringChars$LAYOUT;
    }

    private static final long GetStringChars$OFFSET = 1320;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const jchar *(*GetStringChars)(JNIEnv *, jstring, jboolean *)
     * }
     */
    public static final long GetStringChars$offset() {
        return GetStringChars$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const jchar *(*GetStringChars)(JNIEnv *, jstring, jboolean *)
     * }
     */
    public static MemorySegment GetStringChars(MemorySegment struct) {
        return struct.get(GetStringChars$LAYOUT, GetStringChars$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const jchar *(*GetStringChars)(JNIEnv *, jstring, jboolean *)
     * }
     */
    public static void GetStringChars(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStringChars$LAYOUT, GetStringChars$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseStringChars)(JNIEnv *, jstring, const jchar *)
     * }
     */
    public static class ReleaseStringChars {

        ReleaseStringChars() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(ReleaseStringChars.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseStringChars.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseStringChars$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseStringChars"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseStringChars)(JNIEnv *, jstring, const jchar *)
     * }
     */
    public static final AddressLayout ReleaseStringChars$layout() {
        return ReleaseStringChars$LAYOUT;
    }

    private static final long ReleaseStringChars$OFFSET = 1328;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseStringChars)(JNIEnv *, jstring, const jchar *)
     * }
     */
    public static final long ReleaseStringChars$offset() {
        return ReleaseStringChars$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseStringChars)(JNIEnv *, jstring, const jchar *)
     * }
     */
    public static MemorySegment ReleaseStringChars(MemorySegment struct) {
        return struct.get(ReleaseStringChars$LAYOUT, ReleaseStringChars$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseStringChars)(JNIEnv *, jstring, const jchar *)
     * }
     */
    public static void ReleaseStringChars(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseStringChars$LAYOUT, ReleaseStringChars$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jstring (*NewStringUTF)(JNIEnv *, const char *)
     * }
     */
    public static class NewStringUTF {

        NewStringUTF() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(NewStringUTF.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(NewStringUTF.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout NewStringUTF$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("NewStringUTF"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jstring (*NewStringUTF)(JNIEnv *, const char *)
     * }
     */
    public static final AddressLayout NewStringUTF$layout() {
        return NewStringUTF$LAYOUT;
    }

    private static final long NewStringUTF$OFFSET = 1336;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jstring (*NewStringUTF)(JNIEnv *, const char *)
     * }
     */
    public static final long NewStringUTF$offset() {
        return NewStringUTF$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jstring (*NewStringUTF)(JNIEnv *, const char *)
     * }
     */
    public static MemorySegment NewStringUTF(MemorySegment struct) {
        return struct.get(NewStringUTF$LAYOUT, NewStringUTF$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jstring (*NewStringUTF)(JNIEnv *, const char *)
     * }
     */
    public static void NewStringUTF(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(NewStringUTF$LAYOUT, NewStringUTF$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jsize (*GetStringUTFLength)(JNIEnv *, jstring)
     * }
     */
    public static class GetStringUTFLength {

        GetStringUTFLength() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetStringUTFLength.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStringUTFLength.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStringUTFLength$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStringUTFLength"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jsize (*GetStringUTFLength)(JNIEnv *, jstring)
     * }
     */
    public static final AddressLayout GetStringUTFLength$layout() {
        return GetStringUTFLength$LAYOUT;
    }

    private static final long GetStringUTFLength$OFFSET = 1344;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jsize (*GetStringUTFLength)(JNIEnv *, jstring)
     * }
     */
    public static final long GetStringUTFLength$offset() {
        return GetStringUTFLength$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jsize (*GetStringUTFLength)(JNIEnv *, jstring)
     * }
     */
    public static MemorySegment GetStringUTFLength(MemorySegment struct) {
        return struct.get(GetStringUTFLength$LAYOUT, GetStringUTFLength$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jsize (*GetStringUTFLength)(JNIEnv *, jstring)
     * }
     */
    public static void GetStringUTFLength(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStringUTFLength$LAYOUT, GetStringUTFLength$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const char *(*GetStringUTFChars)(JNIEnv *, jstring, jboolean *)
     * }
     */
    public static class GetStringUTFChars {

        GetStringUTFChars() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetStringUTFChars.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStringUTFChars.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStringUTFChars$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStringUTFChars"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *(*GetStringUTFChars)(JNIEnv *, jstring, jboolean *)
     * }
     */
    public static final AddressLayout GetStringUTFChars$layout() {
        return GetStringUTFChars$LAYOUT;
    }

    private static final long GetStringUTFChars$OFFSET = 1352;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *(*GetStringUTFChars)(JNIEnv *, jstring, jboolean *)
     * }
     */
    public static final long GetStringUTFChars$offset() {
        return GetStringUTFChars$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *(*GetStringUTFChars)(JNIEnv *, jstring, jboolean *)
     * }
     */
    public static MemorySegment GetStringUTFChars(MemorySegment struct) {
        return struct.get(GetStringUTFChars$LAYOUT, GetStringUTFChars$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *(*GetStringUTFChars)(JNIEnv *, jstring, jboolean *)
     * }
     */
    public static void GetStringUTFChars(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStringUTFChars$LAYOUT, GetStringUTFChars$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseStringUTFChars)(JNIEnv *, jstring, const char *)
     * }
     */
    public static class ReleaseStringUTFChars {

        ReleaseStringUTFChars() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(ReleaseStringUTFChars.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseStringUTFChars.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseStringUTFChars$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseStringUTFChars"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseStringUTFChars)(JNIEnv *, jstring, const char *)
     * }
     */
    public static final AddressLayout ReleaseStringUTFChars$layout() {
        return ReleaseStringUTFChars$LAYOUT;
    }

    private static final long ReleaseStringUTFChars$OFFSET = 1360;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseStringUTFChars)(JNIEnv *, jstring, const char *)
     * }
     */
    public static final long ReleaseStringUTFChars$offset() {
        return ReleaseStringUTFChars$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseStringUTFChars)(JNIEnv *, jstring, const char *)
     * }
     */
    public static MemorySegment ReleaseStringUTFChars(MemorySegment struct) {
        return struct.get(ReleaseStringUTFChars$LAYOUT, ReleaseStringUTFChars$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseStringUTFChars)(JNIEnv *, jstring, const char *)
     * }
     */
    public static void ReleaseStringUTFChars(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseStringUTFChars$LAYOUT, ReleaseStringUTFChars$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jsize (*GetArrayLength)(JNIEnv *, jarray)
     * }
     */
    public static class GetArrayLength {

        GetArrayLength() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetArrayLength.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetArrayLength.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetArrayLength$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetArrayLength"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jsize (*GetArrayLength)(JNIEnv *, jarray)
     * }
     */
    public static final AddressLayout GetArrayLength$layout() {
        return GetArrayLength$LAYOUT;
    }

    private static final long GetArrayLength$OFFSET = 1368;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jsize (*GetArrayLength)(JNIEnv *, jarray)
     * }
     */
    public static final long GetArrayLength$offset() {
        return GetArrayLength$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jsize (*GetArrayLength)(JNIEnv *, jarray)
     * }
     */
    public static MemorySegment GetArrayLength(MemorySegment struct) {
        return struct.get(GetArrayLength$LAYOUT, GetArrayLength$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jsize (*GetArrayLength)(JNIEnv *, jarray)
     * }
     */
    public static void GetArrayLength(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetArrayLength$LAYOUT, GetArrayLength$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jobjectArray (*NewObjectArray)(JNIEnv *, jsize, jclass, jobject)
     * }
     */
    public static class NewObjectArray {

        NewObjectArray() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(NewObjectArray.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(NewObjectArray.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout NewObjectArray$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("NewObjectArray"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jobjectArray (*NewObjectArray)(JNIEnv *, jsize, jclass, jobject)
     * }
     */
    public static final AddressLayout NewObjectArray$layout() {
        return NewObjectArray$LAYOUT;
    }

    private static final long NewObjectArray$OFFSET = 1376;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jobjectArray (*NewObjectArray)(JNIEnv *, jsize, jclass, jobject)
     * }
     */
    public static final long NewObjectArray$offset() {
        return NewObjectArray$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jobjectArray (*NewObjectArray)(JNIEnv *, jsize, jclass, jobject)
     * }
     */
    public static MemorySegment NewObjectArray(MemorySegment struct) {
        return struct.get(NewObjectArray$LAYOUT, NewObjectArray$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jobjectArray (*NewObjectArray)(JNIEnv *, jsize, jclass, jobject)
     * }
     */
    public static void NewObjectArray(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(NewObjectArray$LAYOUT, NewObjectArray$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jobject (*GetObjectArrayElement)(JNIEnv *, jobjectArray, jsize)
     * }
     */
    public static class GetObjectArrayElement {

        GetObjectArrayElement() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, int _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetObjectArrayElement.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetObjectArrayElement.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetObjectArrayElement$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetObjectArrayElement"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jobject (*GetObjectArrayElement)(JNIEnv *, jobjectArray, jsize)
     * }
     */
    public static final AddressLayout GetObjectArrayElement$layout() {
        return GetObjectArrayElement$LAYOUT;
    }

    private static final long GetObjectArrayElement$OFFSET = 1384;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jobject (*GetObjectArrayElement)(JNIEnv *, jobjectArray, jsize)
     * }
     */
    public static final long GetObjectArrayElement$offset() {
        return GetObjectArrayElement$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jobject (*GetObjectArrayElement)(JNIEnv *, jobjectArray, jsize)
     * }
     */
    public static MemorySegment GetObjectArrayElement(MemorySegment struct) {
        return struct.get(GetObjectArrayElement$LAYOUT, GetObjectArrayElement$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jobject (*GetObjectArrayElement)(JNIEnv *, jobjectArray, jsize)
     * }
     */
    public static void GetObjectArrayElement(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetObjectArrayElement$LAYOUT, GetObjectArrayElement$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetObjectArrayElement)(JNIEnv *, jobjectArray, jsize, jobject)
     * }
     */
    public static class SetObjectArrayElement {

        SetObjectArrayElement() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetObjectArrayElement.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetObjectArrayElement.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetObjectArrayElement$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetObjectArrayElement"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetObjectArrayElement)(JNIEnv *, jobjectArray, jsize, jobject)
     * }
     */
    public static final AddressLayout SetObjectArrayElement$layout() {
        return SetObjectArrayElement$LAYOUT;
    }

    private static final long SetObjectArrayElement$OFFSET = 1392;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetObjectArrayElement)(JNIEnv *, jobjectArray, jsize, jobject)
     * }
     */
    public static final long SetObjectArrayElement$offset() {
        return SetObjectArrayElement$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetObjectArrayElement)(JNIEnv *, jobjectArray, jsize, jobject)
     * }
     */
    public static MemorySegment SetObjectArrayElement(MemorySegment struct) {
        return struct.get(SetObjectArrayElement$LAYOUT, SetObjectArrayElement$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetObjectArrayElement)(JNIEnv *, jobjectArray, jsize, jobject)
     * }
     */
    public static void SetObjectArrayElement(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetObjectArrayElement$LAYOUT, SetObjectArrayElement$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jbooleanArray (*NewBooleanArray)(JNIEnv *, jsize)
     * }
     */
    public static class NewBooleanArray {

        NewBooleanArray() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(NewBooleanArray.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(NewBooleanArray.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout NewBooleanArray$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("NewBooleanArray"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jbooleanArray (*NewBooleanArray)(JNIEnv *, jsize)
     * }
     */
    public static final AddressLayout NewBooleanArray$layout() {
        return NewBooleanArray$LAYOUT;
    }

    private static final long NewBooleanArray$OFFSET = 1400;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jbooleanArray (*NewBooleanArray)(JNIEnv *, jsize)
     * }
     */
    public static final long NewBooleanArray$offset() {
        return NewBooleanArray$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jbooleanArray (*NewBooleanArray)(JNIEnv *, jsize)
     * }
     */
    public static MemorySegment NewBooleanArray(MemorySegment struct) {
        return struct.get(NewBooleanArray$LAYOUT, NewBooleanArray$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jbooleanArray (*NewBooleanArray)(JNIEnv *, jsize)
     * }
     */
    public static void NewBooleanArray(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(NewBooleanArray$LAYOUT, NewBooleanArray$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jbyteArray (*NewByteArray)(JNIEnv *, jsize)
     * }
     */
    public static class NewByteArray {

        NewByteArray() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(NewByteArray.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(NewByteArray.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout NewByteArray$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("NewByteArray"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jbyteArray (*NewByteArray)(JNIEnv *, jsize)
     * }
     */
    public static final AddressLayout NewByteArray$layout() {
        return NewByteArray$LAYOUT;
    }

    private static final long NewByteArray$OFFSET = 1408;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jbyteArray (*NewByteArray)(JNIEnv *, jsize)
     * }
     */
    public static final long NewByteArray$offset() {
        return NewByteArray$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jbyteArray (*NewByteArray)(JNIEnv *, jsize)
     * }
     */
    public static MemorySegment NewByteArray(MemorySegment struct) {
        return struct.get(NewByteArray$LAYOUT, NewByteArray$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jbyteArray (*NewByteArray)(JNIEnv *, jsize)
     * }
     */
    public static void NewByteArray(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(NewByteArray$LAYOUT, NewByteArray$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jcharArray (*NewCharArray)(JNIEnv *, jsize)
     * }
     */
    public static class NewCharArray {

        NewCharArray() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(NewCharArray.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(NewCharArray.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout NewCharArray$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("NewCharArray"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jcharArray (*NewCharArray)(JNIEnv *, jsize)
     * }
     */
    public static final AddressLayout NewCharArray$layout() {
        return NewCharArray$LAYOUT;
    }

    private static final long NewCharArray$OFFSET = 1416;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jcharArray (*NewCharArray)(JNIEnv *, jsize)
     * }
     */
    public static final long NewCharArray$offset() {
        return NewCharArray$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jcharArray (*NewCharArray)(JNIEnv *, jsize)
     * }
     */
    public static MemorySegment NewCharArray(MemorySegment struct) {
        return struct.get(NewCharArray$LAYOUT, NewCharArray$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jcharArray (*NewCharArray)(JNIEnv *, jsize)
     * }
     */
    public static void NewCharArray(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(NewCharArray$LAYOUT, NewCharArray$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jshortArray (*NewShortArray)(JNIEnv *, jsize)
     * }
     */
    public static class NewShortArray {

        NewShortArray() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(NewShortArray.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(NewShortArray.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout NewShortArray$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("NewShortArray"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jshortArray (*NewShortArray)(JNIEnv *, jsize)
     * }
     */
    public static final AddressLayout NewShortArray$layout() {
        return NewShortArray$LAYOUT;
    }

    private static final long NewShortArray$OFFSET = 1424;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jshortArray (*NewShortArray)(JNIEnv *, jsize)
     * }
     */
    public static final long NewShortArray$offset() {
        return NewShortArray$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jshortArray (*NewShortArray)(JNIEnv *, jsize)
     * }
     */
    public static MemorySegment NewShortArray(MemorySegment struct) {
        return struct.get(NewShortArray$LAYOUT, NewShortArray$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jshortArray (*NewShortArray)(JNIEnv *, jsize)
     * }
     */
    public static void NewShortArray(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(NewShortArray$LAYOUT, NewShortArray$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jintArray (*NewIntArray)(JNIEnv *, jsize)
     * }
     */
    public static class NewIntArray {

        NewIntArray() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(NewIntArray.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(NewIntArray.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout NewIntArray$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("NewIntArray"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jintArray (*NewIntArray)(JNIEnv *, jsize)
     * }
     */
    public static final AddressLayout NewIntArray$layout() {
        return NewIntArray$LAYOUT;
    }

    private static final long NewIntArray$OFFSET = 1432;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jintArray (*NewIntArray)(JNIEnv *, jsize)
     * }
     */
    public static final long NewIntArray$offset() {
        return NewIntArray$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jintArray (*NewIntArray)(JNIEnv *, jsize)
     * }
     */
    public static MemorySegment NewIntArray(MemorySegment struct) {
        return struct.get(NewIntArray$LAYOUT, NewIntArray$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jintArray (*NewIntArray)(JNIEnv *, jsize)
     * }
     */
    public static void NewIntArray(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(NewIntArray$LAYOUT, NewIntArray$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jlongArray (*NewLongArray)(JNIEnv *, jsize)
     * }
     */
    public static class NewLongArray {

        NewLongArray() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(NewLongArray.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(NewLongArray.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout NewLongArray$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("NewLongArray"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jlongArray (*NewLongArray)(JNIEnv *, jsize)
     * }
     */
    public static final AddressLayout NewLongArray$layout() {
        return NewLongArray$LAYOUT;
    }

    private static final long NewLongArray$OFFSET = 1440;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jlongArray (*NewLongArray)(JNIEnv *, jsize)
     * }
     */
    public static final long NewLongArray$offset() {
        return NewLongArray$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jlongArray (*NewLongArray)(JNIEnv *, jsize)
     * }
     */
    public static MemorySegment NewLongArray(MemorySegment struct) {
        return struct.get(NewLongArray$LAYOUT, NewLongArray$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jlongArray (*NewLongArray)(JNIEnv *, jsize)
     * }
     */
    public static void NewLongArray(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(NewLongArray$LAYOUT, NewLongArray$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jfloatArray (*NewFloatArray)(JNIEnv *, jsize)
     * }
     */
    public static class NewFloatArray {

        NewFloatArray() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(NewFloatArray.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(NewFloatArray.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout NewFloatArray$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("NewFloatArray"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jfloatArray (*NewFloatArray)(JNIEnv *, jsize)
     * }
     */
    public static final AddressLayout NewFloatArray$layout() {
        return NewFloatArray$LAYOUT;
    }

    private static final long NewFloatArray$OFFSET = 1448;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jfloatArray (*NewFloatArray)(JNIEnv *, jsize)
     * }
     */
    public static final long NewFloatArray$offset() {
        return NewFloatArray$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jfloatArray (*NewFloatArray)(JNIEnv *, jsize)
     * }
     */
    public static MemorySegment NewFloatArray(MemorySegment struct) {
        return struct.get(NewFloatArray$LAYOUT, NewFloatArray$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jfloatArray (*NewFloatArray)(JNIEnv *, jsize)
     * }
     */
    public static void NewFloatArray(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(NewFloatArray$LAYOUT, NewFloatArray$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jdoubleArray (*NewDoubleArray)(JNIEnv *, jsize)
     * }
     */
    public static class NewDoubleArray {

        NewDoubleArray() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(NewDoubleArray.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(NewDoubleArray.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout NewDoubleArray$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("NewDoubleArray"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jdoubleArray (*NewDoubleArray)(JNIEnv *, jsize)
     * }
     */
    public static final AddressLayout NewDoubleArray$layout() {
        return NewDoubleArray$LAYOUT;
    }

    private static final long NewDoubleArray$OFFSET = 1456;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jdoubleArray (*NewDoubleArray)(JNIEnv *, jsize)
     * }
     */
    public static final long NewDoubleArray$offset() {
        return NewDoubleArray$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jdoubleArray (*NewDoubleArray)(JNIEnv *, jsize)
     * }
     */
    public static MemorySegment NewDoubleArray(MemorySegment struct) {
        return struct.get(NewDoubleArray$LAYOUT, NewDoubleArray$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jdoubleArray (*NewDoubleArray)(JNIEnv *, jsize)
     * }
     */
    public static void NewDoubleArray(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(NewDoubleArray$LAYOUT, NewDoubleArray$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jboolean *(*GetBooleanArrayElements)(JNIEnv *, jbooleanArray, jboolean *)
     * }
     */
    public static class GetBooleanArrayElements {

        GetBooleanArrayElements() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetBooleanArrayElements.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetBooleanArrayElements.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetBooleanArrayElements$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetBooleanArrayElements"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jboolean *(*GetBooleanArrayElements)(JNIEnv *, jbooleanArray, jboolean *)
     * }
     */
    public static final AddressLayout GetBooleanArrayElements$layout() {
        return GetBooleanArrayElements$LAYOUT;
    }

    private static final long GetBooleanArrayElements$OFFSET = 1464;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jboolean *(*GetBooleanArrayElements)(JNIEnv *, jbooleanArray, jboolean *)
     * }
     */
    public static final long GetBooleanArrayElements$offset() {
        return GetBooleanArrayElements$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jboolean *(*GetBooleanArrayElements)(JNIEnv *, jbooleanArray, jboolean *)
     * }
     */
    public static MemorySegment GetBooleanArrayElements(MemorySegment struct) {
        return struct.get(GetBooleanArrayElements$LAYOUT, GetBooleanArrayElements$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jboolean *(*GetBooleanArrayElements)(JNIEnv *, jbooleanArray, jboolean *)
     * }
     */
    public static void GetBooleanArrayElements(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetBooleanArrayElements$LAYOUT, GetBooleanArrayElements$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jbyte *(*GetByteArrayElements)(JNIEnv *, jbyteArray, jboolean *)
     * }
     */
    public static class GetByteArrayElements {

        GetByteArrayElements() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetByteArrayElements.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetByteArrayElements.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetByteArrayElements$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetByteArrayElements"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jbyte *(*GetByteArrayElements)(JNIEnv *, jbyteArray, jboolean *)
     * }
     */
    public static final AddressLayout GetByteArrayElements$layout() {
        return GetByteArrayElements$LAYOUT;
    }

    private static final long GetByteArrayElements$OFFSET = 1472;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jbyte *(*GetByteArrayElements)(JNIEnv *, jbyteArray, jboolean *)
     * }
     */
    public static final long GetByteArrayElements$offset() {
        return GetByteArrayElements$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jbyte *(*GetByteArrayElements)(JNIEnv *, jbyteArray, jboolean *)
     * }
     */
    public static MemorySegment GetByteArrayElements(MemorySegment struct) {
        return struct.get(GetByteArrayElements$LAYOUT, GetByteArrayElements$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jbyte *(*GetByteArrayElements)(JNIEnv *, jbyteArray, jboolean *)
     * }
     */
    public static void GetByteArrayElements(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetByteArrayElements$LAYOUT, GetByteArrayElements$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jchar *(*GetCharArrayElements)(JNIEnv *, jcharArray, jboolean *)
     * }
     */
    public static class GetCharArrayElements {

        GetCharArrayElements() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetCharArrayElements.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetCharArrayElements.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetCharArrayElements$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetCharArrayElements"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jchar *(*GetCharArrayElements)(JNIEnv *, jcharArray, jboolean *)
     * }
     */
    public static final AddressLayout GetCharArrayElements$layout() {
        return GetCharArrayElements$LAYOUT;
    }

    private static final long GetCharArrayElements$OFFSET = 1480;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jchar *(*GetCharArrayElements)(JNIEnv *, jcharArray, jboolean *)
     * }
     */
    public static final long GetCharArrayElements$offset() {
        return GetCharArrayElements$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jchar *(*GetCharArrayElements)(JNIEnv *, jcharArray, jboolean *)
     * }
     */
    public static MemorySegment GetCharArrayElements(MemorySegment struct) {
        return struct.get(GetCharArrayElements$LAYOUT, GetCharArrayElements$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jchar *(*GetCharArrayElements)(JNIEnv *, jcharArray, jboolean *)
     * }
     */
    public static void GetCharArrayElements(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetCharArrayElements$LAYOUT, GetCharArrayElements$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jshort *(*GetShortArrayElements)(JNIEnv *, jshortArray, jboolean *)
     * }
     */
    public static class GetShortArrayElements {

        GetShortArrayElements() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetShortArrayElements.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetShortArrayElements.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetShortArrayElements$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetShortArrayElements"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jshort *(*GetShortArrayElements)(JNIEnv *, jshortArray, jboolean *)
     * }
     */
    public static final AddressLayout GetShortArrayElements$layout() {
        return GetShortArrayElements$LAYOUT;
    }

    private static final long GetShortArrayElements$OFFSET = 1488;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jshort *(*GetShortArrayElements)(JNIEnv *, jshortArray, jboolean *)
     * }
     */
    public static final long GetShortArrayElements$offset() {
        return GetShortArrayElements$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jshort *(*GetShortArrayElements)(JNIEnv *, jshortArray, jboolean *)
     * }
     */
    public static MemorySegment GetShortArrayElements(MemorySegment struct) {
        return struct.get(GetShortArrayElements$LAYOUT, GetShortArrayElements$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jshort *(*GetShortArrayElements)(JNIEnv *, jshortArray, jboolean *)
     * }
     */
    public static void GetShortArrayElements(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetShortArrayElements$LAYOUT, GetShortArrayElements$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jint *(*GetIntArrayElements)(JNIEnv *, jintArray, jboolean *)
     * }
     */
    public static class GetIntArrayElements {

        GetIntArrayElements() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetIntArrayElements.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetIntArrayElements.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetIntArrayElements$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetIntArrayElements"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jint *(*GetIntArrayElements)(JNIEnv *, jintArray, jboolean *)
     * }
     */
    public static final AddressLayout GetIntArrayElements$layout() {
        return GetIntArrayElements$LAYOUT;
    }

    private static final long GetIntArrayElements$OFFSET = 1496;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jint *(*GetIntArrayElements)(JNIEnv *, jintArray, jboolean *)
     * }
     */
    public static final long GetIntArrayElements$offset() {
        return GetIntArrayElements$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jint *(*GetIntArrayElements)(JNIEnv *, jintArray, jboolean *)
     * }
     */
    public static MemorySegment GetIntArrayElements(MemorySegment struct) {
        return struct.get(GetIntArrayElements$LAYOUT, GetIntArrayElements$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jint *(*GetIntArrayElements)(JNIEnv *, jintArray, jboolean *)
     * }
     */
    public static void GetIntArrayElements(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetIntArrayElements$LAYOUT, GetIntArrayElements$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jlong *(*GetLongArrayElements)(JNIEnv *, jlongArray, jboolean *)
     * }
     */
    public static class GetLongArrayElements {

        GetLongArrayElements() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetLongArrayElements.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetLongArrayElements.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetLongArrayElements$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetLongArrayElements"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jlong *(*GetLongArrayElements)(JNIEnv *, jlongArray, jboolean *)
     * }
     */
    public static final AddressLayout GetLongArrayElements$layout() {
        return GetLongArrayElements$LAYOUT;
    }

    private static final long GetLongArrayElements$OFFSET = 1504;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jlong *(*GetLongArrayElements)(JNIEnv *, jlongArray, jboolean *)
     * }
     */
    public static final long GetLongArrayElements$offset() {
        return GetLongArrayElements$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jlong *(*GetLongArrayElements)(JNIEnv *, jlongArray, jboolean *)
     * }
     */
    public static MemorySegment GetLongArrayElements(MemorySegment struct) {
        return struct.get(GetLongArrayElements$LAYOUT, GetLongArrayElements$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jlong *(*GetLongArrayElements)(JNIEnv *, jlongArray, jboolean *)
     * }
     */
    public static void GetLongArrayElements(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetLongArrayElements$LAYOUT, GetLongArrayElements$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jfloat *(*GetFloatArrayElements)(JNIEnv *, jfloatArray, jboolean *)
     * }
     */
    public static class GetFloatArrayElements {

        GetFloatArrayElements() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetFloatArrayElements.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetFloatArrayElements.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetFloatArrayElements$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetFloatArrayElements"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jfloat *(*GetFloatArrayElements)(JNIEnv *, jfloatArray, jboolean *)
     * }
     */
    public static final AddressLayout GetFloatArrayElements$layout() {
        return GetFloatArrayElements$LAYOUT;
    }

    private static final long GetFloatArrayElements$OFFSET = 1512;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jfloat *(*GetFloatArrayElements)(JNIEnv *, jfloatArray, jboolean *)
     * }
     */
    public static final long GetFloatArrayElements$offset() {
        return GetFloatArrayElements$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jfloat *(*GetFloatArrayElements)(JNIEnv *, jfloatArray, jboolean *)
     * }
     */
    public static MemorySegment GetFloatArrayElements(MemorySegment struct) {
        return struct.get(GetFloatArrayElements$LAYOUT, GetFloatArrayElements$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jfloat *(*GetFloatArrayElements)(JNIEnv *, jfloatArray, jboolean *)
     * }
     */
    public static void GetFloatArrayElements(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetFloatArrayElements$LAYOUT, GetFloatArrayElements$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jdouble *(*GetDoubleArrayElements)(JNIEnv *, jdoubleArray, jboolean *)
     * }
     */
    public static class GetDoubleArrayElements {

        GetDoubleArrayElements() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetDoubleArrayElements.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetDoubleArrayElements.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetDoubleArrayElements$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetDoubleArrayElements"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jdouble *(*GetDoubleArrayElements)(JNIEnv *, jdoubleArray, jboolean *)
     * }
     */
    public static final AddressLayout GetDoubleArrayElements$layout() {
        return GetDoubleArrayElements$LAYOUT;
    }

    private static final long GetDoubleArrayElements$OFFSET = 1520;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jdouble *(*GetDoubleArrayElements)(JNIEnv *, jdoubleArray, jboolean *)
     * }
     */
    public static final long GetDoubleArrayElements$offset() {
        return GetDoubleArrayElements$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jdouble *(*GetDoubleArrayElements)(JNIEnv *, jdoubleArray, jboolean *)
     * }
     */
    public static MemorySegment GetDoubleArrayElements(MemorySegment struct) {
        return struct.get(GetDoubleArrayElements$LAYOUT, GetDoubleArrayElements$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jdouble *(*GetDoubleArrayElements)(JNIEnv *, jdoubleArray, jboolean *)
     * }
     */
    public static void GetDoubleArrayElements(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetDoubleArrayElements$LAYOUT, GetDoubleArrayElements$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseBooleanArrayElements)(JNIEnv *, jbooleanArray, jboolean *, jint)
     * }
     */
    public static class ReleaseBooleanArrayElements {

        ReleaseBooleanArrayElements() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(ReleaseBooleanArrayElements.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseBooleanArrayElements.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseBooleanArrayElements$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseBooleanArrayElements"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseBooleanArrayElements)(JNIEnv *, jbooleanArray, jboolean *, jint)
     * }
     */
    public static final AddressLayout ReleaseBooleanArrayElements$layout() {
        return ReleaseBooleanArrayElements$LAYOUT;
    }

    private static final long ReleaseBooleanArrayElements$OFFSET = 1528;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseBooleanArrayElements)(JNIEnv *, jbooleanArray, jboolean *, jint)
     * }
     */
    public static final long ReleaseBooleanArrayElements$offset() {
        return ReleaseBooleanArrayElements$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseBooleanArrayElements)(JNIEnv *, jbooleanArray, jboolean *, jint)
     * }
     */
    public static MemorySegment ReleaseBooleanArrayElements(MemorySegment struct) {
        return struct.get(ReleaseBooleanArrayElements$LAYOUT, ReleaseBooleanArrayElements$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseBooleanArrayElements)(JNIEnv *, jbooleanArray, jboolean *, jint)
     * }
     */
    public static void ReleaseBooleanArrayElements(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseBooleanArrayElements$LAYOUT, ReleaseBooleanArrayElements$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseByteArrayElements)(JNIEnv *, jbyteArray, jbyte *, jint)
     * }
     */
    public static class ReleaseByteArrayElements {

        ReleaseByteArrayElements() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(ReleaseByteArrayElements.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseByteArrayElements.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseByteArrayElements$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseByteArrayElements"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseByteArrayElements)(JNIEnv *, jbyteArray, jbyte *, jint)
     * }
     */
    public static final AddressLayout ReleaseByteArrayElements$layout() {
        return ReleaseByteArrayElements$LAYOUT;
    }

    private static final long ReleaseByteArrayElements$OFFSET = 1536;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseByteArrayElements)(JNIEnv *, jbyteArray, jbyte *, jint)
     * }
     */
    public static final long ReleaseByteArrayElements$offset() {
        return ReleaseByteArrayElements$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseByteArrayElements)(JNIEnv *, jbyteArray, jbyte *, jint)
     * }
     */
    public static MemorySegment ReleaseByteArrayElements(MemorySegment struct) {
        return struct.get(ReleaseByteArrayElements$LAYOUT, ReleaseByteArrayElements$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseByteArrayElements)(JNIEnv *, jbyteArray, jbyte *, jint)
     * }
     */
    public static void ReleaseByteArrayElements(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseByteArrayElements$LAYOUT, ReleaseByteArrayElements$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseCharArrayElements)(JNIEnv *, jcharArray, jchar *, jint)
     * }
     */
    public static class ReleaseCharArrayElements {

        ReleaseCharArrayElements() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(ReleaseCharArrayElements.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseCharArrayElements.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseCharArrayElements$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseCharArrayElements"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseCharArrayElements)(JNIEnv *, jcharArray, jchar *, jint)
     * }
     */
    public static final AddressLayout ReleaseCharArrayElements$layout() {
        return ReleaseCharArrayElements$LAYOUT;
    }

    private static final long ReleaseCharArrayElements$OFFSET = 1544;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseCharArrayElements)(JNIEnv *, jcharArray, jchar *, jint)
     * }
     */
    public static final long ReleaseCharArrayElements$offset() {
        return ReleaseCharArrayElements$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseCharArrayElements)(JNIEnv *, jcharArray, jchar *, jint)
     * }
     */
    public static MemorySegment ReleaseCharArrayElements(MemorySegment struct) {
        return struct.get(ReleaseCharArrayElements$LAYOUT, ReleaseCharArrayElements$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseCharArrayElements)(JNIEnv *, jcharArray, jchar *, jint)
     * }
     */
    public static void ReleaseCharArrayElements(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseCharArrayElements$LAYOUT, ReleaseCharArrayElements$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseShortArrayElements)(JNIEnv *, jshortArray, jshort *, jint)
     * }
     */
    public static class ReleaseShortArrayElements {

        ReleaseShortArrayElements() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(ReleaseShortArrayElements.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseShortArrayElements.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseShortArrayElements$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseShortArrayElements"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseShortArrayElements)(JNIEnv *, jshortArray, jshort *, jint)
     * }
     */
    public static final AddressLayout ReleaseShortArrayElements$layout() {
        return ReleaseShortArrayElements$LAYOUT;
    }

    private static final long ReleaseShortArrayElements$OFFSET = 1552;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseShortArrayElements)(JNIEnv *, jshortArray, jshort *, jint)
     * }
     */
    public static final long ReleaseShortArrayElements$offset() {
        return ReleaseShortArrayElements$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseShortArrayElements)(JNIEnv *, jshortArray, jshort *, jint)
     * }
     */
    public static MemorySegment ReleaseShortArrayElements(MemorySegment struct) {
        return struct.get(ReleaseShortArrayElements$LAYOUT, ReleaseShortArrayElements$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseShortArrayElements)(JNIEnv *, jshortArray, jshort *, jint)
     * }
     */
    public static void ReleaseShortArrayElements(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseShortArrayElements$LAYOUT, ReleaseShortArrayElements$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseIntArrayElements)(JNIEnv *, jintArray, jint *, jint)
     * }
     */
    public static class ReleaseIntArrayElements {

        ReleaseIntArrayElements() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(ReleaseIntArrayElements.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseIntArrayElements.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseIntArrayElements$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseIntArrayElements"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseIntArrayElements)(JNIEnv *, jintArray, jint *, jint)
     * }
     */
    public static final AddressLayout ReleaseIntArrayElements$layout() {
        return ReleaseIntArrayElements$LAYOUT;
    }

    private static final long ReleaseIntArrayElements$OFFSET = 1560;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseIntArrayElements)(JNIEnv *, jintArray, jint *, jint)
     * }
     */
    public static final long ReleaseIntArrayElements$offset() {
        return ReleaseIntArrayElements$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseIntArrayElements)(JNIEnv *, jintArray, jint *, jint)
     * }
     */
    public static MemorySegment ReleaseIntArrayElements(MemorySegment struct) {
        return struct.get(ReleaseIntArrayElements$LAYOUT, ReleaseIntArrayElements$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseIntArrayElements)(JNIEnv *, jintArray, jint *, jint)
     * }
     */
    public static void ReleaseIntArrayElements(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseIntArrayElements$LAYOUT, ReleaseIntArrayElements$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseLongArrayElements)(JNIEnv *, jlongArray, jlong *, jint)
     * }
     */
    public static class ReleaseLongArrayElements {

        ReleaseLongArrayElements() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(ReleaseLongArrayElements.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseLongArrayElements.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseLongArrayElements$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseLongArrayElements"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseLongArrayElements)(JNIEnv *, jlongArray, jlong *, jint)
     * }
     */
    public static final AddressLayout ReleaseLongArrayElements$layout() {
        return ReleaseLongArrayElements$LAYOUT;
    }

    private static final long ReleaseLongArrayElements$OFFSET = 1568;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseLongArrayElements)(JNIEnv *, jlongArray, jlong *, jint)
     * }
     */
    public static final long ReleaseLongArrayElements$offset() {
        return ReleaseLongArrayElements$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseLongArrayElements)(JNIEnv *, jlongArray, jlong *, jint)
     * }
     */
    public static MemorySegment ReleaseLongArrayElements(MemorySegment struct) {
        return struct.get(ReleaseLongArrayElements$LAYOUT, ReleaseLongArrayElements$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseLongArrayElements)(JNIEnv *, jlongArray, jlong *, jint)
     * }
     */
    public static void ReleaseLongArrayElements(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseLongArrayElements$LAYOUT, ReleaseLongArrayElements$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseFloatArrayElements)(JNIEnv *, jfloatArray, jfloat *, jint)
     * }
     */
    public static class ReleaseFloatArrayElements {

        ReleaseFloatArrayElements() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(ReleaseFloatArrayElements.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseFloatArrayElements.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseFloatArrayElements$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseFloatArrayElements"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseFloatArrayElements)(JNIEnv *, jfloatArray, jfloat *, jint)
     * }
     */
    public static final AddressLayout ReleaseFloatArrayElements$layout() {
        return ReleaseFloatArrayElements$LAYOUT;
    }

    private static final long ReleaseFloatArrayElements$OFFSET = 1576;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseFloatArrayElements)(JNIEnv *, jfloatArray, jfloat *, jint)
     * }
     */
    public static final long ReleaseFloatArrayElements$offset() {
        return ReleaseFloatArrayElements$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseFloatArrayElements)(JNIEnv *, jfloatArray, jfloat *, jint)
     * }
     */
    public static MemorySegment ReleaseFloatArrayElements(MemorySegment struct) {
        return struct.get(ReleaseFloatArrayElements$LAYOUT, ReleaseFloatArrayElements$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseFloatArrayElements)(JNIEnv *, jfloatArray, jfloat *, jint)
     * }
     */
    public static void ReleaseFloatArrayElements(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseFloatArrayElements$LAYOUT, ReleaseFloatArrayElements$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseDoubleArrayElements)(JNIEnv *, jdoubleArray, jdouble *, jint)
     * }
     */
    public static class ReleaseDoubleArrayElements {

        ReleaseDoubleArrayElements() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(ReleaseDoubleArrayElements.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseDoubleArrayElements.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseDoubleArrayElements$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseDoubleArrayElements"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseDoubleArrayElements)(JNIEnv *, jdoubleArray, jdouble *, jint)
     * }
     */
    public static final AddressLayout ReleaseDoubleArrayElements$layout() {
        return ReleaseDoubleArrayElements$LAYOUT;
    }

    private static final long ReleaseDoubleArrayElements$OFFSET = 1584;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseDoubleArrayElements)(JNIEnv *, jdoubleArray, jdouble *, jint)
     * }
     */
    public static final long ReleaseDoubleArrayElements$offset() {
        return ReleaseDoubleArrayElements$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseDoubleArrayElements)(JNIEnv *, jdoubleArray, jdouble *, jint)
     * }
     */
    public static MemorySegment ReleaseDoubleArrayElements(MemorySegment struct) {
        return struct.get(ReleaseDoubleArrayElements$LAYOUT, ReleaseDoubleArrayElements$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseDoubleArrayElements)(JNIEnv *, jdoubleArray, jdouble *, jint)
     * }
     */
    public static void ReleaseDoubleArrayElements(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseDoubleArrayElements$LAYOUT, ReleaseDoubleArrayElements$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*GetBooleanArrayRegion)(JNIEnv *, jbooleanArray, jsize, jsize, jboolean *)
     * }
     */
    public static class GetBooleanArrayRegion {

        GetBooleanArrayRegion() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetBooleanArrayRegion.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetBooleanArrayRegion.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetBooleanArrayRegion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetBooleanArrayRegion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*GetBooleanArrayRegion)(JNIEnv *, jbooleanArray, jsize, jsize, jboolean *)
     * }
     */
    public static final AddressLayout GetBooleanArrayRegion$layout() {
        return GetBooleanArrayRegion$LAYOUT;
    }

    private static final long GetBooleanArrayRegion$OFFSET = 1592;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*GetBooleanArrayRegion)(JNIEnv *, jbooleanArray, jsize, jsize, jboolean *)
     * }
     */
    public static final long GetBooleanArrayRegion$offset() {
        return GetBooleanArrayRegion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*GetBooleanArrayRegion)(JNIEnv *, jbooleanArray, jsize, jsize, jboolean *)
     * }
     */
    public static MemorySegment GetBooleanArrayRegion(MemorySegment struct) {
        return struct.get(GetBooleanArrayRegion$LAYOUT, GetBooleanArrayRegion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*GetBooleanArrayRegion)(JNIEnv *, jbooleanArray, jsize, jsize, jboolean *)
     * }
     */
    public static void GetBooleanArrayRegion(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetBooleanArrayRegion$LAYOUT, GetBooleanArrayRegion$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*GetByteArrayRegion)(JNIEnv *, jbyteArray, jsize, jsize, jbyte *)
     * }
     */
    public static class GetByteArrayRegion {

        GetByteArrayRegion() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetByteArrayRegion.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetByteArrayRegion.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetByteArrayRegion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetByteArrayRegion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*GetByteArrayRegion)(JNIEnv *, jbyteArray, jsize, jsize, jbyte *)
     * }
     */
    public static final AddressLayout GetByteArrayRegion$layout() {
        return GetByteArrayRegion$LAYOUT;
    }

    private static final long GetByteArrayRegion$OFFSET = 1600;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*GetByteArrayRegion)(JNIEnv *, jbyteArray, jsize, jsize, jbyte *)
     * }
     */
    public static final long GetByteArrayRegion$offset() {
        return GetByteArrayRegion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*GetByteArrayRegion)(JNIEnv *, jbyteArray, jsize, jsize, jbyte *)
     * }
     */
    public static MemorySegment GetByteArrayRegion(MemorySegment struct) {
        return struct.get(GetByteArrayRegion$LAYOUT, GetByteArrayRegion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*GetByteArrayRegion)(JNIEnv *, jbyteArray, jsize, jsize, jbyte *)
     * }
     */
    public static void GetByteArrayRegion(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetByteArrayRegion$LAYOUT, GetByteArrayRegion$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*GetCharArrayRegion)(JNIEnv *, jcharArray, jsize, jsize, jchar *)
     * }
     */
    public static class GetCharArrayRegion {

        GetCharArrayRegion() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetCharArrayRegion.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetCharArrayRegion.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetCharArrayRegion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetCharArrayRegion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*GetCharArrayRegion)(JNIEnv *, jcharArray, jsize, jsize, jchar *)
     * }
     */
    public static final AddressLayout GetCharArrayRegion$layout() {
        return GetCharArrayRegion$LAYOUT;
    }

    private static final long GetCharArrayRegion$OFFSET = 1608;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*GetCharArrayRegion)(JNIEnv *, jcharArray, jsize, jsize, jchar *)
     * }
     */
    public static final long GetCharArrayRegion$offset() {
        return GetCharArrayRegion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*GetCharArrayRegion)(JNIEnv *, jcharArray, jsize, jsize, jchar *)
     * }
     */
    public static MemorySegment GetCharArrayRegion(MemorySegment struct) {
        return struct.get(GetCharArrayRegion$LAYOUT, GetCharArrayRegion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*GetCharArrayRegion)(JNIEnv *, jcharArray, jsize, jsize, jchar *)
     * }
     */
    public static void GetCharArrayRegion(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetCharArrayRegion$LAYOUT, GetCharArrayRegion$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*GetShortArrayRegion)(JNIEnv *, jshortArray, jsize, jsize, jshort *)
     * }
     */
    public static class GetShortArrayRegion {

        GetShortArrayRegion() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetShortArrayRegion.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetShortArrayRegion.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetShortArrayRegion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetShortArrayRegion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*GetShortArrayRegion)(JNIEnv *, jshortArray, jsize, jsize, jshort *)
     * }
     */
    public static final AddressLayout GetShortArrayRegion$layout() {
        return GetShortArrayRegion$LAYOUT;
    }

    private static final long GetShortArrayRegion$OFFSET = 1616;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*GetShortArrayRegion)(JNIEnv *, jshortArray, jsize, jsize, jshort *)
     * }
     */
    public static final long GetShortArrayRegion$offset() {
        return GetShortArrayRegion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*GetShortArrayRegion)(JNIEnv *, jshortArray, jsize, jsize, jshort *)
     * }
     */
    public static MemorySegment GetShortArrayRegion(MemorySegment struct) {
        return struct.get(GetShortArrayRegion$LAYOUT, GetShortArrayRegion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*GetShortArrayRegion)(JNIEnv *, jshortArray, jsize, jsize, jshort *)
     * }
     */
    public static void GetShortArrayRegion(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetShortArrayRegion$LAYOUT, GetShortArrayRegion$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*GetIntArrayRegion)(JNIEnv *, jintArray, jsize, jsize, jint *)
     * }
     */
    public static class GetIntArrayRegion {

        GetIntArrayRegion() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetIntArrayRegion.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetIntArrayRegion.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetIntArrayRegion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetIntArrayRegion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*GetIntArrayRegion)(JNIEnv *, jintArray, jsize, jsize, jint *)
     * }
     */
    public static final AddressLayout GetIntArrayRegion$layout() {
        return GetIntArrayRegion$LAYOUT;
    }

    private static final long GetIntArrayRegion$OFFSET = 1624;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*GetIntArrayRegion)(JNIEnv *, jintArray, jsize, jsize, jint *)
     * }
     */
    public static final long GetIntArrayRegion$offset() {
        return GetIntArrayRegion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*GetIntArrayRegion)(JNIEnv *, jintArray, jsize, jsize, jint *)
     * }
     */
    public static MemorySegment GetIntArrayRegion(MemorySegment struct) {
        return struct.get(GetIntArrayRegion$LAYOUT, GetIntArrayRegion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*GetIntArrayRegion)(JNIEnv *, jintArray, jsize, jsize, jint *)
     * }
     */
    public static void GetIntArrayRegion(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetIntArrayRegion$LAYOUT, GetIntArrayRegion$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*GetLongArrayRegion)(JNIEnv *, jlongArray, jsize, jsize, jlong *)
     * }
     */
    public static class GetLongArrayRegion {

        GetLongArrayRegion() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetLongArrayRegion.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetLongArrayRegion.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetLongArrayRegion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetLongArrayRegion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*GetLongArrayRegion)(JNIEnv *, jlongArray, jsize, jsize, jlong *)
     * }
     */
    public static final AddressLayout GetLongArrayRegion$layout() {
        return GetLongArrayRegion$LAYOUT;
    }

    private static final long GetLongArrayRegion$OFFSET = 1632;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*GetLongArrayRegion)(JNIEnv *, jlongArray, jsize, jsize, jlong *)
     * }
     */
    public static final long GetLongArrayRegion$offset() {
        return GetLongArrayRegion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*GetLongArrayRegion)(JNIEnv *, jlongArray, jsize, jsize, jlong *)
     * }
     */
    public static MemorySegment GetLongArrayRegion(MemorySegment struct) {
        return struct.get(GetLongArrayRegion$LAYOUT, GetLongArrayRegion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*GetLongArrayRegion)(JNIEnv *, jlongArray, jsize, jsize, jlong *)
     * }
     */
    public static void GetLongArrayRegion(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetLongArrayRegion$LAYOUT, GetLongArrayRegion$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*GetFloatArrayRegion)(JNIEnv *, jfloatArray, jsize, jsize, jfloat *)
     * }
     */
    public static class GetFloatArrayRegion {

        GetFloatArrayRegion() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetFloatArrayRegion.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetFloatArrayRegion.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetFloatArrayRegion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetFloatArrayRegion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*GetFloatArrayRegion)(JNIEnv *, jfloatArray, jsize, jsize, jfloat *)
     * }
     */
    public static final AddressLayout GetFloatArrayRegion$layout() {
        return GetFloatArrayRegion$LAYOUT;
    }

    private static final long GetFloatArrayRegion$OFFSET = 1640;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*GetFloatArrayRegion)(JNIEnv *, jfloatArray, jsize, jsize, jfloat *)
     * }
     */
    public static final long GetFloatArrayRegion$offset() {
        return GetFloatArrayRegion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*GetFloatArrayRegion)(JNIEnv *, jfloatArray, jsize, jsize, jfloat *)
     * }
     */
    public static MemorySegment GetFloatArrayRegion(MemorySegment struct) {
        return struct.get(GetFloatArrayRegion$LAYOUT, GetFloatArrayRegion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*GetFloatArrayRegion)(JNIEnv *, jfloatArray, jsize, jsize, jfloat *)
     * }
     */
    public static void GetFloatArrayRegion(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetFloatArrayRegion$LAYOUT, GetFloatArrayRegion$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*GetDoubleArrayRegion)(JNIEnv *, jdoubleArray, jsize, jsize, jdouble *)
     * }
     */
    public static class GetDoubleArrayRegion {

        GetDoubleArrayRegion() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetDoubleArrayRegion.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetDoubleArrayRegion.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetDoubleArrayRegion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetDoubleArrayRegion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*GetDoubleArrayRegion)(JNIEnv *, jdoubleArray, jsize, jsize, jdouble *)
     * }
     */
    public static final AddressLayout GetDoubleArrayRegion$layout() {
        return GetDoubleArrayRegion$LAYOUT;
    }

    private static final long GetDoubleArrayRegion$OFFSET = 1648;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*GetDoubleArrayRegion)(JNIEnv *, jdoubleArray, jsize, jsize, jdouble *)
     * }
     */
    public static final long GetDoubleArrayRegion$offset() {
        return GetDoubleArrayRegion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*GetDoubleArrayRegion)(JNIEnv *, jdoubleArray, jsize, jsize, jdouble *)
     * }
     */
    public static MemorySegment GetDoubleArrayRegion(MemorySegment struct) {
        return struct.get(GetDoubleArrayRegion$LAYOUT, GetDoubleArrayRegion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*GetDoubleArrayRegion)(JNIEnv *, jdoubleArray, jsize, jsize, jdouble *)
     * }
     */
    public static void GetDoubleArrayRegion(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetDoubleArrayRegion$LAYOUT, GetDoubleArrayRegion$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetBooleanArrayRegion)(JNIEnv *, jbooleanArray, jsize, jsize, const jboolean *)
     * }
     */
    public static class SetBooleanArrayRegion {

        SetBooleanArrayRegion() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetBooleanArrayRegion.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetBooleanArrayRegion.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetBooleanArrayRegion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetBooleanArrayRegion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetBooleanArrayRegion)(JNIEnv *, jbooleanArray, jsize, jsize, const jboolean *)
     * }
     */
    public static final AddressLayout SetBooleanArrayRegion$layout() {
        return SetBooleanArrayRegion$LAYOUT;
    }

    private static final long SetBooleanArrayRegion$OFFSET = 1656;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetBooleanArrayRegion)(JNIEnv *, jbooleanArray, jsize, jsize, const jboolean *)
     * }
     */
    public static final long SetBooleanArrayRegion$offset() {
        return SetBooleanArrayRegion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetBooleanArrayRegion)(JNIEnv *, jbooleanArray, jsize, jsize, const jboolean *)
     * }
     */
    public static MemorySegment SetBooleanArrayRegion(MemorySegment struct) {
        return struct.get(SetBooleanArrayRegion$LAYOUT, SetBooleanArrayRegion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetBooleanArrayRegion)(JNIEnv *, jbooleanArray, jsize, jsize, const jboolean *)
     * }
     */
    public static void SetBooleanArrayRegion(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetBooleanArrayRegion$LAYOUT, SetBooleanArrayRegion$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetByteArrayRegion)(JNIEnv *, jbyteArray, jsize, jsize, const jbyte *)
     * }
     */
    public static class SetByteArrayRegion {

        SetByteArrayRegion() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetByteArrayRegion.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetByteArrayRegion.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetByteArrayRegion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetByteArrayRegion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetByteArrayRegion)(JNIEnv *, jbyteArray, jsize, jsize, const jbyte *)
     * }
     */
    public static final AddressLayout SetByteArrayRegion$layout() {
        return SetByteArrayRegion$LAYOUT;
    }

    private static final long SetByteArrayRegion$OFFSET = 1664;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetByteArrayRegion)(JNIEnv *, jbyteArray, jsize, jsize, const jbyte *)
     * }
     */
    public static final long SetByteArrayRegion$offset() {
        return SetByteArrayRegion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetByteArrayRegion)(JNIEnv *, jbyteArray, jsize, jsize, const jbyte *)
     * }
     */
    public static MemorySegment SetByteArrayRegion(MemorySegment struct) {
        return struct.get(SetByteArrayRegion$LAYOUT, SetByteArrayRegion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetByteArrayRegion)(JNIEnv *, jbyteArray, jsize, jsize, const jbyte *)
     * }
     */
    public static void SetByteArrayRegion(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetByteArrayRegion$LAYOUT, SetByteArrayRegion$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetCharArrayRegion)(JNIEnv *, jcharArray, jsize, jsize, const jchar *)
     * }
     */
    public static class SetCharArrayRegion {

        SetCharArrayRegion() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetCharArrayRegion.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetCharArrayRegion.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetCharArrayRegion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetCharArrayRegion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetCharArrayRegion)(JNIEnv *, jcharArray, jsize, jsize, const jchar *)
     * }
     */
    public static final AddressLayout SetCharArrayRegion$layout() {
        return SetCharArrayRegion$LAYOUT;
    }

    private static final long SetCharArrayRegion$OFFSET = 1672;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetCharArrayRegion)(JNIEnv *, jcharArray, jsize, jsize, const jchar *)
     * }
     */
    public static final long SetCharArrayRegion$offset() {
        return SetCharArrayRegion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetCharArrayRegion)(JNIEnv *, jcharArray, jsize, jsize, const jchar *)
     * }
     */
    public static MemorySegment SetCharArrayRegion(MemorySegment struct) {
        return struct.get(SetCharArrayRegion$LAYOUT, SetCharArrayRegion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetCharArrayRegion)(JNIEnv *, jcharArray, jsize, jsize, const jchar *)
     * }
     */
    public static void SetCharArrayRegion(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetCharArrayRegion$LAYOUT, SetCharArrayRegion$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetShortArrayRegion)(JNIEnv *, jshortArray, jsize, jsize, const jshort *)
     * }
     */
    public static class SetShortArrayRegion {

        SetShortArrayRegion() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetShortArrayRegion.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetShortArrayRegion.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetShortArrayRegion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetShortArrayRegion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetShortArrayRegion)(JNIEnv *, jshortArray, jsize, jsize, const jshort *)
     * }
     */
    public static final AddressLayout SetShortArrayRegion$layout() {
        return SetShortArrayRegion$LAYOUT;
    }

    private static final long SetShortArrayRegion$OFFSET = 1680;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetShortArrayRegion)(JNIEnv *, jshortArray, jsize, jsize, const jshort *)
     * }
     */
    public static final long SetShortArrayRegion$offset() {
        return SetShortArrayRegion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetShortArrayRegion)(JNIEnv *, jshortArray, jsize, jsize, const jshort *)
     * }
     */
    public static MemorySegment SetShortArrayRegion(MemorySegment struct) {
        return struct.get(SetShortArrayRegion$LAYOUT, SetShortArrayRegion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetShortArrayRegion)(JNIEnv *, jshortArray, jsize, jsize, const jshort *)
     * }
     */
    public static void SetShortArrayRegion(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetShortArrayRegion$LAYOUT, SetShortArrayRegion$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetIntArrayRegion)(JNIEnv *, jintArray, jsize, jsize, const jint *)
     * }
     */
    public static class SetIntArrayRegion {

        SetIntArrayRegion() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetIntArrayRegion.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetIntArrayRegion.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetIntArrayRegion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetIntArrayRegion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetIntArrayRegion)(JNIEnv *, jintArray, jsize, jsize, const jint *)
     * }
     */
    public static final AddressLayout SetIntArrayRegion$layout() {
        return SetIntArrayRegion$LAYOUT;
    }

    private static final long SetIntArrayRegion$OFFSET = 1688;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetIntArrayRegion)(JNIEnv *, jintArray, jsize, jsize, const jint *)
     * }
     */
    public static final long SetIntArrayRegion$offset() {
        return SetIntArrayRegion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetIntArrayRegion)(JNIEnv *, jintArray, jsize, jsize, const jint *)
     * }
     */
    public static MemorySegment SetIntArrayRegion(MemorySegment struct) {
        return struct.get(SetIntArrayRegion$LAYOUT, SetIntArrayRegion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetIntArrayRegion)(JNIEnv *, jintArray, jsize, jsize, const jint *)
     * }
     */
    public static void SetIntArrayRegion(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetIntArrayRegion$LAYOUT, SetIntArrayRegion$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetLongArrayRegion)(JNIEnv *, jlongArray, jsize, jsize, const jlong *)
     * }
     */
    public static class SetLongArrayRegion {

        SetLongArrayRegion() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetLongArrayRegion.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetLongArrayRegion.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetLongArrayRegion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetLongArrayRegion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetLongArrayRegion)(JNIEnv *, jlongArray, jsize, jsize, const jlong *)
     * }
     */
    public static final AddressLayout SetLongArrayRegion$layout() {
        return SetLongArrayRegion$LAYOUT;
    }

    private static final long SetLongArrayRegion$OFFSET = 1696;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetLongArrayRegion)(JNIEnv *, jlongArray, jsize, jsize, const jlong *)
     * }
     */
    public static final long SetLongArrayRegion$offset() {
        return SetLongArrayRegion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetLongArrayRegion)(JNIEnv *, jlongArray, jsize, jsize, const jlong *)
     * }
     */
    public static MemorySegment SetLongArrayRegion(MemorySegment struct) {
        return struct.get(SetLongArrayRegion$LAYOUT, SetLongArrayRegion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetLongArrayRegion)(JNIEnv *, jlongArray, jsize, jsize, const jlong *)
     * }
     */
    public static void SetLongArrayRegion(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetLongArrayRegion$LAYOUT, SetLongArrayRegion$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetFloatArrayRegion)(JNIEnv *, jfloatArray, jsize, jsize, const jfloat *)
     * }
     */
    public static class SetFloatArrayRegion {

        SetFloatArrayRegion() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetFloatArrayRegion.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetFloatArrayRegion.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetFloatArrayRegion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetFloatArrayRegion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetFloatArrayRegion)(JNIEnv *, jfloatArray, jsize, jsize, const jfloat *)
     * }
     */
    public static final AddressLayout SetFloatArrayRegion$layout() {
        return SetFloatArrayRegion$LAYOUT;
    }

    private static final long SetFloatArrayRegion$OFFSET = 1704;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetFloatArrayRegion)(JNIEnv *, jfloatArray, jsize, jsize, const jfloat *)
     * }
     */
    public static final long SetFloatArrayRegion$offset() {
        return SetFloatArrayRegion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetFloatArrayRegion)(JNIEnv *, jfloatArray, jsize, jsize, const jfloat *)
     * }
     */
    public static MemorySegment SetFloatArrayRegion(MemorySegment struct) {
        return struct.get(SetFloatArrayRegion$LAYOUT, SetFloatArrayRegion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetFloatArrayRegion)(JNIEnv *, jfloatArray, jsize, jsize, const jfloat *)
     * }
     */
    public static void SetFloatArrayRegion(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetFloatArrayRegion$LAYOUT, SetFloatArrayRegion$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*SetDoubleArrayRegion)(JNIEnv *, jdoubleArray, jsize, jsize, const jdouble *)
     * }
     */
    public static class SetDoubleArrayRegion {

        SetDoubleArrayRegion() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(SetDoubleArrayRegion.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetDoubleArrayRegion.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout SetDoubleArrayRegion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("SetDoubleArrayRegion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*SetDoubleArrayRegion)(JNIEnv *, jdoubleArray, jsize, jsize, const jdouble *)
     * }
     */
    public static final AddressLayout SetDoubleArrayRegion$layout() {
        return SetDoubleArrayRegion$LAYOUT;
    }

    private static final long SetDoubleArrayRegion$OFFSET = 1712;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*SetDoubleArrayRegion)(JNIEnv *, jdoubleArray, jsize, jsize, const jdouble *)
     * }
     */
    public static final long SetDoubleArrayRegion$offset() {
        return SetDoubleArrayRegion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*SetDoubleArrayRegion)(JNIEnv *, jdoubleArray, jsize, jsize, const jdouble *)
     * }
     */
    public static MemorySegment SetDoubleArrayRegion(MemorySegment struct) {
        return struct.get(SetDoubleArrayRegion$LAYOUT, SetDoubleArrayRegion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*SetDoubleArrayRegion)(JNIEnv *, jdoubleArray, jsize, jsize, const jdouble *)
     * }
     */
    public static void SetDoubleArrayRegion(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetDoubleArrayRegion$LAYOUT, SetDoubleArrayRegion$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jint (*RegisterNatives)(JNIEnv *, jclass, const JNINativeMethod *, jint)
     * }
     */
    public static class RegisterNatives {

        RegisterNatives() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(RegisterNatives.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RegisterNatives.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout RegisterNatives$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("RegisterNatives"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jint (*RegisterNatives)(JNIEnv *, jclass, const JNINativeMethod *, jint)
     * }
     */
    public static final AddressLayout RegisterNatives$layout() {
        return RegisterNatives$LAYOUT;
    }

    private static final long RegisterNatives$OFFSET = 1720;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jint (*RegisterNatives)(JNIEnv *, jclass, const JNINativeMethod *, jint)
     * }
     */
    public static final long RegisterNatives$offset() {
        return RegisterNatives$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jint (*RegisterNatives)(JNIEnv *, jclass, const JNINativeMethod *, jint)
     * }
     */
    public static MemorySegment RegisterNatives(MemorySegment struct) {
        return struct.get(RegisterNatives$LAYOUT, RegisterNatives$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jint (*RegisterNatives)(JNIEnv *, jclass, const JNINativeMethod *, jint)
     * }
     */
    public static void RegisterNatives(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RegisterNatives$LAYOUT, RegisterNatives$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jint (*UnregisterNatives)(JNIEnv *, jclass)
     * }
     */
    public static class UnregisterNatives {

        UnregisterNatives() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(UnregisterNatives.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(UnregisterNatives.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout UnregisterNatives$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("UnregisterNatives"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jint (*UnregisterNatives)(JNIEnv *, jclass)
     * }
     */
    public static final AddressLayout UnregisterNatives$layout() {
        return UnregisterNatives$LAYOUT;
    }

    private static final long UnregisterNatives$OFFSET = 1728;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jint (*UnregisterNatives)(JNIEnv *, jclass)
     * }
     */
    public static final long UnregisterNatives$offset() {
        return UnregisterNatives$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jint (*UnregisterNatives)(JNIEnv *, jclass)
     * }
     */
    public static MemorySegment UnregisterNatives(MemorySegment struct) {
        return struct.get(UnregisterNatives$LAYOUT, UnregisterNatives$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jint (*UnregisterNatives)(JNIEnv *, jclass)
     * }
     */
    public static void UnregisterNatives(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(UnregisterNatives$LAYOUT, UnregisterNatives$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jint (*MonitorEnter)(JNIEnv *, jobject)
     * }
     */
    public static class MonitorEnter {

        MonitorEnter() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(MonitorEnter.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(MonitorEnter.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout MonitorEnter$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("MonitorEnter"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jint (*MonitorEnter)(JNIEnv *, jobject)
     * }
     */
    public static final AddressLayout MonitorEnter$layout() {
        return MonitorEnter$LAYOUT;
    }

    private static final long MonitorEnter$OFFSET = 1736;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jint (*MonitorEnter)(JNIEnv *, jobject)
     * }
     */
    public static final long MonitorEnter$offset() {
        return MonitorEnter$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jint (*MonitorEnter)(JNIEnv *, jobject)
     * }
     */
    public static MemorySegment MonitorEnter(MemorySegment struct) {
        return struct.get(MonitorEnter$LAYOUT, MonitorEnter$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jint (*MonitorEnter)(JNIEnv *, jobject)
     * }
     */
    public static void MonitorEnter(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(MonitorEnter$LAYOUT, MonitorEnter$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jint (*MonitorExit)(JNIEnv *, jobject)
     * }
     */
    public static class MonitorExit {

        MonitorExit() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(MonitorExit.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(MonitorExit.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout MonitorExit$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("MonitorExit"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jint (*MonitorExit)(JNIEnv *, jobject)
     * }
     */
    public static final AddressLayout MonitorExit$layout() {
        return MonitorExit$LAYOUT;
    }

    private static final long MonitorExit$OFFSET = 1744;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jint (*MonitorExit)(JNIEnv *, jobject)
     * }
     */
    public static final long MonitorExit$offset() {
        return MonitorExit$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jint (*MonitorExit)(JNIEnv *, jobject)
     * }
     */
    public static MemorySegment MonitorExit(MemorySegment struct) {
        return struct.get(MonitorExit$LAYOUT, MonitorExit$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jint (*MonitorExit)(JNIEnv *, jobject)
     * }
     */
    public static void MonitorExit(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(MonitorExit$LAYOUT, MonitorExit$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jint (*GetJavaVM)(JNIEnv *, JavaVM **)
     * }
     */
    public static class GetJavaVM {

        GetJavaVM() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetJavaVM.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetJavaVM.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetJavaVM$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetJavaVM"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jint (*GetJavaVM)(JNIEnv *, JavaVM **)
     * }
     */
    public static final AddressLayout GetJavaVM$layout() {
        return GetJavaVM$LAYOUT;
    }

    private static final long GetJavaVM$OFFSET = 1752;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jint (*GetJavaVM)(JNIEnv *, JavaVM **)
     * }
     */
    public static final long GetJavaVM$offset() {
        return GetJavaVM$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jint (*GetJavaVM)(JNIEnv *, JavaVM **)
     * }
     */
    public static MemorySegment GetJavaVM(MemorySegment struct) {
        return struct.get(GetJavaVM$LAYOUT, GetJavaVM$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jint (*GetJavaVM)(JNIEnv *, JavaVM **)
     * }
     */
    public static void GetJavaVM(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetJavaVM$LAYOUT, GetJavaVM$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*GetStringRegion)(JNIEnv *, jstring, jsize, jsize, jchar *)
     * }
     */
    public static class GetStringRegion {

        GetStringRegion() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetStringRegion.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStringRegion.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStringRegion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStringRegion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*GetStringRegion)(JNIEnv *, jstring, jsize, jsize, jchar *)
     * }
     */
    public static final AddressLayout GetStringRegion$layout() {
        return GetStringRegion$LAYOUT;
    }

    private static final long GetStringRegion$OFFSET = 1760;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*GetStringRegion)(JNIEnv *, jstring, jsize, jsize, jchar *)
     * }
     */
    public static final long GetStringRegion$offset() {
        return GetStringRegion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*GetStringRegion)(JNIEnv *, jstring, jsize, jsize, jchar *)
     * }
     */
    public static MemorySegment GetStringRegion(MemorySegment struct) {
        return struct.get(GetStringRegion$LAYOUT, GetStringRegion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*GetStringRegion)(JNIEnv *, jstring, jsize, jsize, jchar *)
     * }
     */
    public static void GetStringRegion(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStringRegion$LAYOUT, GetStringRegion$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*GetStringUTFRegion)(JNIEnv *, jstring, jsize, jsize, char *)
     * }
     */
    public static class GetStringUTFRegion {

        GetStringUTFRegion() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetStringUTFRegion.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStringUTFRegion.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStringUTFRegion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStringUTFRegion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*GetStringUTFRegion)(JNIEnv *, jstring, jsize, jsize, char *)
     * }
     */
    public static final AddressLayout GetStringUTFRegion$layout() {
        return GetStringUTFRegion$LAYOUT;
    }

    private static final long GetStringUTFRegion$OFFSET = 1768;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*GetStringUTFRegion)(JNIEnv *, jstring, jsize, jsize, char *)
     * }
     */
    public static final long GetStringUTFRegion$offset() {
        return GetStringUTFRegion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*GetStringUTFRegion)(JNIEnv *, jstring, jsize, jsize, char *)
     * }
     */
    public static MemorySegment GetStringUTFRegion(MemorySegment struct) {
        return struct.get(GetStringUTFRegion$LAYOUT, GetStringUTFRegion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*GetStringUTFRegion)(JNIEnv *, jstring, jsize, jsize, char *)
     * }
     */
    public static void GetStringUTFRegion(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStringUTFRegion$LAYOUT, GetStringUTFRegion$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*GetPrimitiveArrayCritical)(JNIEnv *, jarray, jboolean *)
     * }
     */
    public static class GetPrimitiveArrayCritical {

        GetPrimitiveArrayCritical() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetPrimitiveArrayCritical.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetPrimitiveArrayCritical.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetPrimitiveArrayCritical$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetPrimitiveArrayCritical"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*GetPrimitiveArrayCritical)(JNIEnv *, jarray, jboolean *)
     * }
     */
    public static final AddressLayout GetPrimitiveArrayCritical$layout() {
        return GetPrimitiveArrayCritical$LAYOUT;
    }

    private static final long GetPrimitiveArrayCritical$OFFSET = 1776;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*GetPrimitiveArrayCritical)(JNIEnv *, jarray, jboolean *)
     * }
     */
    public static final long GetPrimitiveArrayCritical$offset() {
        return GetPrimitiveArrayCritical$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*GetPrimitiveArrayCritical)(JNIEnv *, jarray, jboolean *)
     * }
     */
    public static MemorySegment GetPrimitiveArrayCritical(MemorySegment struct) {
        return struct.get(GetPrimitiveArrayCritical$LAYOUT, GetPrimitiveArrayCritical$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*GetPrimitiveArrayCritical)(JNIEnv *, jarray, jboolean *)
     * }
     */
    public static void GetPrimitiveArrayCritical(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetPrimitiveArrayCritical$LAYOUT, GetPrimitiveArrayCritical$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleasePrimitiveArrayCritical)(JNIEnv *, jarray, void *, jint)
     * }
     */
    public static class ReleasePrimitiveArrayCritical {

        ReleasePrimitiveArrayCritical() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(ReleasePrimitiveArrayCritical.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleasePrimitiveArrayCritical.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleasePrimitiveArrayCritical$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleasePrimitiveArrayCritical"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleasePrimitiveArrayCritical)(JNIEnv *, jarray, void *, jint)
     * }
     */
    public static final AddressLayout ReleasePrimitiveArrayCritical$layout() {
        return ReleasePrimitiveArrayCritical$LAYOUT;
    }

    private static final long ReleasePrimitiveArrayCritical$OFFSET = 1784;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleasePrimitiveArrayCritical)(JNIEnv *, jarray, void *, jint)
     * }
     */
    public static final long ReleasePrimitiveArrayCritical$offset() {
        return ReleasePrimitiveArrayCritical$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleasePrimitiveArrayCritical)(JNIEnv *, jarray, void *, jint)
     * }
     */
    public static MemorySegment ReleasePrimitiveArrayCritical(MemorySegment struct) {
        return struct.get(ReleasePrimitiveArrayCritical$LAYOUT, ReleasePrimitiveArrayCritical$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleasePrimitiveArrayCritical)(JNIEnv *, jarray, void *, jint)
     * }
     */
    public static void ReleasePrimitiveArrayCritical(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleasePrimitiveArrayCritical$LAYOUT, ReleasePrimitiveArrayCritical$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * const jchar *(*GetStringCritical)(JNIEnv *, jstring, jboolean *)
     * }
     */
    public static class GetStringCritical {

        GetStringCritical() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetStringCritical.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStringCritical.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetStringCritical$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetStringCritical"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const jchar *(*GetStringCritical)(JNIEnv *, jstring, jboolean *)
     * }
     */
    public static final AddressLayout GetStringCritical$layout() {
        return GetStringCritical$LAYOUT;
    }

    private static final long GetStringCritical$OFFSET = 1792;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const jchar *(*GetStringCritical)(JNIEnv *, jstring, jboolean *)
     * }
     */
    public static final long GetStringCritical$offset() {
        return GetStringCritical$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const jchar *(*GetStringCritical)(JNIEnv *, jstring, jboolean *)
     * }
     */
    public static MemorySegment GetStringCritical(MemorySegment struct) {
        return struct.get(GetStringCritical$LAYOUT, GetStringCritical$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const jchar *(*GetStringCritical)(JNIEnv *, jstring, jboolean *)
     * }
     */
    public static void GetStringCritical(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStringCritical$LAYOUT, GetStringCritical$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseStringCritical)(JNIEnv *, jstring, const jchar *)
     * }
     */
    public static class ReleaseStringCritical {

        ReleaseStringCritical() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(ReleaseStringCritical.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseStringCritical.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ReleaseStringCritical$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ReleaseStringCritical"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseStringCritical)(JNIEnv *, jstring, const jchar *)
     * }
     */
    public static final AddressLayout ReleaseStringCritical$layout() {
        return ReleaseStringCritical$LAYOUT;
    }

    private static final long ReleaseStringCritical$OFFSET = 1800;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseStringCritical)(JNIEnv *, jstring, const jchar *)
     * }
     */
    public static final long ReleaseStringCritical$offset() {
        return ReleaseStringCritical$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseStringCritical)(JNIEnv *, jstring, const jchar *)
     * }
     */
    public static MemorySegment ReleaseStringCritical(MemorySegment struct) {
        return struct.get(ReleaseStringCritical$LAYOUT, ReleaseStringCritical$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseStringCritical)(JNIEnv *, jstring, const jchar *)
     * }
     */
    public static void ReleaseStringCritical(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseStringCritical$LAYOUT, ReleaseStringCritical$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jweak (*NewWeakGlobalRef)(JNIEnv *, jobject)
     * }
     */
    public static class NewWeakGlobalRef {

        NewWeakGlobalRef() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(NewWeakGlobalRef.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(NewWeakGlobalRef.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout NewWeakGlobalRef$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("NewWeakGlobalRef"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jweak (*NewWeakGlobalRef)(JNIEnv *, jobject)
     * }
     */
    public static final AddressLayout NewWeakGlobalRef$layout() {
        return NewWeakGlobalRef$LAYOUT;
    }

    private static final long NewWeakGlobalRef$OFFSET = 1808;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jweak (*NewWeakGlobalRef)(JNIEnv *, jobject)
     * }
     */
    public static final long NewWeakGlobalRef$offset() {
        return NewWeakGlobalRef$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jweak (*NewWeakGlobalRef)(JNIEnv *, jobject)
     * }
     */
    public static MemorySegment NewWeakGlobalRef(MemorySegment struct) {
        return struct.get(NewWeakGlobalRef$LAYOUT, NewWeakGlobalRef$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jweak (*NewWeakGlobalRef)(JNIEnv *, jobject)
     * }
     */
    public static void NewWeakGlobalRef(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(NewWeakGlobalRef$LAYOUT, NewWeakGlobalRef$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*DeleteWeakGlobalRef)(JNIEnv *, jweak)
     * }
     */
    public static class DeleteWeakGlobalRef {

        DeleteWeakGlobalRef() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(DeleteWeakGlobalRef.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(DeleteWeakGlobalRef.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout DeleteWeakGlobalRef$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("DeleteWeakGlobalRef"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*DeleteWeakGlobalRef)(JNIEnv *, jweak)
     * }
     */
    public static final AddressLayout DeleteWeakGlobalRef$layout() {
        return DeleteWeakGlobalRef$LAYOUT;
    }

    private static final long DeleteWeakGlobalRef$OFFSET = 1816;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*DeleteWeakGlobalRef)(JNIEnv *, jweak)
     * }
     */
    public static final long DeleteWeakGlobalRef$offset() {
        return DeleteWeakGlobalRef$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*DeleteWeakGlobalRef)(JNIEnv *, jweak)
     * }
     */
    public static MemorySegment DeleteWeakGlobalRef(MemorySegment struct) {
        return struct.get(DeleteWeakGlobalRef$LAYOUT, DeleteWeakGlobalRef$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*DeleteWeakGlobalRef)(JNIEnv *, jweak)
     * }
     */
    public static void DeleteWeakGlobalRef(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(DeleteWeakGlobalRef$LAYOUT, DeleteWeakGlobalRef$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jboolean (*ExceptionCheck)(JNIEnv *)
     * }
     */
    public static class ExceptionCheck {

        ExceptionCheck() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            byte apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_CHAR,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(ExceptionCheck.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ExceptionCheck.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static byte invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (byte) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ExceptionCheck$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ExceptionCheck"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jboolean (*ExceptionCheck)(JNIEnv *)
     * }
     */
    public static final AddressLayout ExceptionCheck$layout() {
        return ExceptionCheck$LAYOUT;
    }

    private static final long ExceptionCheck$OFFSET = 1824;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jboolean (*ExceptionCheck)(JNIEnv *)
     * }
     */
    public static final long ExceptionCheck$offset() {
        return ExceptionCheck$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jboolean (*ExceptionCheck)(JNIEnv *)
     * }
     */
    public static MemorySegment ExceptionCheck(MemorySegment struct) {
        return struct.get(ExceptionCheck$LAYOUT, ExceptionCheck$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jboolean (*ExceptionCheck)(JNIEnv *)
     * }
     */
    public static void ExceptionCheck(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ExceptionCheck$LAYOUT, ExceptionCheck$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jobject (*NewDirectByteBuffer)(JNIEnv *, void *, jlong)
     * }
     */
    public static class NewDirectByteBuffer {

        NewDirectByteBuffer() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(NewDirectByteBuffer.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(NewDirectByteBuffer.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout NewDirectByteBuffer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("NewDirectByteBuffer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jobject (*NewDirectByteBuffer)(JNIEnv *, void *, jlong)
     * }
     */
    public static final AddressLayout NewDirectByteBuffer$layout() {
        return NewDirectByteBuffer$LAYOUT;
    }

    private static final long NewDirectByteBuffer$OFFSET = 1832;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jobject (*NewDirectByteBuffer)(JNIEnv *, void *, jlong)
     * }
     */
    public static final long NewDirectByteBuffer$offset() {
        return NewDirectByteBuffer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jobject (*NewDirectByteBuffer)(JNIEnv *, void *, jlong)
     * }
     */
    public static MemorySegment NewDirectByteBuffer(MemorySegment struct) {
        return struct.get(NewDirectByteBuffer$LAYOUT, NewDirectByteBuffer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jobject (*NewDirectByteBuffer)(JNIEnv *, void *, jlong)
     * }
     */
    public static void NewDirectByteBuffer(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(NewDirectByteBuffer$LAYOUT, NewDirectByteBuffer$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*GetDirectBufferAddress)(JNIEnv *, jobject)
     * }
     */
    public static class GetDirectBufferAddress {

        GetDirectBufferAddress() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetDirectBufferAddress.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetDirectBufferAddress.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetDirectBufferAddress$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetDirectBufferAddress"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*GetDirectBufferAddress)(JNIEnv *, jobject)
     * }
     */
    public static final AddressLayout GetDirectBufferAddress$layout() {
        return GetDirectBufferAddress$LAYOUT;
    }

    private static final long GetDirectBufferAddress$OFFSET = 1840;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*GetDirectBufferAddress)(JNIEnv *, jobject)
     * }
     */
    public static final long GetDirectBufferAddress$offset() {
        return GetDirectBufferAddress$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*GetDirectBufferAddress)(JNIEnv *, jobject)
     * }
     */
    public static MemorySegment GetDirectBufferAddress(MemorySegment struct) {
        return struct.get(GetDirectBufferAddress$LAYOUT, GetDirectBufferAddress$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*GetDirectBufferAddress)(JNIEnv *, jobject)
     * }
     */
    public static void GetDirectBufferAddress(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetDirectBufferAddress$LAYOUT, GetDirectBufferAddress$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jlong (*GetDirectBufferCapacity)(JNIEnv *, jobject)
     * }
     */
    public static class GetDirectBufferCapacity {

        GetDirectBufferCapacity() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_LONG,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetDirectBufferCapacity.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetDirectBufferCapacity.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetDirectBufferCapacity$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetDirectBufferCapacity"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jlong (*GetDirectBufferCapacity)(JNIEnv *, jobject)
     * }
     */
    public static final AddressLayout GetDirectBufferCapacity$layout() {
        return GetDirectBufferCapacity$LAYOUT;
    }

    private static final long GetDirectBufferCapacity$OFFSET = 1848;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jlong (*GetDirectBufferCapacity)(JNIEnv *, jobject)
     * }
     */
    public static final long GetDirectBufferCapacity$offset() {
        return GetDirectBufferCapacity$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jlong (*GetDirectBufferCapacity)(JNIEnv *, jobject)
     * }
     */
    public static MemorySegment GetDirectBufferCapacity(MemorySegment struct) {
        return struct.get(GetDirectBufferCapacity$LAYOUT, GetDirectBufferCapacity$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jlong (*GetDirectBufferCapacity)(JNIEnv *, jobject)
     * }
     */
    public static void GetDirectBufferCapacity(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetDirectBufferCapacity$LAYOUT, GetDirectBufferCapacity$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jobjectRefType (*GetObjectRefType)(JNIEnv *, jobject)
     * }
     */
    public static class GetObjectRefType {

        GetObjectRefType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_INT,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetObjectRefType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetObjectRefType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetObjectRefType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetObjectRefType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jobjectRefType (*GetObjectRefType)(JNIEnv *, jobject)
     * }
     */
    public static final AddressLayout GetObjectRefType$layout() {
        return GetObjectRefType$LAYOUT;
    }

    private static final long GetObjectRefType$OFFSET = 1856;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jobjectRefType (*GetObjectRefType)(JNIEnv *, jobject)
     * }
     */
    public static final long GetObjectRefType$offset() {
        return GetObjectRefType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jobjectRefType (*GetObjectRefType)(JNIEnv *, jobject)
     * }
     */
    public static MemorySegment GetObjectRefType(MemorySegment struct) {
        return struct.get(GetObjectRefType$LAYOUT, GetObjectRefType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jobjectRefType (*GetObjectRefType)(JNIEnv *, jobject)
     * }
     */
    public static void GetObjectRefType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetObjectRefType$LAYOUT, GetObjectRefType$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jobject (*GetModule)(JNIEnv *, jclass)
     * }
     */
    public static class GetModule {

        GetModule() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(GetModule.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetModule.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout GetModule$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("GetModule"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jobject (*GetModule)(JNIEnv *, jclass)
     * }
     */
    public static final AddressLayout GetModule$layout() {
        return GetModule$LAYOUT;
    }

    private static final long GetModule$OFFSET = 1864;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jobject (*GetModule)(JNIEnv *, jclass)
     * }
     */
    public static final long GetModule$offset() {
        return GetModule$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jobject (*GetModule)(JNIEnv *, jclass)
     * }
     */
    public static MemorySegment GetModule(MemorySegment struct) {
        return struct.get(GetModule$LAYOUT, GetModule$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jobject (*GetModule)(JNIEnv *, jclass)
     * }
     */
    public static void GetModule(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetModule$LAYOUT, GetModule$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * jboolean (*IsVirtualThread)(JNIEnv *, jobject)
     * }
     */
    public static class IsVirtualThread {

        IsVirtualThread() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            byte apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            netty_unix_socket_h.C_CHAR,
            netty_unix_socket_h.C_POINTER,
            netty_unix_socket_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = netty_unix_socket_h.upcallHandle(IsVirtualThread.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(IsVirtualThread.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static byte invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (byte) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout IsVirtualThread$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("IsVirtualThread"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * jboolean (*IsVirtualThread)(JNIEnv *, jobject)
     * }
     */
    public static final AddressLayout IsVirtualThread$layout() {
        return IsVirtualThread$LAYOUT;
    }

    private static final long IsVirtualThread$OFFSET = 1872;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * jboolean (*IsVirtualThread)(JNIEnv *, jobject)
     * }
     */
    public static final long IsVirtualThread$offset() {
        return IsVirtualThread$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * jboolean (*IsVirtualThread)(JNIEnv *, jobject)
     * }
     */
    public static MemorySegment IsVirtualThread(MemorySegment struct) {
        return struct.get(IsVirtualThread$LAYOUT, IsVirtualThread$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * jboolean (*IsVirtualThread)(JNIEnv *, jobject)
     * }
     */
    public static void IsVirtualThread(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(IsVirtualThread$LAYOUT, IsVirtualThread$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

